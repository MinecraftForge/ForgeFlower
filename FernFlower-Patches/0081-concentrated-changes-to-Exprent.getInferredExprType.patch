From b84e34a3999001b3da2bed7766c1ed2a77bcd100 Mon Sep 17 00:00:00 2001
From: RainWarrior <rainwarrior@fry.su>
Date: Wed, 14 Oct 2015 05:45:41 +0300
Subject: concentrated changes to Exprent.getInferredExprType


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 4ec7fe9d7d34fe35fcd379d608a102d8f40e1734..7c8276c8dd60eac7022378d4b0700d272a333705 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -435,6 +435,7 @@ public class ClassWriter {
       else {
         buffer.append(" = ");
         // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode intruction.
+        initializer.getInferredExprType(descriptor == null? fieldType : descriptor.type);
         buffer.append(initializer.toJava(indent, tracer));
       }
     }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 2760f202f5d1b04570ad3eb59f89c829f050b6ab..3be3b6fb3db44ef1320c3106e7d432dd1579e335 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -912,9 +912,9 @@ public class ExprProcessor implements CodeConstants {
                                          boolean castAlways,
                                          BytecodeMappingTracer tracer) {
 
-    VarType rightType = exprent.getExprType();
+    VarType rightType = exprent.getInferredExprType(leftType);
 
-    TextBuffer res = exprent.toJava(indent, tracer, leftType);
+    TextBuffer res = exprent.toJava(indent, tracer);
 
     boolean cast =
       castAlways ||
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
index efc64b9d98005572eb9752e36d472f7a65358203..8276abdbc032467bcff47d2be07729c0f0e53d44 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
@@ -65,6 +65,12 @@ public class AssignmentExprent extends Exprent {
     return left.getExprType();
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    //System.out.println("infer: " + upperBound + " = " + getExprType());
+    return getExprType();
+  }
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -106,7 +112,7 @@ public class AssignmentExprent extends Exprent {
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     VarType leftType = left.getExprType();
-    VarType rightType = right.getExprType();
+    VarType rightType = right.getInferredExprType(leftType);
 
     boolean fieldInClassInit = false, hiddenField = false;
     if (left.type == Exprent.EXPRENT_FIELD) { // first assignment to a final field. Field name without "this" in front of it
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
index 9d41ec2900c7cbdddfb591598526c009f69148ae..bda80a0333129fd0e1d476e00cd1e6dee18ce98b 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
@@ -74,7 +74,7 @@ public abstract class Exprent implements IMatchable {
     return VarType.VARTYPE_VOID;
   }
 
-  public VarType getGenericExprType() {
+  public VarType getInferredExprType(VarType upperBound) {
     return getExprType();
   }
 
@@ -130,10 +130,6 @@ public abstract class Exprent implements IMatchable {
     throw new RuntimeException("not implemented");
   }
 
-  public TextBuffer toJava(int indent, BytecodeMappingTracer tracer, VarType expectedType) {
-    return toJava(indent, tracer);
-  }
-
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     throw new RuntimeException("not implemented");
   }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
index d4bd68ef9fd192a67843e14504a226250aaf7a85..be95dc1f6242dc3a12cc433384d34700d8c602b3 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
@@ -68,14 +68,15 @@ public class FieldExprent extends Exprent {
   }
 
   @Override
-  public VarType getGenericExprType() {
+  public VarType getInferredExprType(VarType upperBound) {
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
     while(cl != null) {
       StructField ft = cl.getField(name, descriptor.descriptorString);
       if(ft != null && ft.getSignature() != null) {
         return ft.getSignature().type;
       }
-      cl = DecompilerContext.getStructContext().getClass((String)cl.superClass.value);
+      if(cl.superClass == null) cl = null;
+      else cl = DecompilerContext.getStructContext().getClass((String)cl.superClass.value);
     }
     return getExprType();
   }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index 81b6f4e5108eb3e7b73b4962b5695337e5a1e726..ca5e0778987e633aaf5c4f54a63fefe28cb356e0 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -72,6 +72,8 @@ public class InvocationExprent extends Exprent {
   private int invocationTyp = INVOKE_VIRTUAL;
   private List<Exprent> lstParameters = new ArrayList<Exprent>();
 
+  private List<VarType> genericArgs = new ArrayList<VarType>();
+
   public InvocationExprent() {
     super(EXPRENT_INVOCATION);
   }
@@ -163,6 +165,65 @@ public class InvocationExprent extends Exprent {
     return descriptor.ret;
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    //System.out.println("infer: " + instance + " " + classname + "." + name + " " + getExprType() + " " + upperBound);
+    List<StructMethod> matches = getMatchedDescriptors();
+    StructMethod desc = null;
+    if(matches.size() == 1) desc = matches.get(0);
+
+    VarType type = getExprType();
+
+    List<VarType> toAdd = new ArrayList<VarType>();
+    if(upperBound != null/* && upperBound.type == CodeConstants.TYPE_OBJECT && descriptor.ret.type == CodeConstants.TYPE_OBJECT*/) {
+      genericArgs.clear();
+      //System.out.println("0: " + isStatic + " " + desc + " " + upperBound + " " + descriptor.ret + " " + upperBound.isGeneric());
+      /*if(desc == null) {
+        // more harn than gain
+        // Object -> String
+        if(descriptor.ret.value.equals("java/lang/Object") && !descriptor.ret.equals(upperBound)) {
+          genericArgs.add(upperBound);
+          System.out.println("1: " + upperBound + " " + descriptor.ret);
+        }
+        // List -> List<String>
+        if(upperBound.isGeneric()) {
+          List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
+          //System.out.println("22: " + upperBound + " " + leftArgs.get(0));
+          if(leftArgs.size() == 1 && descriptor.ret.equals(upperBound) && leftArgs.get(0).type == CodeConstants.TYPE_OBJECT) {
+            genericArgs.add(leftArgs.get(0));
+            System.out.println("2: " + upperBound.type + " " + upperBound + " " + leftArgs.get(0).type + " " + leftArgs.get(0));
+          }
+        }
+      }*/
+      if(desc != null && desc.getSignature() != null) {
+        VarType ret = desc.getSignature().ret;
+        // more harm than gain
+        // T -> String
+        /*if(desc.getSignature().fparameters.size() == 1 && desc.getSignature().fparameters.get(0).equals(ret.value)) {
+          genericArgs.add(upperBound);
+          System.out.println("3: " + upperBound + " " + ret + " " + desc.getSignature().fparameters.get(0));
+        }*/
+        // List<T> -> List<String>
+        if(upperBound.isGeneric() && ret.isGeneric()) {
+          List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
+          List<VarType> rightArgs = ((GenericType)ret).getArguments();
+          List<String> fparams = desc.getSignature().fparameters;
+          // trivial case only for now
+          if(leftArgs.size() == 1 && rightArgs.size() == 1 && fparams.size() == 1) {
+            VarType l = leftArgs.get(0);
+            VarType r = rightArgs.get(0);
+            if(l != null /*&& l.type == CodeConstants.TYPE_OBJECT && !l.equals(r)*/ && r.value.equals(fparams.get(0))) {
+              genericArgs.add(leftArgs.get(0));
+              //type = upperBound;
+              System.out.println("4: " + leftArgs.get(0) + " " + rightArgs.get(0) + " " + fparams.get(0));
+            }
+          }
+        }
+      }
+    }
+
+    return type;
+  }
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -197,11 +258,6 @@ public class InvocationExprent extends Exprent {
 
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
-    return toJava(indent, tracer, null);
-  }
-
-  @Override
-  public TextBuffer toJava(int indent, BytecodeMappingTracer tracer, VarType expectedType) {
     TextBuffer buf = new TextBuffer();
 
     String super_qualifier = null;
@@ -276,11 +332,6 @@ public class InvocationExprent extends Exprent {
       }
     }
 
-    List<StructMethod> matches = getMatchedDescriptors();
-    BitSet setAmbiguousParameters = getAmbiguousParameters(matches);
-    StructMethod desc = null;
-    if(matches.size() == 1) desc = matches.get(0);
-
     switch (functype) {
       case TYP_GENERAL:
         if (VarExprent.VAR_NAMELESS_ENCLOSURE.equals(buf.toString())) {
@@ -290,64 +341,16 @@ public class InvocationExprent extends Exprent {
         if (buf.length() > 0) {
           buf.append(".");
 
-          boolean add = false;
-          List<VarType> toAdd = new ArrayList<VarType>();
-          if(expectedType != null && expectedType.type == CodeConstants.TYPE_OBJECT && descriptor.ret.type == CodeConstants.TYPE_OBJECT) {
-            //System.out.println("0: " + isStatic + " " + desc + " " + expectedType + " " + descriptor.ret + " " + expectedType.isGeneric());
-            if(desc == null) {
-              // more harn than gain
-              // Object -> String
-              /*if(descriptor.ret.value.equals("java/lang/Object") && !descriptor.ret.equals(expectedType)) {
-                add = true;
-                toAdd.add(expectedType);
-                System.out.println("1: " + expectedType + " " + descriptor.ret);
-              }*/
-              // List -> List<String>
-              if(expectedType.isGeneric()) {
-                List<VarType> leftArgs = ((GenericType)expectedType).getArguments();
-                //System.out.println("22: " + expectedType + " " + leftArgs.get(0));
-                if(leftArgs.size() == 1 && descriptor.ret.equals(expectedType) && leftArgs.get(0).type == CodeConstants.TYPE_OBJECT) {
-                  add = true;
-                  toAdd.add(leftArgs.get(0));
-                  System.out.println("2: " + expectedType.type + " " + expectedType + " " + leftArgs.get(0).type + " " + leftArgs.get(0));
-                }
-              }
-            }
-            if(desc != null && desc.getSignature() != null) {
-              VarType ret = desc.getSignature().ret;
-              // more harm than gain
-              // T -> String
-              /*if(desc.getSignature().fparameters.size() == 1 && desc.getSignature().fparameters.get(0).equals(ret.value)) {
-                add = true;
-                toAdd.add(expectedType);
-                System.out.println("3: " + expectedType + " " + ret + " " + desc.getSignature().fparameters.get(0));
+          if(genericArgs.size() != 0) {
+            buf.append("<");
+            for(int i = 0; i < genericArgs.size(); i++) {
+              buf.append(ExprProcessor.getCastTypeName(genericArgs.get(i)));
+              if(i + 1 < genericArgs.size()) {
+                buf.append(", ");
               }
-              // List<T> -> List<String>
-              if(expectedType.isGeneric() && ret.isGeneric()) {
-                List<VarType> leftArgs = ((GenericType)expectedType).getArguments();
-                List<VarType> rightArgs = ((GenericType)ret).getArguments();
-                List<String> fparams = desc.getSignature().fparameters;
-                // trivial case only for now
-                if(leftArgs.size() == 1 && rightArgs.size() == 1 && fparams.size() == 1 &&
-                   !leftArgs.get(0).equals(rightArgs.get(0)) && rightArgs.get(0).value.equals(fparams.get(0))) {
-                  add = true;
-                  toAdd.add(leftArgs.get(0));
-                  System.out.println("4: " + leftArgs.get(0) + " " + rightArgs.get(0) + " " + fparams.get(0));
-                }
-              }*/
-            }
-            if(add && toAdd.size() != 0) {
-              buf.append("<");
-              for(int i = 0; i < toAdd.size(); i++) {
-                buf.append(ExprProcessor.getCastTypeName(toAdd.get(i)));
-                if(i + 1 < toAdd.size()) {
-                  buf.append(", ");
-                }
-              }
-              buf.append(">");
             }
+            buf.append(">");
           }
-
         }
         buf.append(name);
         if (invocationTyp == INVOKE_DYNAMIC) {
@@ -389,17 +392,31 @@ public class InvocationExprent extends Exprent {
       }
     }
 
-    /*StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    List<StructMethod> matches = getMatchedDescriptors();
+    BitSet setAmbiguousParameters = getAmbiguousParameters(matches);
+    StructMethod desc = null;
+    if(matches.size() == 1) desc = matches.get(0);
+
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
     Map<VarType, VarType> genArgs = new HashMap<VarType, VarType>();
-    if(cl != null && cl.getSignature() != null && instance != null && instance.getGenericExprType().isGeneric()) {
-      GenericType genType = (GenericType)instance.getGenericExprType();
-      for(int i = 0; i < cl.getSignature().fparameters.size(); i++) {
-        VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
-        VarType to = genType.getArguments().get(i);
-        //System.out.println("(" + from.type + " " + from.value + " -> " + to.type + " " + to.value + ")");
-        genArgs.put(from, to);
+
+    if(cl != null && cl.getSignature() != null && instance != null && instance.getInferredExprType(null).isGeneric()) {
+      GenericType genType = (GenericType)instance.getInferredExprType(null);
+      if(genType.getArguments().size() == cl.getSignature().fparameters.size()) {
+		/*System.out.println("remap: " + classname + "." + name);
+		if(instance instanceof FieldExprent) {
+			System.out.println(((FieldExprent)instance).getClassname() + "." + ((FieldExprent)instance).getName());
+		}*/
+        for(int i = 0; i < cl.getSignature().fparameters.size(); i++) {
+          VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
+          VarType to = genType.getArguments().get(i);
+          //System.out.println("(" + from.type + " " + from.value + " -> " + to.type + " " + to.value + ")");
+          if(from != null && to != null && to.type == CodeConstants.TYPE_OBJECT) {
+            genArgs.put(from, to);
+          }
+        }
       }
-    }*/
+    }
     boolean firstParameter = true;
     int start = isEnum ? 2 : 0;
     for (int i = start; i < lstParameters.size(); i++) {
@@ -411,8 +428,9 @@ public class InvocationExprent extends Exprent {
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
         VarType type = descriptor.params[i];
-        if(desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
-          VarType newType = desc.getSignature().params.get(i);
+		VarType newType = null;
+        /*if(desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+          newType = desc.getSignature().params.get(i);
           boolean free = false;
           for(String param : desc.getSignature().fparameters) {
             if(param.equals(newType.value)) {
@@ -420,14 +438,14 @@ public class InvocationExprent extends Exprent {
               break;
             }
           }
-          if(!free && desc.getSignature().params.get(i).type == CodeConstants.TYPE_OBJECT) {
-            type = desc.getSignature().params.get(i);
+          if(!free) {
+            type = newType;
           }
-        }
-        /*if(genArgs.containsKey(type)) {
+        }*/
+        if(genArgs.containsKey(type)) {
           type = genArgs.get(type);
         }
-        if(desc != null && desc.getSignature() != null) {
+        /*if(desc != null && desc.getSignature() != null) {
           for(String ps: desc.getSignature().fparameters) {
             VarType param = GenericType.parse("T" + ps + ";");
             if(param.equals(type)) { // found free argument, need to infer it from the argument
@@ -436,6 +454,11 @@ public class InvocationExprent extends Exprent {
             }
           }
         }*/
+		VarType exprType = lstParameters.get(i).getInferredExprType(type);
+		if(exprType != null && exprType.type != CodeConstants.TYPE_NULL && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+		  type = exprType;
+		}
+		//System.out.println("param: " + i + " " + newType + " " + exprType + " " + type + " " + lstParameters.get(i));
         ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, true, ambiguous, tracer);
         buf.append(buff);
 
@@ -452,6 +475,7 @@ public class InvocationExprent extends Exprent {
     List<StructMethod> matches = new ArrayList<StructMethod>();
 
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    //System.out.println("m: " + classname + "." + name + " " + cl);
     if (cl == null) return matches;
 
     nextMethod:
@@ -485,7 +509,8 @@ public class InvocationExprent extends Exprent {
         boolean exact = true;
         for (int i = 0; i < md.params.length; i++) {
           if (!md.params[i].equals(lstParameters.get(i).getExprType())) {
-            exact = false;
+            // FIXME
+            //exact = false;
             break;
           }
         }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index 3058e7724f20f48309683af8c16b7bf19e124820..0d417258f78e649b034a680374610a961ed21257 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -66,7 +66,7 @@ public class VarExprent extends Exprent {
   }
 
   @Override
-  public VarType getGenericExprType() {
+  public VarType getInferredExprType(VarType upperBound) {
     if (lvt != null && lvt.getSig() != null) {
       // TODO; figure out why it's crashing, ugly fix for now
       try {
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index aeb786a7b26864424c5b730ef3f954b9bfb583be..da04e009a8b3ef883536cf117faee2f6dfe3b417 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -318,4 +318,20 @@ public class GenericType extends VarType {
     }
     return buffer.toString();
   }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder();
+	switch(getWildcard()) {
+      case GenericType.WILDCARD_EXTENDS:
+        buf.append("? extends ");
+        break;
+      case GenericType.WILDCARD_SUPER:
+        buf.append("? super ");
+      break;
+	}
+	buf.append(super.toString());
+    buf.append(getTypeArguments());
+	return buf.toString();
+  }
 }
diff --git a/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
index c7e781e4172f736a831b857ca7fd3060d95e6186..2afd2e6f60ee5cc191b6eaf535e0fa12f25ea275 100644
--- a/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
+++ b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
@@ -47,6 +47,7 @@ public class MinecraftDecompilationTest {
         put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES,"1");
         put(IFernflowerPreferences.ASCII_STRING_CHARACTERS,"1");
         put(IFernflowerPreferences.REMOVE_SYNTHETIC,"0");
+        put(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH, "1");
     }};
     fixture.setUp(mcFFOptions);
     if (!new File(fixture.getTestDataDir(), MC_JAR).exists()) {
-- 
2.28.0.windows.1

