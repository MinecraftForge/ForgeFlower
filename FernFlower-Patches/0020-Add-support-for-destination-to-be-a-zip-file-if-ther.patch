From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Thu, 19 Jul 2018 22:57:52 -0700
Subject: [PATCH] Add support for destination to be a zip file if there is only
 one input, and it is a file.


diff --git a/src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java b/src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
index aefae5f232c84700c16721643eab4499e319f61a..e8f65944e62c64cc5b2168c363d4c03d9d0a2fb3 100644
--- a/src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
+++ b/src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
@@ -100,7 +100,7 @@ public class ConsoleDecompiler implements IBytecodeProvider, IResultSaver {
     }
 
     File destination = new File(args[args.length - 1]);
-    if (!destination.isDirectory()) {
+    if (!destination.isDirectory() && (sources.size() > 1 || !sources.get(0).isFile())) {
       System.out.println("error: destination '" + destination + "' is not a directory");
       return;
     }
@@ -140,7 +140,7 @@ public class ConsoleDecompiler implements IBytecodeProvider, IResultSaver {
 
   protected ConsoleDecompiler(File destination, Map<String, Object> options, IFernflowerLogger logger) {
     root = destination;
-    engine = new Fernflower(this, this, options, logger);
+    engine = new Fernflower(this, root.isDirectory() ? this : new SingleFileSaver(destination), options, logger);
   }
 
   public void addSource(File source) {
diff --git a/src/org/jetbrains/java/decompiler/main/decompiler/SingleFileSaver.java b/src/org/jetbrains/java/decompiler/main/decompiler/SingleFileSaver.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b35ab03a71f7dda64589c88dc8dd1480c5d9cf1
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/decompiler/SingleFileSaver.java
@@ -0,0 +1,129 @@
+package org.jetbrains.java.decompiler.main.decompiler;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
+import org.jetbrains.java.decompiler.main.extern.IResultSaver;
+import org.jetbrains.java.decompiler.util.InterpreterUtil;
+
+public class SingleFileSaver implements IResultSaver {
+  private final File target;
+  private ZipOutputStream output;
+  private Set<String> entries = new HashSet<>();
+
+  public SingleFileSaver(File target) {
+    this.target = target;
+  }
+
+  @Override
+  public void saveFolder(String path) {
+    if (!"".equals(path))
+      throw new UnsupportedOperationException("Targeted a single output, but tried to create a directory");
+  }
+
+  @Override
+  public void copyFile(String source, String path, String entryName) {
+    throw new UnsupportedOperationException("Targeted a single output, but tried to copy file");
+  }
+
+  @Override
+  public void saveClassFile(String path, String qualifiedName, String entryName, String content, int[] mapping) {
+    throw new UnsupportedOperationException("Targeted a single output, but tried to save a class file");
+  }
+
+  @Override
+  public void createArchive(String path, String archiveName, Manifest manifest) {
+    if (output != null)
+      throw new UnsupportedOperationException("Attempted to write multiple archives at the same time");
+    try {
+      FileOutputStream stream = new FileOutputStream(target);
+      output = new ZipOutputStream(stream);
+      if (manifest != null) {
+        final ZipEntry manifestEntry = new ZipEntry(JarFile.MANIFEST_NAME);
+        manifestEntry.setTime(STABLE_ZIP_TIMESTAMP);
+        output.putNextEntry(manifestEntry);
+        manifest.write(output);
+        output.closeEntry();
+      }
+    } catch (IOException e) {
+      DecompilerContext.getLogger().writeMessage("Cannot create archive " + target, e);
+    }
+  }
+
+  @Override
+  public void saveDirEntry(String path, String archiveName, String entryName) {
+    saveClassEntry(path, archiveName, null, entryName, null);
+  }
+
+  @Override
+  public void copyEntry(String source, String path, String archiveName, String entryName) {
+    if (!checkEntry(entryName))
+      return;
+
+    try (ZipFile srcArchive = new ZipFile(new File(source))) {
+      ZipEntry entry = srcArchive.getEntry(entryName);
+      if (entry != null) {
+        try (InputStream in = srcArchive.getInputStream(entry)) {
+          final ZipEntry newEntry = new ZipEntry(entryName);
+          newEntry.setTime(entry.getTime());
+          output.putNextEntry(newEntry);
+          InterpreterUtil.copyStream(in, output);
+        }
+      }
+    }
+    catch (IOException ex) {
+      String message = "Cannot copy entry " + entryName + " from " + source + " to " + target;
+      DecompilerContext.getLogger().writeMessage(message, ex);
+    }
+  }
+
+  @Override
+  public void saveClassEntry(String path, String archiveName, String qualifiedName, String entryName, String content) {
+    if (!checkEntry(entryName))
+        return;
+
+    try {
+      ZipEntry entry = new ZipEntry(entryName);
+      entry.setTime(STABLE_ZIP_TIMESTAMP);
+      output.putNextEntry(entry);
+      if (content != null)
+          output.write(content.getBytes("UTF-8"));
+    }
+    catch (IOException ex) {
+      String message = "Cannot write entry " + entryName + " to " + target;
+      DecompilerContext.getLogger().writeMessage(message, ex);
+    }
+  }
+
+  @Override
+  public void closeArchive(String path, String archiveName) {
+    try {
+      output.close();
+      entries.clear();
+      output = null;
+    }
+    catch (IOException ex) {
+      DecompilerContext.getLogger().writeMessage("Cannot close " + target, IFernflowerLogger.Severity.WARN);
+    }
+  }
+
+  private boolean checkEntry(String entryName) {
+    boolean added = entries.add(entryName);
+    if (!added) {
+      String message = "Zip entry " + entryName + " already exists in " + target;
+      DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+    }
+    return added;
+  }
+}
