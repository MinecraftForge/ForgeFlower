From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Fri, 6 Nov 2015 03:13:00 -0800
Subject: [PATCH] Propogate renamer state to nested classes.


diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index b3bd44e5c7276d33eecd4cf4287d77864568f927..f22baa00bfcb99aa8e05ee323fdecacdf8cf177a 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -335,13 +335,6 @@ public class ClassesProcessor {
     node.wrapper = wrapper;
 
     for (ClassNode nd : node.nested) {
-      // Stuff the parent context into enclosed child methods
-      if (nd.enclosingMethod != null) {
-        MethodWrapper encmeth = wrapper.getMethods().getWithKey(nd.enclosingMethod);
-        for (final MethodWrapper meth : nd.getWrapper().getMethods()) {
-          meth.methodStruct.renamer.addParentContext(encmeth.methodStruct.renamer);
-        }
-      }
       initWrappers(nd);
     }
   }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 59b1c42717441f6bce853aa4ce9d710c15d723b6..de4dbdc7b84cc6bcb95faa3ba05e6e2290922cf5 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -16,14 +16,16 @@
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
-import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.ConstExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.NewExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph.ExprentIterator;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.DoStatement;
@@ -34,6 +36,7 @@ import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
+import org.jetbrains.java.decompiler.util.StatementIterator;
 
 import java.util.*;
 import java.util.Map.Entry;
@@ -433,9 +436,11 @@ public class VarDefinitionHelper {
     }
 
     for (VarType var : md.params) {
-      List<LVTVariable> vars = varproc.getLVT().getCandidates(index);
-      if (vars != null) {
-        types.put(new VarVersionPair(index, 0), new VarInfo(null,null));
+      if (varproc.getLVT() != null) {
+        List<LVTVariable> vars = varproc.getLVT().getCandidates(index);
+        if (vars != null) {
+          types.put(new VarVersionPair(index, 0), new VarInfo(null,null));
+        }
       }
       index += var.stackSize;
     }
@@ -446,8 +451,36 @@ public class VarDefinitionHelper {
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
       typeNames.put(e.getKey(), e.getValue().typeName());
     }
-    StructMethod current_meth = (StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
+    final StructMethod current_meth = (StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
     Map<VarVersionPair, String> renames = current_meth.renamer.rename(typeNames);
+
+    // Stuff the parent context into enclosed child methods
+    StatementIterator.iterate(root, new ExprentIterator(){
+      @Override
+      public int processExprent(Exprent exprent){
+        ClassNode child = null;
+        if (exprent.type == Exprent.EXPRENT_VAR) {
+          VarExprent var = (VarExprent)exprent;
+          if (var.isClassDef()) {
+            child = DecompilerContext.getClassProcessor().getMapRootClasses().get(var.getVarType().value);
+          }
+        }
+        else if (exprent.type == Exprent.EXPRENT_NEW) {
+          NewExprent _new = (NewExprent)exprent;
+          if (_new.isAnonymous()) { //TODO: Check for Lambda here?
+            child = DecompilerContext.getClassProcessor().getMapRootClasses().get(_new.getNewType().value);
+          }
+        }
+
+        if (child != null) {
+          for (StructMethod meth : child.classStruct.getMethods()) {
+            meth.renamer.addParentContext(current_meth.renamer);
+          }
+        }
+        return 0;
+      }
+    });
+
     Map<VarVersionPair, LVTVariable> lvts = new HashMap<VarVersionPair, LVTVariable>();
 
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
diff --git a/src/org/jetbrains/java/decompiler/util/JADNameProvider.java b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
index 4c0c9762f5f59e858f49e6bd093df00eff0cdaac..f2d2e3baf14f3004b1d377b9cb7a882741885d23 100644
--- a/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
+++ b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
@@ -25,13 +25,13 @@ public class JADNameProvider implements IVariableNameProvider {
 
     public JADNameProvider(StructMethod wrapper) {
       last = new HashMap<String, Holder>();
-      last.put("int",       new Holder(0, true,  "i", "j", "k", "l"));
-      last.put("byte",       new Holder(0, false, "b"       ));
-      last.put("char",       new Holder(0, false, "c"       ));
-      last.put("short",       new Holder(1, false, "short"   ));
-      last.put("boolean",       new Holder(0, true,  "flag"    ));
-      last.put("double",       new Holder(0, false, "d"       ));
-      last.put("float",       new Holder(0, true,  "f"       ));
+      last.put("int",     new Holder(0, true,  "i", "j", "k", "l"));
+      last.put("byte",    new Holder(0, false, "b"       ));
+      last.put("char",    new Holder(0, false, "c"       ));
+      last.put("short",   new Holder(1, false, "short"   ));
+      last.put("boolean", new Holder(0, true,  "flag"    ));
+      last.put("double",  new Holder(0, false, "d"       ));
+      last.put("float",   new Holder(0, true,  "f"       ));
       last.put("File",    new Holder(1, true,  "file"    ));
       last.put("String",  new Holder(0, true,  "s"       ));
       last.put("Class",   new Holder(0, true,  "oclass"  ));
diff --git a/src/org/jetbrains/java/decompiler/util/StatementIterator.java b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e4c8b475a4fdf4d6452ebe57621fc36bc2a2e38
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
@@ -0,0 +1,43 @@
+package org.jetbrains.java.decompiler.util;
+
+import java.util.List;
+
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph.ExprentIterator;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+
+public class StatementIterator {
+  public static void iterate(Statement stat, ExprentIterator itr) {
+    if (stat == null) {
+      return;
+    }
+
+    for (Exprent exp : stat.getVarDefinitions()) {
+      iterate(exp, itr);
+    }
+
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          iterate((Statement)obj, itr);
+        }
+        else if (obj instanceof Exprent) {
+          iterate((Exprent)obj, itr);
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        iterate(exp, itr);
+      }
+    }
+  }
+
+  private static void iterate(Exprent exp, ExprentIterator itr) {
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+    for (Exprent exprent : lst) {
+      itr.processExprent(exprent);
+    }
+  }
+}
