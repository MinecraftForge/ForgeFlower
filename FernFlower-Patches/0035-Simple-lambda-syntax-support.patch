From 5f77febddcd59e5466cab0d133da6d0dacbaae24 Mon Sep 17 00:00:00 2001
From: Justin <jrd2558@gmail.com>
Date: Fri, 20 Dec 2019 08:35:30 -0700
Subject: [PATCH] Simple lambda syntax support


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index fbb9661..69aac2e 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -13,6 +13,7 @@ import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarTypeProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
@@ -99,6 +100,8 @@ public class ClassWriter {
         MethodDescriptor md_content = MethodDescriptor.parseDescriptor(node.lambdaInformation.content_method_descriptor);
         MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(node.lambdaInformation.method_descriptor);
 
+        boolean simpleLambda = false;
+
         if (!lambdaToAnonymous) {
           buffer.append('(');
 
@@ -122,16 +125,60 @@ public class ClassWriter {
           }
 
           buffer.append(") ->");
+
+          RootStatement root = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;
+          if (!methodWrapper.decompiledWithErrors && root != null) {
+            Statement firstStat = root.getFirst();
+            if (firstStat.type == Statement.TYPE_BASICBLOCK && firstStat.getExprents() != null && firstStat.getExprents().size() == 1) {
+              Exprent firstExpr = firstStat.getExprents().get(0);
+              boolean isVarDefinition = firstExpr.type == Exprent.EXPRENT_ASSIGNMENT &&
+                ((AssignmentExprent)firstExpr).getLeft().type == Exprent.EXPRENT_VAR &&
+                ((VarExprent)((AssignmentExprent)firstExpr).getLeft()).isDefinition();
+
+              boolean isThrow = firstExpr.type == Exprent.EXPRENT_EXIT &&
+                ((ExitExprent)firstExpr).getExitType() == ExitExprent.EXIT_THROW;
+
+              if (!isVarDefinition && !isThrow) {
+                simpleLambda = true;
+                MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
+                DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);
+                try {
+                  TextBuffer codeBuffer = firstExpr.toJava(indent + 1, tracer);
+
+                  if (firstExpr.type == Exprent.EXPRENT_EXIT)
+                    codeBuffer.setStart(6); // skip return
+                  else
+                    codeBuffer.prepend(" ");
+
+                  buffer.append(codeBuffer);
+                }
+                catch (Throwable ex) {
+                  DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " " + mt.getDescriptor() + " couldn't be written.",
+                    IFernflowerLogger.Severity.WARN,
+                    ex);
+                  methodWrapper.decompiledWithErrors = true;
+                  buffer.append(" // $FF: Couldn't be decompiled");
+                }
+                finally {
+                  tracer.addMapping(root.getDummyExit().bytecode);
+                  addTracer(cl, mt, tracer);
+                  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);
+                }
+              }
+            }
+          }
         }
 
-        buffer.append(" {").appendLineSeparator();
-        tracer.incrementCurrentSourceLine();
+        if (!simpleLambda) {
+          buffer.append(" {").appendLineSeparator();
+          tracer.incrementCurrentSourceLine();
 
-        methodLambdaToJava(node, wrapper, mt, buffer, indent + 1, !lambdaToAnonymous, tracer);
+          methodLambdaToJava(node, wrapper, mt, buffer, indent + 1, !lambdaToAnonymous, tracer);
 
-        buffer.appendIndent(indent).append("}");
+          buffer.appendIndent(indent).append("}");
 
-        addTracer(cl, mt, tracer);
+          addTracer(cl, mt, tracer);
+        }
       }
     }
     finally {
-- 
2.17.2 (Apple Git-113)

