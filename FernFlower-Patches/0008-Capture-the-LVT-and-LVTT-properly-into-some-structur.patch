From f83b43ba0aaf6e5fb17d17a9fcaa2420ab8aa0ff Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Sun, 2 Aug 2015 14:07:52 -0400
Subject: [PATCH 008/122] Capture the LVT and LVTT properly, into some
 structured data. Ends seem to be the way to index the variable table. Next
 up, we need to capture the block ends in the var parsing code, so we can then
 match up later.

---
 .../java/decompiler/struct/StructMember.java  |  4 +-
 .../struct/attr/StructGeneralAttribute.java   |  3 +-
 .../StructLocalVariableTableAttribute.java    | 77 ++++++++++++++++++-
 3 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/src/org/jetbrains/java/decompiler/struct/StructMember.java b/src/org/jetbrains/java/decompiler/struct/StructMember.java
index f681e19..724c0db 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMember.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMember.java
@@ -57,9 +57,9 @@ public class StructMember {
       StructGeneralAttribute attribute = readAttribute(in, pool, name);
 
       if (attribute != null) {
-        if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) && attributes.containsKey(name)) {
+        if ((StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) || StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name)) && attributes.containsKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE)) {
           // merge all variable tables
-          StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.getWithKey(name);
+          StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
           table.addLocalVariableTable((StructLocalVariableTableAttribute)attribute);
         }
         else {
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
index dc0ebc6..87f5741 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
@@ -42,6 +42,7 @@ public class StructGeneralAttribute {
   public static final String ATTRIBUTE_RUNTIME_VISIBLE_TYPE_ANNOTATIONS = "RuntimeVisibleTypeAnnotations";
   public static final String ATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = "RuntimeInvisibleTypeAnnotations";
   public static final String ATTRIBUTE_LOCAL_VARIABLE_TABLE = "LocalVariableTable";
+  public static final String ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE = "LocalVariableTypeTable";
   public static final String ATTRIBUTE_CONSTANT_VALUE = "ConstantValue";
   public static final String ATTRIBUTE_BOOTSTRAP_METHODS = "BootstrapMethods";
   public static final String ATTRIBUTE_SYNTHETIC = "Synthetic";
@@ -85,7 +86,7 @@ public class StructGeneralAttribute {
              ATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(name)) {
       attr = new StructAnnotationTypeAttribute();
     }
-    else if (ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name)) {
+    else if (ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) || ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name)) {
       attr = new StructLocalVariableTableAttribute();
     }
     else if (ATTRIBUTE_BOOTSTRAP_METHODS.equals(name)) {
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
index fceae35..04f534e 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
@@ -19,9 +19,14 @@ import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
 
 /*
   u2 local_variable_table_length;
@@ -35,21 +40,80 @@ import java.util.Map;
 */
 public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
+  public static class LVTVariable implements Comparable<LVTVariable> {
+      public final String name;
+      public final int start;
+      public final int end;
+      public final int index;
+      private String desc;
+      private String sig;
+      private boolean isLVTT;
+      LVTVariable(String name, String desc, int start, int end, int index, boolean isLVTT) {
+          this.name = name;
+          this.desc = desc;
+          this.start = start;
+          this.end = end;
+          this.index = index;
+          this.isLVTT = isLVTT;
+      }
+
+    void merge(LVTVariable other) {
+        if (other.isLVTT && this.sig == null) {
+            this.sig = other.desc;
+        }
+    }
+    @Override
+    public boolean equals(Object obj) {
+        return ((LVTVariable) obj).index == index && ((LVTVariable) obj).end == end;
+    }
+    @Override
+    public int hashCode() {
+        return index * 31 + end;
+    }
+
+    public void addTo(Map<Integer, Set<LVTVariable>> endpoints) {
+        Set<LVTVariable> ends = endpoints.get(this.end);
+        if (ends == null) {
+            ends = new HashSet<LVTVariable>();
+            endpoints.put(this.end, ends);
+        }
+        ends.add(this);
+    }
+
+    @Override
+    public int compareTo(LVTVariable o) {
+        if (o.end > end) return -1;
+        if (o.end < end) return 1;
+        if (o.index > index) return -1;
+        if (o.index < index) return 1;
+        return 0;
+    }
+  }
   private Map<Integer, String> mapVarNames = Collections.emptyMap();
 
+  private Map<Integer, Set<LVTVariable>> endpoints = Collections.emptyMap();
+  private ArrayList<LVTVariable> allLVT;
+
   @Override
   public void initContent(ConstantPool pool) throws IOException {
     DataInputFullStream data = stream();
 
     int len = data.readUnsignedShort();
+    boolean isLVTT = this.getName().equals(ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE);
     if (len > 0) {
       mapVarNames = new HashMap<Integer, String>(len);
+      endpoints = new HashMap<Integer,Set<LVTVariable>>(len);
+      allLVT = new ArrayList<LVTVariable>(len);
       for (int i = 0; i < len; i++) {
-        data.discard(4);
+        int start = data.readUnsignedShort();
+        int vlen = data.readUnsignedShort();
         int nameIndex = data.readUnsignedShort();
-        data.discard(2);
+        int descIndex = data.readUnsignedShort(); // either descriptor or signature
         int varIndex = data.readUnsignedShort();
+        LVTVariable v = new LVTVariable(pool.getPrimitiveConstant(nameIndex).getString(), pool.getPrimitiveConstant(descIndex).getString(),start,start+vlen,varIndex,isLVTT);
         mapVarNames.put(varIndex, pool.getPrimitiveConstant(nameIndex).getString());
+        allLVT.add(v);
+        v.addTo(endpoints);
       }
     }
     else {
@@ -59,6 +123,15 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
   public void addLocalVariableTable(StructLocalVariableTableAttribute attr) {
     mapVarNames.putAll(attr.getMapVarNames());
+    for (LVTVariable other : attr.allLVT) {
+        int idx = allLVT.indexOf(other);
+        if (idx < 0) {
+            allLVT.add(other);
+        } else {
+            LVTVariable mine = allLVT.get(idx);
+            mine.merge(other);
+        }
+    }
   }
 
   public Map<Integer, String> getMapVarNames() {
-- 
2.21.0.windows.1

