From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Sun, 2 Aug 2015 14:07:52 -0400
Subject: [PATCH] Capture the LVT and LVTT properly, into some structured data.
 Ends seem to be the way to index the variable table. Next up, we need to
 capture the block ends in the var parsing code, so we can then match up
 later.


diff --git a/src/org/jetbrains/java/decompiler/struct/StructMember.java b/src/org/jetbrains/java/decompiler/struct/StructMember.java
index f681e19604b34fdc130fe0b8ebfb697c07580f97..724c0db23d607d1e243f8cf278b0a61a9789e19d 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMember.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMember.java
@@ -57,9 +57,9 @@ public class StructMember {
       StructGeneralAttribute attribute = readAttribute(in, pool, name);
 
       if (attribute != null) {
-        if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) && attributes.containsKey(name)) {
+        if ((StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) || StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name)) && attributes.containsKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE)) {
           // merge all variable tables
-          StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.getWithKey(name);
+          StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
           table.addLocalVariableTable((StructLocalVariableTableAttribute)attribute);
         }
         else {
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
index dc0ebc6708a23899fff7c43a7df56ccf02954ec9..87f574193437cf322d002e8ff3120d245474fbcc 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
@@ -42,6 +42,7 @@ public class StructGeneralAttribute {
   public static final String ATTRIBUTE_RUNTIME_VISIBLE_TYPE_ANNOTATIONS = "RuntimeVisibleTypeAnnotations";
   public static final String ATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = "RuntimeInvisibleTypeAnnotations";
   public static final String ATTRIBUTE_LOCAL_VARIABLE_TABLE = "LocalVariableTable";
+  public static final String ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE = "LocalVariableTypeTable";
   public static final String ATTRIBUTE_CONSTANT_VALUE = "ConstantValue";
   public static final String ATTRIBUTE_BOOTSTRAP_METHODS = "BootstrapMethods";
   public static final String ATTRIBUTE_SYNTHETIC = "Synthetic";
@@ -85,7 +86,7 @@ public class StructGeneralAttribute {
              ATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(name)) {
       attr = new StructAnnotationTypeAttribute();
     }
-    else if (ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name)) {
+    else if (ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) || ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name)) {
       attr = new StructLocalVariableTableAttribute();
     }
     else if (ATTRIBUTE_BOOTSTRAP_METHODS.equals(name)) {
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
index fceae359d8fa763b162851a43284e5f13b6c13ee..04f534ed5482d8778826437dafd6979085a3fb65 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
@@ -19,9 +19,14 @@ import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
 
 /*
   u2 local_variable_table_length;
@@ -35,21 +40,80 @@ import java.util.Map;
 */
 public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
+  public static class LVTVariable implements Comparable<LVTVariable> {
+      public final String name;
+      public final int start;
+      public final int end;
+      public final int index;
+      private String desc;
+      private String sig;
+      private boolean isLVTT;
+      LVTVariable(String name, String desc, int start, int end, int index, boolean isLVTT) {
+          this.name = name;
+          this.desc = desc;
+          this.start = start;
+          this.end = end;
+          this.index = index;
+          this.isLVTT = isLVTT;
+      }
+
+    void merge(LVTVariable other) {
+        if (other.isLVTT && this.sig == null) {
+            this.sig = other.desc;
+        }
+    }
+    @Override
+    public boolean equals(Object obj) {
+        return ((LVTVariable) obj).index == index && ((LVTVariable) obj).end == end;
+    }
+    @Override
+    public int hashCode() {
+        return index * 31 + end;
+    }
+
+    public void addTo(Map<Integer, Set<LVTVariable>> endpoints) {
+        Set<LVTVariable> ends = endpoints.get(this.end);
+        if (ends == null) {
+            ends = new HashSet<LVTVariable>();
+            endpoints.put(this.end, ends);
+        }
+        ends.add(this);
+    }
+
+    @Override
+    public int compareTo(LVTVariable o) {
+        if (o.end > end) return -1;
+        if (o.end < end) return 1;
+        if (o.index > index) return -1;
+        if (o.index < index) return 1;
+        return 0;
+    }
+  }
   private Map<Integer, String> mapVarNames = Collections.emptyMap();
 
+  private Map<Integer, Set<LVTVariable>> endpoints = Collections.emptyMap();
+  private ArrayList<LVTVariable> allLVT;
+
   @Override
   public void initContent(ConstantPool pool) throws IOException {
     DataInputFullStream data = stream();
 
     int len = data.readUnsignedShort();
+    boolean isLVTT = this.getName().equals(ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE);
     if (len > 0) {
       mapVarNames = new HashMap<Integer, String>(len);
+      endpoints = new HashMap<Integer,Set<LVTVariable>>(len);
+      allLVT = new ArrayList<LVTVariable>(len);
       for (int i = 0; i < len; i++) {
-        data.discard(4);
+        int start = data.readUnsignedShort();
+        int vlen = data.readUnsignedShort();
         int nameIndex = data.readUnsignedShort();
-        data.discard(2);
+        int descIndex = data.readUnsignedShort(); // either descriptor or signature
         int varIndex = data.readUnsignedShort();
+        LVTVariable v = new LVTVariable(pool.getPrimitiveConstant(nameIndex).getString(), pool.getPrimitiveConstant(descIndex).getString(),start,start+vlen,varIndex,isLVTT);
         mapVarNames.put(varIndex, pool.getPrimitiveConstant(nameIndex).getString());
+        allLVT.add(v);
+        v.addTo(endpoints);
       }
     }
     else {
@@ -59,6 +123,15 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
   public void addLocalVariableTable(StructLocalVariableTableAttribute attr) {
     mapVarNames.putAll(attr.getMapVarNames());
+    for (LVTVariable other : attr.allLVT) {
+        int idx = allLVT.indexOf(other);
+        if (idx < 0) {
+            allLVT.add(other);
+        } else {
+            LVTVariable mine = allLVT.get(idx);
+            mine.merge(other);
+        }
+    }
   }
 
   public Map<Integer, String> getMapVarNames() {
