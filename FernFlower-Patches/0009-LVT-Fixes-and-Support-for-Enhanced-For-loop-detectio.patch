From 6f2288b2521a030173ec51b88cd24ee67901c9f3 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Tue, 11 Apr 2017 22:54:20 -0700
Subject: [PATCH] LVT Fixes and Support for Enhanced For loop detection.


diff --git a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
index 5b84ab3..57a2897 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
@@ -8,7 +8,6 @@ import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
-import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
@@ -20,7 +19,6 @@ import org.jetbrains.java.decompiler.util.InterpreterUtil;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 public class ClassWrapper {
@@ -144,8 +142,9 @@ public class ClassWrapper {
           StructLocalVariableTableAttribute attr = mt.getLocalVariableAttr();
           if (attr != null) {
             // only param names here
-            varProc.setDebugVarNames(attr.getMapParamNames());
+            varProc.setDebugVarNames(attr.getMapNames());
 
+            /*
             // the rest is here
             methodWrapper.getOrBuildGraph().iterateExprents(exprent -> {
               List<Exprent> lst = exprent.getAllExprents(true);
@@ -161,6 +160,7 @@ public class ClassWrapper {
                 });
               return 0;
             });
+            */
           }
         }
       }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index 9f047d4..8ac1d92 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -11,7 +11,13 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.code.DeadCodeHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.*;
 import org.jetbrains.java.decompiler.modules.decompiler.deobfuscator.ExceptionDeobfuscator;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.MonitorExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.SynchronizedStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
@@ -98,11 +104,11 @@ public class MethodProcessorRunnable implements Runnable {
       DecompilerContext.getLogger().writeMessage("Heavily obfuscated exception ranges found!", IFernflowerLogger.Severity.WARN);
     }
 
-    RootStatement root = DomHelper.parseGraph(graph);
+    RootStatement root = DomHelper.parseGraph(graph, mt);
 
     FinallyProcessor fProc = new FinallyProcessor(md, varProc);
     while (fProc.iterateGraph(mt, root, graph)) {
-      root = DomHelper.parseGraph(graph);
+      root = DomHelper.parseGraph(graph, mt);
     }
 
     // remove synchronized exception handler
@@ -126,7 +132,7 @@ public class MethodProcessorRunnable implements Runnable {
 
       varProc.setVarVersions(root);
 
-      if (!new PPandMMHelper().findPPandMM(root)) {
+      if (!new PPandMMHelper(varProc).findPPandMM(root)) {
         break;
       }
     }
@@ -135,12 +141,16 @@ public class MethodProcessorRunnable implements Runnable {
       LabelHelper.cleanUpEdges(root);
 
       while (true) {
-        MergeHelper.enhanceLoops(root);
+        if (EliminateLoopsHelper.eliminateLoops(root, cl)) {
+          continue;
+        }
 
         if (LoopExtractHelper.extractLoops(root)) {
           continue;
         }
 
+        MergeHelper.enhanceLoops(root);
+
         if (!IfHelper.mergeAllIfs(root)) {
           break;
         }
@@ -178,6 +188,8 @@ public class MethodProcessorRunnable implements Runnable {
 
     SecondaryFunctionsHelper.identifySecondaryFunctions(root, varProc);
 
+    cleanSynchronizedVar(root);
+
     varProc.setVarDefinitions(root);
 
     // must be the last invocation, because it makes the statement structure inconsistent
@@ -198,4 +210,30 @@ public class MethodProcessorRunnable implements Runnable {
   public boolean isFinished() {
     return finished;
   }
+
+
+  public static void cleanSynchronizedVar(Statement stat) {
+    for (Statement st : stat.getStats()) {
+      cleanSynchronizedVar(st);
+    }
+
+    if (stat.type == Statement.TYPE_SYNCRONIZED) {
+      SynchronizedStatement sync = (SynchronizedStatement)stat;
+      if (sync.getHeadexprentList().get(0).type == Exprent.EXPRENT_MONITOR) {
+        MonitorExprent mon = (MonitorExprent)sync.getHeadexprentList().get(0);
+        for (Exprent e : sync.getFirst().getExprents()) {
+          if (e.type == Exprent.EXPRENT_ASSIGNMENT) {
+            AssignmentExprent ass = (AssignmentExprent)e;
+            if (ass.getLeft().type == Exprent.EXPRENT_VAR) {
+              VarExprent var = (VarExprent)ass.getLeft();
+              if (ass.getRight().equals(mon.getValue()) && !var.isVarReferenced(stat.getParent())) {
+                sync.getFirst().getExprents().remove(e);
+                break;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index af07983..451238c 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -24,6 +24,7 @@ import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.attr.StructEnclosingMethodAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.DotExporter;
@@ -232,6 +233,7 @@ public class NestedClassProcessor {
     }
 
     Map<VarVersionPair, String> mapNewNames = new HashMap<>();
+    Map<VarVersionPair, LocalVariable> lvts = new HashMap<>();
 
     enclosingMethod.getOrBuildGraph().iterateExprents(exprent -> {
       List<Exprent> lst = exprent.getAllExprents(true);
@@ -256,6 +258,7 @@ public class NestedClassProcessor {
 
                 if (param.type == Exprent.EXPRENT_VAR) {
                   mapNewNames.put(varVersion, enclosingMethod.varproc.getVarName(new VarVersionPair((VarExprent)param)));
+                  lvts.put(varVersion, ((VarExprent)param).getLVT());
                 }
               }
               else {
@@ -279,8 +282,26 @@ public class NestedClassProcessor {
     method.setOuterVarNames.addAll(setNewOuterNames);
 
     for (Entry<VarVersionPair, String> entry : mapNewNames.entrySet()) {
-      method.varproc.setVarName(entry.getKey(), entry.getValue());
+      VarVersionPair pair = entry.getKey();
+      LocalVariable lvt = lvts.get(pair);
+
+      method.varproc.setVarName(pair, entry.getValue());
+      if (lvt != null) {
+        method.varproc.setVarLVT(pair, lvt);
+      }
     }
+
+    method.getOrBuildGraph().iterateExprentsDeep(exp -> {
+      if (exp.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)exp;
+        LocalVariable lv = lvts.get(var.getVarVersionPair());
+        if (lv != null)
+          var.setLVT(lv);
+        else if (mapNewNames.containsKey(var.getVarVersionPair()))
+          var.setLVT(null);
+      }
+      return 0;
+    });
   }
 
   private static void checkNotFoundClasses(ClassNode root, ClassNode node) {
@@ -519,6 +540,7 @@ public class NestedClassProcessor {
       if (method.root != null) { // neither abstract nor native
         Map<VarVersionPair, String> mapNewNames = new HashMap<>();  // local var names
         Map<VarVersionPair, VarType> mapNewTypes = new HashMap<>();  // local var types
+        Map<VarVersionPair, LocalVariable> mapNewLVTs = new HashMap<>(); // local var table entries
 
         Map<Integer, VarVersionPair> mapParamsToNewVars = new HashMap<>();
         if (method.synthParameters != null) {
@@ -533,15 +555,17 @@ public class NestedClassProcessor {
 
               String varName = null;
               VarType varType = null;
+              LocalVariable varLVT = null;
 
               if (child.type != ClassNode.CLASS_MEMBER) {
                 varName = enclosingMethod.varproc.getVarName(pair);
                 varType = enclosingMethod.varproc.getVarType(pair);
+                varLVT = enclosingMethod.varproc.getVarLVT(pair);
 
                 enclosingMethod.varproc.setVarFinal(pair, VarTypeProcessor.VAR_EXPLICIT_FINAL);
               }
 
-              if (pair.var == -1 || "this".equals(varName)) {
+              if (pair.var == -1 || "this".equals(varName) || (varLVT != null && "this".equals(varLVT.getName()))) {
                 if (parent.simpleName == null) {
                   // anonymous enclosing class, no access to this
                   varName = VarExprent.VAR_NAMELESS_ENCLOSURE;
@@ -549,11 +573,15 @@ public class NestedClassProcessor {
                 else {
                   varName = parent.simpleName + ".this";
                 }
+                if (varLVT != null) {
+                  varLVT = varLVT.rename(varName);
+                }
                 method.varproc.getThisVars().put(newVar, parent.classStruct.qualifiedName);
               }
 
               mapNewNames.put(newVar, varName);
               mapNewTypes.put(newVar, varType);
+              mapNewLVTs.put(newVar, varLVT);
             }
 
             varIndex += md.params[index++].stackSize;
@@ -569,17 +597,19 @@ public class NestedClassProcessor {
 
             String varName = null;
             VarType varType = null;
+            LocalVariable varLVT = null;
 
             if (classNode.type != ClassNode.CLASS_MEMBER) {
               MethodWrapper enclosing_method = classNode.parent.getWrapper().getMethods().getWithKey(classNode.enclosingMethod);
 
               varName = enclosing_method.varproc.getVarName(entry.getValue());
               varType = enclosing_method.varproc.getVarType(entry.getValue());
+              varLVT = enclosing_method.varproc.getVarLVT(entry.getValue());
 
               enclosing_method.varproc.setVarFinal(entry.getValue(), VarTypeProcessor.VAR_EXPLICIT_FINAL);
             }
 
-            if (entry.getValue().var == -1 || "this".equals(varName)) {
+            if (entry.getValue().var == -1 || "this".equals(varName) || (varLVT != null && "this".equals(varLVT.getName()))) {
               if (classNode.parent.simpleName == null) {
                 // anonymous enclosing class, no access to this
                 varName = VarExprent.VAR_NAMELESS_ENCLOSURE;
@@ -587,11 +617,15 @@ public class NestedClassProcessor {
               else {
                 varName = classNode.parent.simpleName + ".this";
               }
+              if (varLVT != null) {
+                varLVT = varLVT.rename(varName);
+              }
               method.varproc.getThisVars().put(newVar, classNode.parent.classStruct.qualifiedName);
             }
 
             mapNewNames.put(newVar, varName);
             mapNewTypes.put(newVar, varType);
+            mapNewLVTs.put(newVar, varLVT);
 
             // hide synthetic field
             if (classNode == child) { // fields higher up the chain were already handled with their classes
@@ -610,16 +644,20 @@ public class NestedClassProcessor {
         for (Entry<VarVersionPair, String> entry : mapNewNames.entrySet()) {
           VarVersionPair pair = entry.getKey();
           VarType type = mapNewTypes.get(pair);
+          LocalVariable lvt = mapNewLVTs.get(pair);
 
           method.varproc.setVarName(pair, entry.getValue());
           if (type != null) {
             method.varproc.setVarType(pair, type);
           }
+          if (lvt != null) {
+            method.varproc.setVarLVT(pair, lvt);
+          }
         }
 
-        method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() {
+        iterateExprents(method.getOrBuildGraph(), new ExprentIteratorWithReplace() {
           @Override
-          public int processExprent(Exprent exprent) {
+          public Exprent processExprent(Exprent exprent) {
             if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {
               AssignmentExprent assignExpr = (AssignmentExprent)exprent;
               if (assignExpr.getLeft().type == Exprent.EXPRENT_FIELD) {
@@ -627,7 +665,7 @@ public class NestedClassProcessor {
                 String qName = child.classStruct.qualifiedName;
                 if (fExpr.getClassname().equals(qName) &&  // process this class only
                     mapFieldsToNewVars.containsKey(InterpreterUtil.makeUniqueKey(qName, fExpr.getName(), fExpr.getDescriptor().descriptorString))) {
-                  return 2;
+                  return null;
                 }
               }
             }
@@ -639,13 +677,13 @@ public class NestedClassProcessor {
               if (invokeExpr.getFunctype() == InvocationExprent.TYP_INIT) {
                 // invocation of the super constructor in an anonymous class
                 child.superInvocation = invokeExpr; // FIXME: save original names of parameters
-                return 2;
+                return null;
               }
             }
 
-            replaceExprent(exprent);
+            Exprent ret = replaceExprent(exprent);
 
-            return 0;
+            return ret == null ? exprent : ret;
           }
 
           private Exprent replaceExprent(Exprent exprent) {
@@ -654,7 +692,12 @@ public class NestedClassProcessor {
               if (mapParamsToNewVars.containsKey(varIndex)) {
                 VarVersionPair newVar = mapParamsToNewVars.get(varIndex);
                 method.varproc.getExternalVars().add(newVar);
-                return new VarExprent(newVar.var, method.varproc.getVarType(newVar), method.varproc, exprent.bytecode);
+                VarExprent ret = new VarExprent(newVar.var, method.varproc.getVarType(newVar), method.varproc, exprent.bytecode);
+                LocalVariable lvt = method.varproc.getVarLVT(newVar);
+                if (lvt != null) {
+                  ret.setLVT(lvt);
+                }
+                return ret;
               }
             }
             else if (exprent.type == Exprent.EXPRENT_FIELD) {
@@ -662,10 +705,15 @@ public class NestedClassProcessor {
               String key = InterpreterUtil.makeUniqueKey(fExpr.getClassname(), fExpr.getName(), fExpr.getDescriptor().descriptorString);
               if (mapFieldsToNewVars.containsKey(key)) {
                 //if(fExpr.getClassname().equals(child.classStruct.qualifiedName) &&
-                //		mapFieldsToNewVars.containsKey(key)) {
+                //        mapFieldsToNewVars.containsKey(key)) {
                 VarVersionPair newVar = mapFieldsToNewVars.get(key);
                 method.varproc.getExternalVars().add(newVar);
-                return new VarExprent(newVar.var, method.varproc.getVarType(newVar), method.varproc, exprent.bytecode);
+                VarExprent ret = new VarExprent(newVar.var, method.varproc.getVarType(newVar), method.varproc, exprent.bytecode);
+                LocalVariable lvt = method.varproc.getVarLVT(newVar);
+                if (lvt != null) {
+                  ret.setLVT(lvt);
+                }
+                return ret;
               }
             }
 
@@ -1047,4 +1095,41 @@ public class NestedClassProcessor {
       return fieldKey.hashCode() + varPair.hashCode();
     }
   }
-}
\ No newline at end of file
+
+  private static interface ExprentIteratorWithReplace {
+    // null - remove exprent
+    // ret != exprent - replace exprent with ret
+    Exprent processExprent(Exprent exprent);
+  }
+
+  private static void iterateExprents(DirectGraph graph, ExprentIteratorWithReplace iter) {
+    LinkedList<DirectNode> stack = new LinkedList<DirectNode>();
+    stack.add(graph.first);
+
+    HashSet<DirectNode> setVisited = new HashSet<DirectNode>();
+
+    while (!stack.isEmpty()) {
+
+      DirectNode node = stack.removeFirst();
+
+      if (setVisited.contains(node)) {
+        continue;
+      }
+      setVisited.add(node);
+
+      for (int i = 0; i < node.exprents.size(); i++) {
+        Exprent res = iter.processExprent(node.exprents.get(i));
+
+        if (res == null) {
+          node.exprents.remove(i);
+          i--;
+        }
+        else if (res != node.exprents.get(i)) {
+          node.exprents.set(i, res);
+        }
+      }
+
+      stack.addAll(node.succs);
+    }
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
index bc3cb33..63b4b35 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
@@ -9,6 +9,8 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.modules.decompiler.decompose.FastExtendedPostdominanceHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.deobfuscator.IrreducibleCFGDeobfuscator;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.FastFixedSetFactory;
 import org.jetbrains.java.decompiler.util.FastFixedSetFactory.FastFixedSet;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -189,17 +191,12 @@ public class DomHelper {
     return ret;
   }
 
-  public static RootStatement parseGraph(ControlFlowGraph graph) {
+  public static RootStatement parseGraph(ControlFlowGraph graph, StructMethod mt) {
 
     RootStatement root = graphToStatement(graph);
 
     if (!processStatement(root, new LinkedHashMap<>())) {
-
-      //			try {
-      //				DotExporter.toDotFile(root.getFirst().getStats().get(13), new File("c:\\Temp\\stat1.dot"));
-      //			} catch (Exception ex) {
-      //				ex.printStackTrace();
-      //			}
+      DotExporter.toDotFile(graph, mt, "parseGraphFail", true);
       throw new RuntimeException("parsing failure!");
     }
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/EliminateLoopsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/EliminateLoopsHelper.java
new file mode 100644
index 0000000..adc7839
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/EliminateLoopsHelper.java
@@ -0,0 +1,199 @@
+// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+package org.jetbrains.java.decompiler.modules.decompiler;
+
+import org.jetbrains.java.decompiler.modules.decompiler.stats.DoStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.struct.StructClass;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+
+public class EliminateLoopsHelper {
+
+  public static boolean eliminateLoops(Statement root, StructClass cl) {
+
+    boolean ret = eliminateLoopsRec(root);
+
+    if(ret) {
+      SequenceHelper.condenseSequences(root);
+
+      Set<Integer> setReorderedIfs = new HashSet<>();
+
+      SimplifyExprentsHelper sehelper = new SimplifyExprentsHelper(false);
+      while(sehelper.simplifyStackVarsStatement(root, setReorderedIfs, null, cl)) {
+        SequenceHelper.condenseSequences(root);
+      }
+    }
+
+    return ret;
+  }
+
+  private static boolean eliminateLoopsRec(Statement stat) {
+
+    for (Statement st : stat.getStats()) {
+      if (eliminateLoopsRec(st)) {
+        return true;
+      }
+    }
+
+    if (stat.type == Statement.TYPE_DO && isLoopRedundant((DoStatement)stat)) {
+      return true;
+    }
+
+    return false;
+  }
+
+  private static boolean isLoopRedundant(DoStatement loop) {
+
+    if (loop.getLooptype() != DoStatement.LOOP_DO) {
+      return false;
+    }
+
+    // get parent loop if exists
+    Statement parentloop = loop.getParent();
+    while (parentloop != null && parentloop.type != Statement.TYPE_DO) {
+      parentloop = parentloop.getParent();
+    }
+
+    if (parentloop == null || parentloop.getBasichead() != loop.getBasichead()) {
+      return false;
+    }
+
+    // collect relevant break edges
+    List<StatEdge> lstBreakEdges = new ArrayList<>();
+    for (StatEdge edge : loop.getLabelEdges()) {
+      if (edge.getType() == StatEdge.TYPE_BREAK) { // all break edges are explicit because of LOOP_DO type
+        lstBreakEdges.add(edge);
+      }
+    }
+
+
+    Statement loopcontent = loop.getFirst();
+
+    boolean firstok = loopcontent.getAllSuccessorEdges().isEmpty();
+    if (!firstok) {
+      StatEdge edge = loopcontent.getAllSuccessorEdges().get(0);
+      firstok = (edge.closure == loop && edge.getType() == StatEdge.TYPE_BREAK);
+      if (firstok) {
+        lstBreakEdges.remove(edge);
+      }
+    }
+
+
+    if (!lstBreakEdges.isEmpty()) {
+      if (firstok) {
+
+        HashMap<Integer, Boolean> statLabeled = new HashMap<>();
+        List<Statement> lstEdgeClosures = new ArrayList<>();
+
+        for (StatEdge edge : lstBreakEdges) {
+          Statement minclosure = LowBreakHelper.getMinClosure(loopcontent, edge.getSource());
+          lstEdgeClosures.add(minclosure);
+        }
+
+        int precount = loop.isLabeled() ? 1 : 0;
+        for (Statement st : lstEdgeClosures) {
+          if (!statLabeled.containsKey(st.id)) {
+            boolean btemp = st.isLabeled();
+            precount += btemp ? 1 : 0;
+            statLabeled.put(st.id, btemp);
+          }
+        }
+
+        for (int i = 0; i < lstBreakEdges.size(); i++) {
+          Statement st = lstEdgeClosures.get(i);
+          statLabeled.put(st.id, LowBreakHelper.isBreakEdgeLabeled(lstBreakEdges.get(i).getSource(), st) | statLabeled.get(st.id));
+        }
+
+        for (int i = 0; i < lstBreakEdges.size(); i++) {
+          lstEdgeClosures.set(i, getMaxBreakLift(lstEdgeClosures.get(i), lstBreakEdges.get(i), statLabeled, loop));
+        }
+
+        statLabeled.clear();
+        for (Statement st : lstEdgeClosures) {
+          statLabeled.put(st.id, st.isLabeled());
+        }
+
+        for (int i = 0; i < lstBreakEdges.size(); i++) {
+          Statement st = lstEdgeClosures.get(i);
+          statLabeled.put(st.id, LowBreakHelper.isBreakEdgeLabeled(lstBreakEdges.get(i).getSource(), st) | statLabeled.get(st.id));
+        }
+
+        long postcount = statLabeled.values().stream().filter(Boolean::booleanValue).count();
+
+        if (precount <= postcount) {
+          return false;
+        }
+        else {
+          for (int i = 0; i < lstBreakEdges.size(); i++) {
+            lstEdgeClosures.get(i).addLabeledEdge(lstBreakEdges.get(i));
+          }
+        }
+      }
+      else {
+        return false;
+      }
+    }
+
+    eliminateLoop(loop, parentloop);
+
+    return true;
+  }
+
+  private static Statement getMaxBreakLift(Statement stat, StatEdge edge, HashMap<Integer, Boolean> statLabeled, Statement max) {
+
+    Statement closure = stat;
+    Statement newclosure = stat;
+
+    while ((newclosure = getNextBreakLift(newclosure, edge, statLabeled, max)) != null) {
+      closure = newclosure;
+    }
+
+    return closure;
+  }
+
+  private static Statement getNextBreakLift(Statement stat, StatEdge edge, HashMap<Integer, Boolean> statLabeled, Statement max) {
+
+    Statement closure = stat.getParent();
+
+    while (closure != null && closure != max && !closure.containsStatementStrict(edge.getDestination())) {
+
+      boolean edge_labeled = LowBreakHelper.isBreakEdgeLabeled(edge.getSource(), closure);
+      boolean stat_labeled = statLabeled.containsKey(closure.id) ? statLabeled.get(closure.id) : closure.isLabeled();
+
+      if (stat_labeled || !edge_labeled) {
+        return closure;
+      }
+
+      closure = closure.getParent();
+    }
+
+    return null;
+  }
+
+  private static void eliminateLoop(Statement loop, Statement parentloop) {
+
+    // move continue edges to the parent loop
+    List<StatEdge> lst = new ArrayList<>(loop.getLabelEdges());
+    for (StatEdge edge : lst) {
+      loop.removePredecessor(edge);
+      edge.getSource().changeEdgeNode(Statement.DIRECTION_FORWARD, edge, parentloop);
+      parentloop.addPredecessor(edge);
+
+      parentloop.addLabeledEdge(edge);
+    }
+
+    // remove the last break edge, if exists
+    Statement loopcontent = loop.getFirst();
+    if (!loopcontent.getAllSuccessorEdges().isEmpty()) {
+      loopcontent.removeSuccessor(loopcontent.getAllSuccessorEdges().get(0));
+    }
+
+    // replace loop with its content
+    loop.getParent().replaceStatement(loop, loopcontent);
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
index 81c61d0..b943963 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
@@ -172,7 +172,7 @@ public class ExitHelper {
   private static Statement isExitEdge(StatEdge edge) {
     Statement dest = edge.getDestination();
 
-    if (edge.getType() == StatEdge.TYPE_BREAK && dest.type == Statement.TYPE_BASICBLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge))) {
+    if (edge.getType() == StatEdge.TYPE_BREAK && dest.type == Statement.TYPE_BASICBLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge)) && edge.canInline) {
       List<Exprent> data = dest.getExprents();
 
       if (data != null && data.size() == 1) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 7b5bf28..ffa733a 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -333,7 +333,9 @@ public class ExprProcessor implements CodeConstants {
         case opc_fload:
         case opc_dload:
         case opc_aload:
-          pushEx(stack, exprlist, new VarExprent(instr.operand(0), varTypes[instr.opcode - opc_iload], varProcessor, bytecode_offsets));
+          VarExprent varExprent = new VarExprent(instr.operand(0), varTypes[instr.opcode - opc_iload], varProcessor, bytecode_offsets);
+          varProcessor.findLVT(varExprent, bytecode_offset + instr.length);
+          pushEx(stack, exprlist, varExprent);
           break;
         case opc_iaload:
         case opc_laload:
@@ -366,8 +368,9 @@ public class ExprProcessor implements CodeConstants {
           if (bytecode_offsets != null) { //TODO: Figure out why this nulls in some cases
             bytecode_offsets.set(bytecode_offset, bytecode_offset + instr.length);
           }
-          AssignmentExprent assign = new AssignmentExprent(
-            new VarExprent(varindex, varTypes[instr.opcode - opc_istore], varProcessor, bytecode_offsets), expr, bytecode_offsets);
+          varExprent = new VarExprent(varindex, varTypes[instr.opcode - opc_istore], varProcessor, bytecode_offsets);
+          varProcessor.findLVT(varExprent, bytecode_offset + instr.length);
+          AssignmentExprent assign = new AssignmentExprent(varExprent, expr, bytecode_offsets);
           exprlist.add(assign);
           break;
         case opc_iastore:
@@ -430,6 +433,7 @@ public class ExprProcessor implements CodeConstants {
           break;
         case opc_iinc:
           VarExprent vevar = new VarExprent(instr.operand(0), VarType.VARTYPE_INT, varProcessor, bytecode_offsets);
+          varProcessor.findLVT(vevar, bytecode_offset + instr.length);
           exprlist.add(new AssignmentExprent(vevar, new FunctionExprent(
             instr.operand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD, Arrays
             .asList(vevar.copy(), new ConstExprent(VarType.VARTYPE_INT, Math.abs(instr.operand(1)), null)),
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
index dd431f1..8c9b5b6 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
@@ -118,7 +118,10 @@ public class InlineSingleBlockHelper {
       StatEdge edge = lst.get(0);
 
       if (sameCatchRanges(edge)) {
-        if (edge.explicit) {
+        if (!edge.canInline) {
+          return false; //Dirty hack, but lets do it!
+        }
+        else if (edge.explicit) {
           return true;
         }
         else {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
index 8229127..545f687 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
@@ -8,6 +8,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Set;
 
 
@@ -63,16 +64,33 @@ public class LoopExtractHelper {
       return false;
     }
 
+    List<Statement> stats = new ArrayList<>();
     for (StatEdge edge : stat.getLabelEdges()) {
       if (edge.getType() != StatEdge.TYPE_CONTINUE && edge.getDestination().type != Statement.TYPE_DUMMYEXIT) {
+        if (edge.getType() == StatEdge.TYPE_BREAK && isExternStatement(stat, edge.getSource(), edge.getSource())) {
+          stats.add(edge.getSource());
+        }
+        else {
+          return false;
+        }
+      }
+    }
+
+    if (stats.size() > 0) { // In this case prioritize first to help the Loop enhancer
+      if (stat.getParent().getStats().getLast() != stat) {
         return false;
       }
     }
 
-    return extractLastIf(stat) || extractFirstIf(stat);
+    if (!extractFirstIf(stat, stats)) {
+      return extractLastIf(stat, stats);
+    }
+    else {
+      return true;
+    }
   }
 
-  private static boolean extractLastIf(DoStatement stat) {
+  private static boolean extractLastIf(DoStatement stat, List<Statement> stats) {
 
     // search for an if condition at the end of the loop
     Statement last = stat.getFirst();
@@ -93,6 +111,11 @@ public class LoopExtractHelper {
 
           if (set.isEmpty()) { // no direct continues in a do{}while loop
             if (isExternStatement(stat, ifstat, ifstat)) {
+              for (Statement s : stats) {
+                if (!ifstat.containsStatement(s)) {
+                  return false;
+                }
+              }
               extractIfBlock(stat, lastif);
               return true;
             }
@@ -103,7 +126,7 @@ public class LoopExtractHelper {
     return false;
   }
 
-  private static boolean extractFirstIf(DoStatement stat) {
+  private static boolean extractFirstIf(DoStatement stat, List<Statement> stats) {
 
     // search for an if condition at the entrance of the loop
     Statement first = stat.getFirst();
@@ -121,6 +144,11 @@ public class LoopExtractHelper {
           Statement ifstat = firstif.getIfstat();
 
           if (isExternStatement(stat, ifstat, ifstat)) {
+            for (Statement s : stats) {
+              if (!ifstat.containsStatement(s)) {
+                return false;
+              }
+            }
             extractIfBlock(stat, firstif);
             return true;
           }
@@ -181,5 +209,10 @@ public class LoopExtractHelper {
         loop.addPredecessor(edge);
       }
     }
+
+    List<StatEdge> link = target.getPredecessorEdges(StatEdge.TYPE_BREAK);
+    if (link.size() == 1) {
+      link.get(0).canInline = false;
+    }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/LowBreakHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/LowBreakHelper.java
new file mode 100644
index 0000000..c62c74d
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/LowBreakHelper.java
@@ -0,0 +1,194 @@
+// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+package org.jetbrains.java.decompiler.modules.decompiler;
+
+import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.SynchronizedStatement;
+
+import java.util.List;
+
+public class LowBreakHelper {
+
+  public static void lowBreakLabels(Statement root) {
+
+    lowBreakLabelsRec(root);
+
+    liftBreakLabels(root);
+  }
+
+  private static void lowBreakLabelsRec(Statement stat) {
+
+    while (true) {
+
+      boolean found = false;
+
+      for (StatEdge edge : stat.getLabelEdges()) {
+        if (edge.getType() == StatEdge.TYPE_BREAK) {
+          Statement minclosure = getMinClosure(stat, edge.getSource());
+          if (minclosure != stat) {
+            minclosure.addLabeledEdge(edge);
+            edge.labeled = isBreakEdgeLabeled(edge.getSource(), minclosure);
+            found = true;
+            break;
+          }
+        }
+      }
+
+      if (!found) {
+        break;
+      }
+    }
+
+    for (Statement st : stat.getStats()) {
+      lowBreakLabelsRec(st);
+    }
+  }
+
+  public static boolean isBreakEdgeLabeled(Statement source, Statement closure) {
+
+    if (closure.type == Statement.TYPE_DO || closure.type == Statement.TYPE_SWITCH) {
+
+      Statement parent = source.getParent();
+
+      if (parent == closure) {
+        return false;
+      }
+      else {
+        return isBreakEdgeLabeled(parent, closure) ||
+               (parent.type == Statement.TYPE_DO || parent.type == Statement.TYPE_SWITCH);
+      }
+    }
+    else {
+      return true;
+    }
+  }
+
+  public static Statement getMinClosure(Statement closure, Statement source) {
+
+    while (true) {
+
+      Statement newclosure = null;
+
+      switch (closure.type) {
+        case Statement.TYPE_SEQUENCE:
+          Statement last = closure.getStats().getLast();
+
+          if (isOkClosure(closure, source, last)) {
+            newclosure = last;
+          }
+          break;
+        case Statement.TYPE_IF:
+          IfStatement ifclosure = (IfStatement)closure;
+          if (isOkClosure(closure, source, ifclosure.getIfstat())) {
+            newclosure = ifclosure.getIfstat();
+          }
+          else if (isOkClosure(closure, source, ifclosure.getElsestat())) {
+            newclosure = ifclosure.getElsestat();
+          }
+          break;
+        case Statement.TYPE_TRYCATCH:
+          for (Statement st : closure.getStats()) {
+            if (isOkClosure(closure, source, st)) {
+              newclosure = st;
+              break;
+            }
+          }
+          break;
+        case Statement.TYPE_SYNCRONIZED:
+          Statement body = ((SynchronizedStatement)closure).getBody();
+
+          if (isOkClosure(closure, source, body)) {
+            newclosure = body;
+          }
+      }
+
+      if (newclosure == null) {
+        break;
+      }
+
+      closure = newclosure;
+    }
+
+    return closure;
+  }
+
+  private static boolean isOkClosure(Statement closure, Statement source, Statement stat) {
+
+    boolean ok = false;
+
+    if (stat != null && stat.containsStatementStrict(source)) {
+
+      List<StatEdge> lst = stat.getAllSuccessorEdges();
+
+      ok = lst.isEmpty();
+      if (!ok) {
+        StatEdge edge = lst.get(0);
+        ok = (edge.closure == closure && edge.getType() == StatEdge.TYPE_BREAK);
+      }
+    }
+
+    return ok;
+  }
+
+
+  private static void liftBreakLabels(Statement stat) {
+
+    for (Statement st : stat.getStats()) {
+      liftBreakLabels(st);
+    }
+
+
+    while (true) {
+
+      boolean found = false;
+
+      for (StatEdge edge : stat.getLabelEdges()) {
+        if (edge.explicit && edge.labeled && edge.getType() == StatEdge.TYPE_BREAK) {
+
+          Statement newclosure = getMaxBreakLift(stat, edge);
+
+          if (newclosure != null) {
+            newclosure.addLabeledEdge(edge);
+            edge.labeled = isBreakEdgeLabeled(edge.getSource(), newclosure);
+
+            found = true;
+            break;
+          }
+        }
+      }
+
+      if (!found) {
+        break;
+      }
+    }
+  }
+
+  private static Statement getMaxBreakLift(Statement stat, StatEdge edge) {
+
+    Statement closure = null;
+    Statement newclosure = stat;
+
+    while ((newclosure = getNextBreakLift(newclosure, edge)) != null) {
+      closure = newclosure;
+    }
+
+    return closure;
+  }
+
+  private static Statement getNextBreakLift(Statement stat, StatEdge edge) {
+
+    Statement closure = stat.getParent();
+
+    while (closure != null && !closure.containsStatementStrict(edge.getDestination())) {
+
+      boolean labeled = isBreakEdgeLabeled(edge.getSource(), closure);
+      if (closure.isLabeled() || !labeled) {
+        return closure;
+      }
+
+      closure = closure.getParent();
+    }
+
+    return null;
+  }
+}
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
index efc1891..ad1575d 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
@@ -4,8 +4,13 @@ package org.jetbrains.java.decompiler.modules.decompiler;
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.ArrayExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.FunctionExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.IfExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.InvocationExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
 
 import java.util.ArrayList;
@@ -42,17 +47,20 @@ public class MergeHelper {
 
         // identify a while loop
         if (matchWhile(stat)) {
-          // identify a for loop - subtype of while
-          matchFor(stat);
+          if (!matchForEach(stat)) {
+            matchFor(stat);
+          }
         }
         else {
           // identify a do{}while loop
-          matchDoWhile(stat);
+          //matchDoWhile(stat);
         }
 
         break;
       case DoStatement.LOOP_WHILE:
-        matchFor(stat);
+        if (!matchForEach(stat)) {
+          matchFor(stat);
+        }
     }
 
     return (stat.getLooptype() != oldloop);
@@ -325,6 +333,8 @@ public class MergeHelper {
         }
         else {
           preData = current.getNeighbours(StatEdge.TYPE_REGULAR, Statement.DIRECTION_BACKWARD).get(0);
+          // we're not a basic block, so we can't dive inside for exprents
+          if (preData.type != Statement.TYPE_BASICBLOCK) break;
           preData = getLastDirectData(preData);
           if (preData != null && !preData.getExprents().isEmpty()) {
             initDoExprent = preData.getExprents().get(preData.getExprents().size() - 1);
@@ -363,12 +373,16 @@ public class MergeHelper {
       stat.setIncExprent(exp);
     }
 
-    if (lastData.getExprents().isEmpty()) {
-      List<StatEdge> lst = lastData.getAllSuccessorEdges();
+    cleanEmptyStatements(stat, lastData);
+  }
+
+  private static void cleanEmptyStatements(DoStatement dostat, Statement stat) {
+    if (stat != null && stat.getExprents().isEmpty()) {
+      List<StatEdge> lst = stat.getAllSuccessorEdges();
       if (!lst.isEmpty()) {
-        lastData.removeSuccessor(lst.get(0));
+        stat.removeSuccessor(lst.get(0));
       }
-      removeLastEmptyStatement(stat, lastData);
+      removeLastEmptyStatement(dostat, stat);
     }
   }
 
@@ -401,15 +415,296 @@ public class MergeHelper {
       return stat;
     }
 
-    switch (stat.type) {
-      case Statement.TYPE_SEQUENCE:
-        for (int i = stat.getStats().size() - 1; i >= 0; i--) {
-          Statement tmp = getLastDirectData(stat.getStats().get(i));
-          if (tmp == null || !tmp.getExprents().isEmpty()) {
-            return tmp;
+    for (int i = stat.getStats().size() - 1; i >= 0; i--) {
+      Statement tmp = getLastDirectData(stat.getStats().get(i));
+      if (tmp == null || !tmp.getExprents().isEmpty()) {
+        return tmp;
+      }
+    }
+    return null;
+  }
+  
+  private static boolean matchForEach(DoStatement stat) {
+    AssignmentExprent firstDoExprent = null;
+    AssignmentExprent[] initExprents = new AssignmentExprent[3];
+    Statement firstData = null, preData = null, lastData = null;
+    Exprent lastExprent = null;
+
+    // search for an initializing exprent
+    Statement current = stat;
+    while (true) {
+      Statement parent = current.getParent();
+      if (parent == null) {
+        break;
+      }
+
+      if (parent.type == Statement.TYPE_SEQUENCE) {
+        if (current == parent.getFirst()) {
+          current = parent;
+        }
+        else {
+          preData = current.getNeighbours(StatEdge.TYPE_REGULAR, Statement.DIRECTION_BACKWARD).get(0);
+          preData = getLastDirectData(preData);
+          if (preData != null && !preData.getExprents().isEmpty()) {
+            int size = preData.getExprents().size();
+            for (int x = 0; x < initExprents.length; x++) {
+              if (size > x) {
+                 Exprent exprent = preData.getExprents().get(size - 1 - x);
+                 if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {
+                   initExprents[x] = (AssignmentExprent)exprent;
+                 }
+              }
+            }
+          }
+          break;
+        }
+      }
+      else {
+        break;
+      }
+    }
+
+    firstData = getFirstDirectData(stat.getFirst());
+    if (firstData != null && firstData.getExprents().get(0).type == Exprent.EXPRENT_ASSIGNMENT) {
+      firstDoExprent = (AssignmentExprent)firstData.getExprents().get(0);
+    }
+    lastData = getLastDirectData(stat.getFirst());
+    if (lastData != null && !lastData.getExprents().isEmpty()) {
+      lastExprent = lastData.getExprents().get(lastData.getExprents().size() - 1);
+    }
+
+    if (stat.getLooptype() == DoStatement.LOOP_WHILE && initExprents[0] != null && firstDoExprent != null) {
+      if (initExprents[0].type == Exprent.EXPRENT_ASSIGNMENT &&
+          isIteratorCall(((AssignmentExprent)initExprents[0]).getRight())) {
+
+        //Streams mimic Iterable but arnt.. so explicitly disallow their enhancements
+        //TODO: Check inheritance for Iterable instead of just names?
+        InvocationExprent invc = (InvocationExprent)getUncast(((AssignmentExprent)initExprents[0]).getRight());
+        if (invc.getClassname().contains("java/util/stream")) {
+          return false;
+        }
+
+        if (!isHasNextCall(drillNots(stat.getConditionExprent())) ||
+            firstDoExprent.type != Exprent.EXPRENT_ASSIGNMENT) {
+          return false;
+        }
+
+        AssignmentExprent ass = (AssignmentExprent)firstDoExprent;
+        if ((!isNextCall(ass.getRight()) && !isNextUnboxing(ass.getRight())) || ass.getLeft().type != Exprent.EXPRENT_VAR) {
+          return false;
+        }
+
+        InvocationExprent next = (InvocationExprent)getUncast(ass.getRight());
+        if (isNextUnboxing(next))
+          next = (InvocationExprent)getUncast(next.getInstance());
+        InvocationExprent hnext = (InvocationExprent)getUncast(drillNots(stat.getConditionExprent()));
+        if (next.getInstance().type != Exprent.EXPRENT_VAR ||
+            hnext.getInstance().type != Exprent.EXPRENT_VAR ||
+          ((VarExprent)initExprents[0].getLeft()).isVarReferenced(stat, (VarExprent)next.getInstance(), (VarExprent)hnext.getInstance())) {
+          return false;
+        }
+
+        InvocationExprent holder = (InvocationExprent)((AssignmentExprent)initExprents[0]).getRight();
+
+        initExprents[0].getBytecodeRange(holder.getInstance().bytecode);
+        holder.getBytecodeRange(holder.getInstance().bytecode);
+        firstDoExprent.getBytecodeRange(ass.getLeft().bytecode);
+        ass.getRight().getBytecodeRange(ass.getLeft().bytecode);
+        if (stat.getIncExprent() != null) {
+          stat.getIncExprent().getBytecodeRange(holder.getInstance().bytecode);
+        }
+        if (stat.getInitExprent() != null) {
+          stat.getInitExprent().getBytecodeRange(ass.getLeft().bytecode);
+        }
+
+        stat.setLooptype(DoStatement.LOOP_FOREACH);
+        stat.setInitExprent(ass.getLeft());
+        stat.setIncExprent(holder.getInstance());
+        preData.getExprents().remove(initExprents[0]);
+        firstData.getExprents().remove(firstDoExprent);
+
+        if (initExprents[1] != null && initExprents[1].getLeft().type == Exprent.EXPRENT_VAR &&
+            holder.getInstance().type == Exprent.EXPRENT_VAR) {
+          VarExprent copy = (VarExprent)initExprents[1].getLeft();
+          VarExprent inc = (VarExprent)holder.getInstance();
+          if (copy.getIndex() == inc.getIndex() && copy.getVersion() == inc.getVersion() && !inc.isVarReferenced(stat.getTopParent(), copy)) {
+            preData.getExprents().remove(initExprents[1]);
+            initExprents[1].getBytecodeRange(initExprents[1].getRight().bytecode);
+            stat.getIncExprent().getBytecodeRange(initExprents[1].getRight().bytecode);
+            stat.setIncExprent(initExprents[1].getRight());
           }
         }
+
+        return true;
+      }
+      else if (initExprents[0] != null && initExprents[1] != null && firstDoExprent != null) {
+        if (firstDoExprent.getRight().type != Exprent.EXPRENT_ARRAY || firstDoExprent.getLeft().type != Exprent.EXPRENT_VAR) {
+          return false;
+        }
+  
+        if (lastExprent == null || lastExprent.type != Exprent.EXPRENT_FUNCTION) {
+          return false;
+        }
+  
+        if (initExprents[0].getRight().type != Exprent.EXPRENT_CONST ||
+            initExprents[1].getRight().type != Exprent.EXPRENT_FUNCTION ||
+            stat.getConditionExprent().type != Exprent.EXPRENT_FUNCTION) {
+          return false;
+        }
+
+        //FunctionExprent funcCond  = (FunctionExprent)drillNots(stat.getConditionExprent()); //TODO: Verify this is counter < copy.length
+        FunctionExprent funcRight = (FunctionExprent)initExprents[1].getRight();
+        FunctionExprent funcInc   = (FunctionExprent)lastExprent;
+        ArrayExprent    arr       = (ArrayExprent)firstDoExprent.getRight();
+        int incType = funcInc.getFuncType();
+  
+        if (funcRight.getFuncType() != FunctionExprent.FUNCTION_ARRAY_LENGTH ||
+            (incType != FunctionExprent.FUNCTION_PPI && incType != FunctionExprent.FUNCTION_IPP) ||
+            arr.getIndex().type != Exprent.EXPRENT_VAR ||
+            arr.getArray().type != Exprent.EXPRENT_VAR) {
+            return false;
+        }
+  
+        VarExprent index = (VarExprent)arr.getIndex();
+        VarExprent array = (VarExprent)arr.getArray();
+        VarExprent counter = (VarExprent)funcInc.getLstOperands().get(0);
+  
+        if (counter.getIndex() != index.getIndex() ||
+            counter.getVersion() != index.getVersion()) {
+          return false;
+        }
+
+        if (counter.isVarReferenced(stat.getFirst(), index)) {
+          return false;
+        }
+  
+        funcRight.getLstOperands().get(0).addBytecodeOffsets(initExprents[0].bytecode);
+        funcRight.getLstOperands().get(0).addBytecodeOffsets(initExprents[1].bytecode);
+        funcRight.getLstOperands().get(0).addBytecodeOffsets(lastExprent.bytecode);
+        firstDoExprent.getLeft().addBytecodeOffsets(firstDoExprent.bytecode);
+        firstDoExprent.getLeft().addBytecodeOffsets(initExprents[0].bytecode);
+  
+        stat.setLooptype(DoStatement.LOOP_FOREACH);
+        stat.setInitExprent(firstDoExprent.getLeft());
+        stat.setIncExprent(funcRight.getLstOperands().get(0));
+        preData.getExprents().remove(initExprents[0]);
+        preData.getExprents().remove(initExprents[1]);
+        firstData.getExprents().remove(firstDoExprent);
+        lastData.getExprents().remove(lastExprent);
+  
+        if (initExprents[2] != null && initExprents[2].getLeft().type == Exprent.EXPRENT_VAR) {
+          VarExprent copy = (VarExprent)initExprents[2].getLeft();
+          if (copy.getIndex() == array.getIndex() && copy.getVersion() == array.getVersion()) {
+            preData.getExprents().remove(initExprents[2]);
+            initExprents[2].getRight().addBytecodeOffsets(initExprents[2].bytecode);
+            initExprents[2].getRight().addBytecodeOffsets(stat.getIncExprent().bytecode);
+            stat.setIncExprent(initExprents[2].getRight());
+          }
+        }
+  
+        return true;
+      }
+    }
+
+    //cleanEmptyStatements(stat, firstData); //TODO: Look into this and see what it does...
+
+    return false;
+  }
+
+  private static Exprent drillNots(Exprent exp) {
+    while (true) {
+      if (exp.type == Exprent.EXPRENT_FUNCTION) {
+        FunctionExprent fun = (FunctionExprent)exp;
+        if (fun.getFuncType() == FunctionExprent.FUNCTION_BOOL_NOT) {
+          exp = fun.getLstOperands().get(0);
+        }
+        else if (fun.getFuncType() == FunctionExprent.FUNCTION_EQ ||
+                 fun.getFuncType() == FunctionExprent.FUNCTION_NE) {
+          return fun.getLstOperands().get(0);
+        }
+        else {
+          return null;
+        }
+      }
+      else {
+        return null;
+      }
+    }
+  }
+
+  private static Statement getFirstDirectData(Statement stat) {
+    if (stat.getExprents() != null && !stat.getExprents().isEmpty()) {
+      return stat;
+    }
+
+    for (Statement tmp : stat.getStats()) {
+      Statement ret = getFirstDirectData(tmp);
+      if (ret != null) {
+        return ret;
+      }
+    }
+    return null;
+  }
+
+  private static Exprent getUncast(Exprent exp) {
+    if (exp.type == Exprent.EXPRENT_FUNCTION) {
+      FunctionExprent func = (FunctionExprent)exp;
+      if (func.getFuncType() == FunctionExprent.FUNCTION_CAST) {
+        return getUncast(func.getLstOperands().get(0));
+      }
+    }
+    return exp;
+  }
+
+  private static InvocationExprent asInvocationExprent(Exprent exp) {
+    exp = getUncast(exp);
+    if (exp.type == Exprent.EXPRENT_INVOCATION) {
+      return (InvocationExprent) exp;
     }
     return null;
   }
-}
\ No newline at end of file
+
+  private static boolean isIteratorCall(Exprent exp) {
+    final InvocationExprent iexp = asInvocationExprent(exp);
+    if (iexp == null) {
+      return false;
+    }
+    final org.jetbrains.java.decompiler.struct.gen.MethodDescriptor descriptor = iexp.getDescriptor();
+    if (!DecompilerContext.getStructContext().instanceOf(descriptor.ret.value, "java/util/Iterator")) {
+      return false;
+    }
+    final String name = iexp.getName();
+    return "iterator".equals(name) ||
+           "listIterator".equals(name);
+  }
+
+  private static boolean isHasNextCall(Exprent exp) {
+    final InvocationExprent iexp = asInvocationExprent(exp);
+    if (iexp == null) {
+      return false;
+    }
+    if (!DecompilerContext.getStructContext().instanceOf(iexp.getClassname(), "java/util/Iterator")) {
+      return false;
+    }
+    return "hasNext".equals(iexp.getName()) && "()Z".equals(iexp.getStringDescriptor());
+  }
+
+  private static boolean isNextCall(Exprent exp) {
+    final InvocationExprent iexp = asInvocationExprent(exp);
+    if (iexp == null) {
+      return false;
+    }
+    if (!DecompilerContext.getStructContext().instanceOf(iexp.getClassname(), "java/util/Iterator")) {
+      return false;
+    }
+    return "next".equals(iexp.getName()) && "()Ljava/lang/Object;".equals(iexp.getStringDescriptor());
+  }
+
+  private static boolean isNextUnboxing(Exprent exprent) {
+    Exprent exp = getUncast(exprent);
+    if (exp.type != Exprent.EXPRENT_INVOCATION)
+      return false;
+    InvocationExprent inv = (InvocationExprent)exp;
+    return inv.isUnboxingCall() && isNextCall(inv.getInstance());
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
index d73535f..94dc0a3 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
@@ -5,19 +5,31 @@ import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.ConstExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.FunctionExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectNode;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.FlattenStatementsHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 
 public class PPandMMHelper {
 
   private boolean exprentReplaced;
+  private VarProcessor varProc;
+  private Map<VarVersionPair, VarVersionPair> remaps = new HashMap<>();
+
+  public PPandMMHelper(VarProcessor varProc) {
+    this.varProc = varProc;
+  }
 
   public boolean findPPandMM(RootStatement root) {
 
@@ -45,6 +57,8 @@ public class PPandMMHelper {
       stack.addAll(node.succs);
     }
 
+    updateVersions(dgraph);
+
     return res;
   }
 
@@ -120,13 +134,18 @@ public class PPandMMHelper {
             Exprent left = as.getLeft();
 
             VarType condtype = econd.getExprType();
-            if (left.equals(econd) && (midlayer == null || midlayer.equals(condtype))) {
+            if (exprsEqual(left, econd) && (midlayer == null || midlayer.equals(condtype))) {
               FunctionExprent ret = new FunctionExprent(
                 func.getFuncType() == FunctionExprent.FUNCTION_ADD ? FunctionExprent.FUNCTION_PPI : FunctionExprent.FUNCTION_MMI,
                 econd, func.bytecode);
               ret.setImplicitType(condtype);
 
               exprentReplaced = true;
+
+              if (!left.equals(econd)) {
+                remaps.put(new VarVersionPair((VarExprent)left), new VarVersionPair((VarExprent)econd));
+              }
+
               return ret;
             }
           }
@@ -136,4 +155,48 @@ public class PPandMMHelper {
 
     return null;
   }
+
+  private boolean exprsEqual(Exprent e1, Exprent e2) {
+    if (e1 == e2) return true;
+    if (e1 == null || e2 == null) return false;
+    if (e1.type == VarExprent.EXPRENT_VAR) {
+      return varsEqual(e1, e2);
+    }
+    return e1.equals(e2);
+  }
+
+  private boolean varsEqual(Exprent e1, Exprent e2) {
+    if (!(e1 instanceof VarExprent)) return false;
+    if (!(e2 instanceof VarExprent)) return false;
+
+    VarExprent v1 = (VarExprent)e1;
+    VarExprent v2 = (VarExprent)e2;
+    return varProc.getVarOriginalIndex(v1.getIndex()) == varProc.getVarOriginalIndex(v2.getIndex())
+            && InterpreterUtil.equalObjects(v1.getVarType(), v2.getVarType());
+  }
+
+
+  private void updateVersions(DirectGraph graph) {
+    if (remaps.isEmpty()) return;
+    graph.iterateExprents(new DirectGraph.ExprentIterator() {
+      @Override
+      public int processExprent(Exprent exprent) {
+        List<Exprent> lst = exprent.getAllExprents(true);
+        lst.add(exprent);
+
+        for (Exprent expr : lst) {
+          if (expr.type == Exprent.EXPRENT_VAR) {
+            VarExprent var = (VarExprent)expr;
+            VarVersionPair nvar = remaps.get(new VarVersionPair(var));
+            if (nvar != null) {
+              var.setIndex(nvar.var);
+              var.setVersion(nvar.version);
+            }
+          }
+        }
+
+        return 0;
+      }
+    });
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java b/src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
index c481c0a..cdbcb70 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
@@ -35,6 +35,8 @@ public class StatEdge {
 
   public boolean explicit = true;
 
+  public boolean canInline = true;
+
   public StatEdge(int type, Statement source, Statement destination, Statement closure) {
     this(type, source, destination);
     this.closure = closure;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index 1b5eeb5..97a820c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -467,7 +467,7 @@ public class InvocationExprent extends Exprent {
     UNBOXING_METHODS.put("charValue", "java/lang/Character");
   }
 
-  private boolean isUnboxingCall() {
+  public boolean isUnboxingCall() {
     return !isStatic && lstParameters.size() == 0 && classname.equals(UNBOXING_METHODS.get(name));
   }
 
@@ -668,4 +668,4 @@ public class InvocationExprent extends Exprent {
 
     return true;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index 93b2b08..0c3c48f 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -12,12 +12,15 @@ import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarTypeProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTypeTableAttribute;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
@@ -31,6 +34,7 @@ import org.jetbrains.java.decompiler.util.TextUtil;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.List;
+import java.util.stream.Collectors;
 
 public class VarExprent extends Exprent {
 
@@ -44,6 +48,7 @@ public class VarExprent extends Exprent {
   private int version = 0;
   private boolean classDef = false;
   private boolean stack = false;
+  private LocalVariable lvt = null;
 
   public VarExprent(int index, VarType varType, VarProcessor processor) {
     this(index, varType, processor, null);
@@ -79,6 +84,7 @@ public class VarExprent extends Exprent {
     var.setVersion(version);
     var.setClassDef(classDef);
     var.setStack(stack);
+    var.setLVT(lvt);
     return var;
   }
 
@@ -95,10 +101,6 @@ public class VarExprent extends Exprent {
     }
     else {
       VarVersionPair varVersion = getVarVersionPair();
-      String name = null;
-      if (processor != null) {
-        name = processor.getVarName(varVersion);
-      }
 
       if (definition) {
         if (processor != null && processor.getVarFinal(varVersion) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {
@@ -108,7 +110,7 @@ public class VarExprent extends Exprent {
         buffer.append(" ");
       }
 
-      buffer.append(name == null ? ("var" + index + (this.version == 0 ? "" : "_" + this.version)) : name);
+      buffer.append(getName());
     }
 
     return buffer;
@@ -118,6 +120,7 @@ public class VarExprent extends Exprent {
     return new VarVersionPair(index, version);
   }
 
+  /*
   public String getDebugName(StructMethod method) {
     StructLocalVariableTableAttribute attr = method.getLocalVariableAttr();
     if (attr != null && processor != null) {
@@ -131,9 +134,25 @@ public class VarExprent extends Exprent {
     }
     return null;
   }
+  */
 
   private void appendDefinitionType(TextBuffer buffer) {
     if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_VAR_NAMES)) {
+
+      if (lvt != null) {
+        if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+          if (lvt.getSignature() != null) {
+            GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(lvt.getSignature());
+            if (descriptor != null) {
+              buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));
+              return;
+            }
+          }
+        }
+        buffer.append(ExprProcessor.getCastTypeName(getVarType()));
+        return;
+      }
+
       MethodWrapper method = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
       if (method != null) {
         Integer originalIndex = null;
@@ -199,6 +218,10 @@ public class VarExprent extends Exprent {
   }
 
   public VarType getVarType() {
+    if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_VAR_NAMES) && lvt != null) {
+      return new VarType(lvt.getDescriptor());
+    }
+
     VarType vt = null;
     if (processor != null) {
       vt = processor.getVarType(getVarVersionPair());
@@ -251,6 +274,86 @@ public class VarExprent extends Exprent {
     this.stack = stack;
   }
 
+  public void setLVT(LocalVariable var) {
+    this.lvt = var;
+    if (processor != null && lvt != null) {
+      processor.setVarType(getVarVersionPair(), lvt.getVarType());
+    }
+  }
+
+  public LocalVariable getLVT() {
+    return lvt;
+  }
+
+  public String getName() {
+    VarVersionPair pair = getVarVersionPair();
+    if (lvt != null)
+      return lvt.getName();
+
+    if (processor != null) {
+      return processor.getVarName(pair);
+    }
+
+    return pair.version == 0 ? "var" + pair.var : "var" + pair.var + "_" + version;
+  }
+
+  @Override
+  public CheckTypesResult checkExprTypeBounds() {
+    if (lvt != null) {
+      CheckTypesResult ret = new CheckTypesResult();
+      ret.addMinTypeExprent(this, lvt.getVarType());
+      return ret;
+    }
+    return null;
+  }
+
+  public boolean isVarReferenced(Statement stat, VarExprent... whitelist) {
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          if (isVarReferenced((Statement)obj, whitelist)) {
+            return true;
+          }
+        }
+        else if (obj instanceof Exprent) {
+          if (isVarReferenced((Exprent)obj, whitelist)) {
+            return true;
+          }
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        if (isVarReferenced(exp, whitelist)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  public boolean isVarReferenced(Exprent exp, VarExprent... whitelist) {
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+    lst = lst.stream().filter(e -> e != this && e.type == Exprent.EXPRENT_VAR &&
+      getVarVersionPair().equals(((VarExprent)e).getVarVersionPair()))
+        .collect(Collectors.toList());
+
+    for (Exprent var : lst) {
+      boolean allowed = false;
+      for (VarExprent white : whitelist) {
+        if (var == white) {
+          allowed = true;
+          break;
+        }
+      }
+      if (!allowed) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
index 6f33885..ba61e34 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
@@ -113,6 +113,21 @@ public class DirectGraph {
     return true;
   }
 
+  public boolean iterateExprentsDeep(ExprentIterator itr) {
+    return iterateExprents(exprent -> {
+      List<Exprent> lst = exprent.getAllExprents(true);
+      lst.add(exprent);
+
+      for (Exprent expr : lst) {
+        int res = itr.processExprent(expr);
+        if (res == 1 || res == 2) {
+          return res;
+        }
+      }
+      return 0;
+    });
+  }
+
   public interface ExprentIterator {
     // 0 - success, do nothing
     // 1 - cancel iteration
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
index f1dbf9f..0724aef 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
@@ -201,6 +201,7 @@ public class FlattenStatementsHelper {
                 sourcenode = node;
                 break;
               case DoStatement.LOOP_FOR:
+              case DoStatement.LOOP_FOREACH:
                 DirectNode nodeinit = new DirectNode(DirectNode.NODE_INIT, stat, stat.id + "_init");
                 if (dostat.getInitExprent() != null) {
                   nodeinit.exprents = dostat.getInitExprentList();
@@ -208,7 +209,9 @@ public class FlattenStatementsHelper {
                 graph.nodes.putWithKey(nodeinit, nodeinit.id);
 
                 DirectNode nodecond = new DirectNode(DirectNode.NODE_CONDITION, stat, stat.id + "_cond");
-                nodecond.exprents = dostat.getConditionExprentList();
+                if (looptype != DoStatement.LOOP_FOREACH) {
+                  nodecond.exprents = dostat.getConditionExprentList();
+                }
                 graph.nodes.putWithKey(nodecond, nodecond.id);
 
                 DirectNode nodeinc = new DirectNode(DirectNode.NODE_INCREMENT, stat, stat.id + "_inc");
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
index 8d50513..e110963 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
@@ -4,6 +4,7 @@
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
@@ -51,7 +52,7 @@ public class CatchAllStatement extends Statement {
         post = edge.getDestination();
       }
     }
-
+    
     vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
                             new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Throwable"),
                             DecompilerContext.getVarProcessor()));
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
index 87b9bd9..f74fe84 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
@@ -43,7 +43,7 @@ public class CatchStatement extends Statement {
       if (setHandlers.contains(stat)) {
         stats.addWithKey(stat, stat.id);
         exctstrings.add(new ArrayList<>(edge.getExceptions()));
-
+        
         vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
                                 new VarType(CodeConstants.TYPE_OBJECT, 0, edge.getExceptions().get(0)),
                                 // FIXME: for now simply the first type. Should get the first common superclass when possible.
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
index 06a3a80..6631c8b 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
@@ -19,6 +19,7 @@ public class DoStatement extends Statement {
   public static final int LOOP_DOWHILE = 1;
   public static final int LOOP_WHILE = 2;
   public static final int LOOP_FOR = 3;
+  public static final int LOOP_FOREACH = 4;
 
   private int looptype;
 
@@ -123,6 +124,13 @@ public class DoStatement extends Statement {
         buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));
         buf.appendIndent(indent).append("}").appendLineSeparator();
         tracer.incrementCurrentSourceLine();
+        break;
+      case LOOP_FOREACH:
+        buf.appendIndent(indent).append("for(").append(initExprent.get(0).toJava(indent, tracer));
+        buf.append(" : ").append(incExprent.get(0).toJava(indent, tracer)).append(") {").appendLineSeparator();
+        tracer.incrementCurrentSourceLine();
+        buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));
+        buf.appendIndent(indent).append("}").appendLineSeparator();
     }
 
     return buf;
@@ -139,6 +147,10 @@ public class DoStatement extends Statement {
         }
       case LOOP_WHILE:
         lst.add(getConditionExprent());
+        break;
+      case LOOP_FOREACH:
+        lst.add(getInitExprent());
+        lst.add(getIncExprent());
     }
 
     lst.add(first);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
index 92b45b6..78f990a 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
@@ -803,6 +803,14 @@ public class Statement implements IMatchable {
     this.parent = parent;
   }
 
+  public Statement getTopParent() {
+    Statement ret = this;
+    while (ret.getParent() != null) {
+      ret = ret.getParent();
+    }
+    return ret;
+  }
+
   public HashSet<StatEdge> getLabelEdges() {  // FIXME: why HashSet?
     return labelEdges;
   }
@@ -829,7 +837,7 @@ public class Statement implements IMatchable {
 
   // helper methods
   public String toString() {
-    return id.toString();
+    return String.format("{%d}:%d", type, id);
   }
 
   //TODO: Cleanup/cache?
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 0402097..01fd4af 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -4,16 +4,23 @@ package org.jetbrains.java.decompiler.modules.decompiler.vars;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.ConstExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.DoStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 
 import java.util.*;
 import java.util.Map.Entry;
@@ -29,6 +36,9 @@ public class VarDefinitionHelper {
 
   private final VarProcessor varproc;
 
+  private final Statement root;
+  private final StructMethod mt;
+
   public VarDefinitionHelper(Statement root, StructMethod mt, VarProcessor varproc) {
 
     mapVarDefStatements = new HashMap<>();
@@ -36,6 +46,8 @@ public class VarDefinitionHelper {
     implDefVars = new HashSet<>();
 
     this.varproc = varproc;
+    this.root = root;
+    this.mt = mt;
 
     VarNamesCollector vc = varproc.getVarNamesCollector();
 
@@ -49,12 +61,12 @@ public class VarDefinitionHelper {
     }
     paramcount += md.params.length;
 
-
     // method parameters are implicitly defined
     int varindex = 0;
     for (int i = 0; i < paramcount; i++) {
       implDefVars.add(varindex);
-      varproc.setVarName(new VarVersionPair(varindex, 0), vc.getFreeName(varindex));
+      VarVersionPair vpp = new VarVersionPair(varindex, 0);
+      varproc.setVarName(vpp, vc.getFreeName(varindex));
 
       if (thisvar) {
         if (i == 0) {
@@ -77,6 +89,8 @@ public class VarDefinitionHelper {
       vc.addName("this");
     }
 
+    mergeVars(root);
+
     // catch variables are implicitly defined
     LinkedList<Statement> stack = new LinkedList<>();
     stack.add(root);
@@ -106,7 +120,6 @@ public class VarDefinitionHelper {
     initStatement(root);
   }
 
-
   public void setVarDefinitions() {
     VarNamesCollector vc = varproc.getVarNamesCollector();
 
@@ -139,9 +152,17 @@ public class VarDefinitionHelper {
             }
           }
         }
+        else if (dstat.getLooptype() == DoStatement.LOOP_FOREACH) {
+          if (dstat.getInitExprent() != null && dstat.getInitExprent().type == Exprent.EXPRENT_VAR) {
+            VarExprent var = (VarExprent)dstat.getInitExprent();
+            if (var.getIndex() == index.intValue()) {
+              var.setDefinition(true);
+              continue;
+            }
+          }
+        }
       }
 
-
       Statement first = findFirstBlock(stat, index);
 
       List<Exprent> lst;
@@ -155,7 +176,6 @@ public class VarDefinitionHelper {
         lst = first.getExprents();
       }
 
-
       boolean defset = false;
 
       // search for the first assignment to var [index]
@@ -184,9 +204,17 @@ public class VarDefinitionHelper {
         VarExprent var = new VarExprent(index, varproc.getVarType(new VarVersionPair(index.intValue(), 0)), varproc);
         var.setDefinition(true);
 
+        LocalVariable lvt = findLVT(index.intValue(), stat);
+        if (lvt != null) { 
+          var.setLVT(lvt);
+        }
+
         lst.add(addindex, var);
       }
     }
+
+    mergeVars(root);
+    propogateLVTs(root);
   }
 
 
@@ -194,6 +222,50 @@ public class VarDefinitionHelper {
   // private methods
   // *****************************************************************************
 
+  private LocalVariable findLVT(int index, Statement stat) {
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          LocalVariable lvt = findLVT(index, (Statement)obj);
+          if (lvt != null) {
+            return lvt;
+          }
+        }
+        else if (obj instanceof Exprent) {
+          LocalVariable lvt = findLVT(index, (Exprent)obj);
+          if (lvt != null) {
+            return lvt;
+          }
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        LocalVariable lvt = findLVT(index, exp);
+        if (lvt != null) {
+          return lvt;
+        }
+      }
+    }
+    return null;
+  }
+
+  private LocalVariable findLVT(int index, Exprent exp) {
+    for (Exprent e: exp.getAllExprents(false)) {
+      LocalVariable lvt = findLVT(index, e);
+      if (lvt != null) {
+        return lvt;
+      }
+    }
+
+    if (exp.type != Exprent.EXPRENT_VAR) {
+      return null;
+    }
+
+    VarExprent var = (VarExprent)exp;
+    return var.getIndex() == index ? var.getLVT() : null;
+  }
+
   private Statement findFirstBlock(Statement stat, Integer varindex) {
 
     LinkedList<Statement> stack = new LinkedList<>();
@@ -254,6 +326,7 @@ public class VarDefinitionHelper {
           if (st.type == DoStatement.TYPE_DO) {
             DoStatement dost = (DoStatement)st;
             if (dost.getLooptype() != DoStatement.LOOP_FOR &&
+                dost.getLooptype() != DoStatement.LOOP_FOREACH &&
                 dost.getLooptype() != DoStatement.LOOP_DO) {
               currVars.add(dost.getConditionExprent());
             }
@@ -324,7 +397,7 @@ public class VarDefinitionHelper {
     return res;
   }
 
-  private static boolean setDefinition(Exprent expr, Integer index) {
+  private boolean setDefinition(Exprent expr, Integer index) {
     if (expr.type == Exprent.EXPRENT_ASSIGNMENT) {
       Exprent left = ((AssignmentExprent)expr).getLeft();
       if (left.type == Exprent.EXPRENT_VAR) {
@@ -337,4 +410,561 @@ public class VarDefinitionHelper {
     }
     return false;
   }
+
+
+  private VPPEntry mergeVars(Statement stat) {
+    Map<Integer, VarVersionPair> parent = new HashMap<Integer, VarVersionPair>(); // Always empty dua!
+    MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
+
+    int index = 0;
+    if (!mt.hasModifier(CodeConstants.ACC_STATIC)) {
+      parent.put(index, new VarVersionPair(index++, 0));
+    }
+
+    for (VarType var : md.params) {
+      parent.put(index, new VarVersionPair(index, 0));
+      index += var.stackSize;
+    }
+
+    Map<VarVersionPair, VarVersionPair> blacklist = new HashMap<VarVersionPair, VarVersionPair>();
+    VPPEntry remap = mergeVars(stat, parent, new HashMap<Integer, VarVersionPair>(), blacklist);
+    while (remap != null) {
+      //System.out.println("Remapping: " + remap.getKey() + " -> " + remap.getValue());
+      if (!remapVar(stat, remap.getKey(), remap.getValue())) {
+        blacklist.put(remap.getKey(), remap.getValue());
+      }
+      remap = mergeVars(stat, parent, new HashMap<Integer, VarVersionPair>(), blacklist);
+    }
+    return null;
+  }
+
+
+  private VPPEntry mergeVars(Statement stat, Map<Integer, VarVersionPair> parent, Map<Integer, VarVersionPair> leaked, Map<VarVersionPair, VarVersionPair> blacklist) {
+    Map<Integer, VarVersionPair> this_vars = new HashMap<Integer, VarVersionPair>();
+    if (parent.size() > 0)
+      this_vars.putAll(parent);
+
+    if (stat.getVarDefinitions().size() > 0) {
+      for (int x = 0; x < stat.getVarDefinitions().size(); x++) {
+        Exprent exp = stat.getVarDefinitions().get(x);
+        if (exp.type == Exprent.EXPRENT_VAR) {
+          VarExprent var = (VarExprent)exp;
+          int index = varproc.getVarOriginalIndex(var.getIndex());
+          if (this_vars.containsKey(index)) {
+            stat.getVarDefinitions().remove(x);
+            return new VPPEntry(var, this_vars.get(index));
+          }
+          this_vars.put(index, new VarVersionPair(var));
+          leaked.put(index, new VarVersionPair(var));
+        }
+      }
+    }
+
+    Map<Integer, VarVersionPair> scoped = null;
+    switch (stat.type) { // These are the type of statements that leak vars
+      case Statement.TYPE_BASICBLOCK:
+      case Statement.TYPE_GENERAL:
+      case Statement.TYPE_ROOT:
+      case Statement.TYPE_SEQUENCE:
+        scoped = leaked;
+    }
+
+    if (stat.getExprents() == null) {
+      List<Object> objs = stat.getSequentialObjects();
+      for (int i = 0; i < objs.size(); i++) {
+        Object obj = objs.get(i);
+        if (obj instanceof Statement) {
+          Statement st = (Statement)obj;
+
+          //Map<VarVersionPair, VarVersionPair> blacklist_n = new HashMap<VarVersionPair, VarVersionPair>();
+          Map<Integer, VarVersionPair> leaked_n = new HashMap<Integer, VarVersionPair>();
+          VPPEntry remap = mergeVars(st, this_vars, leaked_n, blacklist);
+
+          if (remap != null) {
+            return remap;
+          }
+          /* TODO: See if we can optimize and only go up till needed.
+          while (remap != null) {
+            System.out.println("Remapping: " + remap.getKey() + " -> " + remap.getValue());
+            VarVersionPair var = parent.get(varproc.getRemapped(remap.getValue().var));
+            if (remap.getValue().equals(var)) { //Drill up to original declaration.
+              return remap;
+            }
+            if (!remapVar(stat, remap.getKey(), remap.getValue())) {
+              blacklist_n.put(remap.getKey(), remap.getValue());
+            }
+            leaked_n.clear();
+            remap = mergeVars(st, this_vars, leaked_n, blacklist_n);
+          }
+          */
+
+          if (leaked_n.size() > 0) {
+            if (stat.type == Statement.TYPE_IF) {
+              IfStatement ifst = (IfStatement)stat;
+              if (obj == ifst.getIfstat() || obj == ifst.getElsestat()) {
+                leaked_n.clear(); // Force no leaking at the end of if blocks
+                // We may need to do this for Switches as well.. But havent run into that issue yet...
+              }
+              else if (obj == ifst.getFirst()) {
+                leaked.putAll(leaked_n); //First is outside the scope so leak!
+              }
+            } else if (stat.type == Statement.TYPE_SWITCH ||
+                       stat.type == Statement.TYPE_SYNCRONIZED) {
+              if (obj == stat.getFirst()) {
+                leaked.putAll(leaked_n); //First is outside the scope so leak!
+              }
+              else {
+                leaked_n.clear();
+              }
+            }
+            else if (stat.type == Statement.TYPE_TRYCATCH ||
+              stat.type == Statement.TYPE_CATCHALL) {
+              leaked_n.clear(); // Catches can't leak anything mwhahahahah!
+            }
+            this_vars.putAll(leaked_n);
+          }
+        }
+        else if (obj instanceof Exprent) {
+          VPPEntry ret = processExprent((Exprent)obj, this_vars, scoped, blacklist);
+          if (ret != null && isVarReadFirst(ret.getValue(), stat, i + 1)) {
+            return ret;
+          }
+        }
+      }
+    }
+    else {
+      List<Exprent> exps = stat.getExprents();
+      for (int i = 0; i < exps.size(); i++) {
+        VPPEntry ret = processExprent(exps.get(i), this_vars, scoped, blacklist);
+        if (ret != null && !isVarReadFirst(ret.getValue(), stat, i + 1)) {
+          return ret;
+        }
+      }
+    }
+    return null; // We made it with no remaps!!!!!!!
+  }
+
+  private VPPEntry processExprent(Exprent exp, Map<Integer, VarVersionPair> this_vars, Map<Integer, VarVersionPair> leaked, Map<VarVersionPair, VarVersionPair> blacklist) {
+    VarExprent var = null;
+
+    if (exp.type == Exprent.EXPRENT_ASSIGNMENT) {
+      AssignmentExprent ass = (AssignmentExprent)exp;
+      if (ass.getLeft().type != Exprent.EXPRENT_VAR) {
+        return null;
+      }
+
+      var = (VarExprent)ass.getLeft();
+    }
+    else if (exp.type == Exprent.EXPRENT_VAR) {
+      var = (VarExprent)exp;
+    }
+
+    if (var == null) {
+      return null;
+    }
+
+    if (!var.isDefinition()) {
+      return null;
+    }
+
+    int index = varproc.getVarOriginalIndex(var.getIndex());
+    VarVersionPair new_ = this_vars.get(index);
+    if (new_ != null) {
+      VarVersionPair old = new VarVersionPair(var);
+      VarVersionPair black = blacklist.get(old);
+      if (black == null || !black.equals(new_)) {
+        return new VPPEntry(var, this_vars.get(index));
+      }
+    }
+    this_vars.put(index, new VarVersionPair(var));
+
+    if (leaked != null) {
+      leaked.put(index, new VarVersionPair(var));
+    }
+
+    return null;
+  }
+
+  private boolean remapVar(Statement stat, VarVersionPair from, VarVersionPair to) {
+    if (from.equals(to))
+      throw new IllegalArgumentException("Shit went wrong: " + from);
+    boolean success = false;
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          success |= remapVar((Statement)obj, from, to);
+        }
+        else if (obj instanceof Exprent) {
+          if (remapVar((Exprent)obj, from, to)) {
+            success = true;
+          }
+        }
+      }
+    }
+    else {
+      boolean remapped = false;
+      for (int x = 0; x < stat.getExprents().size(); x++) {
+        Exprent exp = stat.getExprents().get(x);
+        if (remapVar(exp, from, to)) {
+          remapped = true;
+          if (exp.type == Exprent.EXPRENT_VAR) {
+            if (!((VarExprent)exp).isDefinition()) {
+              stat.getExprents().remove(x);
+              x--;
+            }
+          }
+        }
+      }
+      success |= remapped;
+    }
+
+    if (success) {
+      Iterator<Exprent> itr = stat.getVarDefinitions().iterator();
+      while (itr.hasNext()) {
+        Exprent exp = itr.next();
+        if (exp.type == Exprent.EXPRENT_VAR) {
+          VarExprent var = (VarExprent)exp;
+          if (from.equals(var.getVarVersionPair())) {
+            itr.remove();
+          }
+          else if (to.var == var.getIndex() && to.version == var.getVersion()) {
+            Map<VarVersionPair, VarType> mapExprentMinTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMinTypes();
+            Map<VarVersionPair, VarType> mapExprentMaxTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMaxTypes();
+            VarType merged = getMergedType(mapExprentMinTypes.get(from), mapExprentMinTypes.get(to),
+                                           mapExprentMaxTypes.get(from), mapExprentMaxTypes.get(to));
+
+            if (merged == null) { // Something went wrong.. This SHOULD be non-null
+              continue;
+            }
+
+            var.setVarType(merged);
+          }
+        }
+      }
+    }
+
+    return success;
+  }
+
+  private boolean remapVar(Exprent exprent, VarVersionPair from, VarVersionPair to) {
+    if (exprent == null) { // Sometimes there are null exprents?
+      return false;
+    }
+    List<Exprent> lst = exprent.getAllExprents(true);
+    lst.add(exprent);
+    Map<VarVersionPair, VarType> mapExprentMinTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMinTypes();
+    Map<VarVersionPair, VarType> mapExprentMaxTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMaxTypes();
+
+    boolean remapped = false;
+
+    for (Exprent expr : lst) {
+      if (expr.type == Exprent.EXPRENT_ASSIGNMENT) {
+        AssignmentExprent ass = (AssignmentExprent)expr;
+        if (ass.getLeft().type == Exprent.EXPRENT_VAR && ass.getRight().type == Exprent.EXPRENT_CONST) {
+          VarVersionPair left = new VarVersionPair((VarExprent)ass.getLeft());
+          if (!left.equals(from) && !left.equals(to)) {
+            continue;
+          }
+
+          ConstExprent right = (ConstExprent)ass.getRight();
+          if (right.getConstType() == VarType.VARTYPE_NULL) {
+            continue;
+          }
+          VarType merged = getMergedType(mapExprentMinTypes.get(from), mapExprentMinTypes.get(to),
+                                         mapExprentMaxTypes.get(from), mapExprentMaxTypes.get(to));
+
+          if (merged == null) { // Types incompatible, do not merge
+            continue;
+          }
+
+          right.setConstType(merged);
+        }
+      }
+      else if (expr.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)expr;
+        VarVersionPair old = new VarVersionPair(var);
+        if (!old.equals(from)) {
+          continue;
+        }
+        VarType merged = getMergedType(mapExprentMinTypes.get(from), mapExprentMinTypes.get(to),
+                                       mapExprentMaxTypes.get(from), mapExprentMaxTypes.get(to));
+        if (merged == null) { // Types incompatible, do not merge
+          continue;
+        }
+
+        var.setIndex(to.var);
+        var.setVersion(to.version);
+        var.setVarType(merged);
+        if (var.isDefinition()) {
+          var.setDefinition(false);
+        }
+        mapExprentMinTypes.put(to, merged);
+        remapped = true;
+      }
+    }
+    return remapped;
+  }
+
+  private VarType getMergedType(VarType firstMin, VarType secondMin, VarType firstMax, VarType secondMax) {
+    if (firstMin != null && firstMin.equals(secondMin)) {
+      return firstMin; // Short circuit this for simplicities sake
+    }
+    VarType type = firstMin == null ? secondMin : (secondMin == null ? firstMin : VarType.getCommonSupertype(firstMin, secondMin));
+    if (type == null || firstMin == null || secondMin == null) {
+      return null; // no common supertype, skip the remapping
+    }
+    if (type.typeFamily == CodeConstants.TYPE_FAMILY_OBJECT) {
+      if (firstMax != null && secondMax != null) {
+        type = VarType.getCommonMinType(firstMax, secondMax);
+      } else if (firstMin.arrayDim != secondMin.arrayDim) {
+        return null; // Don't merge is arrays don't match.
+      } else {
+        type = VarType.getCommonMinType(firstMin, secondMin);
+        // couldn't find a sane common supertype, we're not gonna be able to merge
+        if (type == null || type == VarType.VARTYPE_NULL) {
+          return null;
+        }
+      }
+    }
+    return type;
+  }
+
+  private void propogateLVTs(Statement stat) {
+    MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
+    Map<VarVersionPair, VarInfo> types = new LinkedHashMap<>();
+
+    if (varproc.hasLVT()) {
+      int index = 0;
+      if (!mt.hasModifier(CodeConstants.ACC_STATIC)) {
+        List<LocalVariable> lvt = varproc.getCandidates(index); // Some enums give incomplete lvts?
+        if (lvt != null && lvt.size() > 0) {
+          types.put(new VarVersionPair(index, 0), new VarInfo(lvt.get(0), null));
+        }
+        index++;
+      }
+
+      for (VarType var : md.params) {
+        List<LocalVariable> lvt = varproc.getCandidates(index); // Some enums give incomplete lvts?
+        if (lvt != null && lvt.size() > 0) {
+          types.put(new VarVersionPair(index, 0), new VarInfo(lvt.get(0), null));
+        }
+        index += var.stackSize;
+      }
+    }
+
+    findTypes(stat, types);
+
+    Map<VarVersionPair,String> typeNames = new LinkedHashMap<VarVersionPair,String>();
+    for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
+      typeNames.put(e.getKey(), e.getValue().typeName());
+    }
+    Map<VarVersionPair, LocalVariable> lvts = new HashMap<>();
+
+    for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
+      VarVersionPair idx = e.getKey();
+      // skip this. we can't rename it
+      if (idx.var == 0 && !mt.hasModifier(CodeConstants.ACC_STATIC)) {
+        continue;
+      }
+      LocalVariable lvt = e.getValue().lvt;
+      if (lvt != null) {
+        varproc.setVarLVT(idx, lvt);
+        lvts.put(idx, lvt);
+      }
+    }
+
+
+    applyTypes(stat, lvts);
+  }
+
+  private void findTypes(Statement stat, Map<VarVersionPair, VarInfo> types) {
+    if (stat == null) {
+      return;
+    }
+
+    for (Exprent exp : stat.getVarDefinitions()) {
+      findTypes(exp, types);
+    }
+
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          findTypes((Statement)obj, types);
+        }
+        else if (obj instanceof Exprent) {
+          findTypes((Exprent)obj, types);
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        findTypes(exp, types);
+      }
+    }
+  }
+
+  private void findTypes(Exprent exp, Map<VarVersionPair, VarInfo> types) {
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+
+    for (Exprent exprent : lst) {
+      if (exprent.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)exprent;
+        VarVersionPair ver = new VarVersionPair(var);
+        if (var.isDefinition()) {
+          types.put(ver, new VarInfo(var.getLVT(), var.getVarType()));
+        }
+        else if (!types.containsKey(ver)) {
+          types.put(ver, new VarInfo(var.getLVT(), var.getVarType()));
+        }
+      }
+    }
+  }
+
+  private void applyTypes(Statement stat, Map<VarVersionPair, LocalVariable> types) {
+    if (stat == null || types.size() == 0) {
+      return;
+    }
+
+    for (Exprent exp : stat.getVarDefinitions()) {
+      applyTypes(exp, types);
+    }
+
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          applyTypes((Statement)obj, types);
+        }
+        else if (obj instanceof Exprent) {
+          applyTypes((Exprent)obj, types);
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        applyTypes(exp, types);
+      }
+    }
+  }
+
+  private void applyTypes(Exprent exprent, Map<VarVersionPair, LocalVariable> types) {
+    if (exprent == null) {
+      return;
+    }
+    List<Exprent> lst = exprent.getAllExprents(true);
+    lst.add(exprent);
+
+    for (Exprent expr : lst) {
+      if (expr.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)expr;
+        LocalVariable lvt = types.get(new VarVersionPair(var));
+        if (lvt != null) {
+          var.setLVT(lvt);
+        } else {
+          System.currentTimeMillis();
+        }
+      }
+    }
+  }
+  
+  //Helper classes because Java is dumb and doesn't have a Pair<K,V> class
+  private static class SimpleEntry<K, V> implements Entry<K, V> {
+    private K key;
+    private V value;
+    public SimpleEntry(K key, V value) {
+      this.key = key;
+      this.value = value;
+    }
+    @Override public K getKey() { return key; }
+    @Override public V getValue() { return value; }
+    @Override
+    public V setValue(V value) {
+      V tmp = this.value;
+      this.value = value;
+      return tmp;
+    }
+  }
+  private static class VPPEntry extends SimpleEntry<VarVersionPair, VarVersionPair> {
+    public VPPEntry(VarExprent key, VarVersionPair value) {
+        super(new VarVersionPair(key), value);
+    }
+  }
+  private static class VarInfo {
+    LocalVariable lvt;
+    String cast;
+    private VarInfo(LocalVariable lvt, VarType type) {
+      if (lvt != null && lvt.getSignature() != null) {
+        cast = GenericMain.getGenericCastTypeName(new GenericType(lvt.getSignature()));
+      }
+      else if (lvt != null) {
+        cast = ExprProcessor.getCastTypeName(lvt.getVarType(), false);
+      }
+      else if (type != null) {
+        cast = ExprProcessor.getCastTypeName(type, false);
+      }
+      else {
+        cast = "this";
+      }
+      this.lvt = lvt;
+    }
+
+    public String typeName() {
+      return cast;
+    }
+  }
+
+  private static boolean isVarReadFirst(VarVersionPair var, Statement stat, int index, VarExprent... whitelist) {
+    if (stat.getExprents() == null) {
+      List<Object> objs = stat.getSequentialObjects();
+      for (int x = index; x < objs.size(); x++) {
+        Object obj = objs.get(x);
+        if (obj instanceof Statement) {
+          if (isVarReadFirst(var, (Statement)obj, 0, whitelist)) {
+            return true;
+          }
+        }
+        else if (obj instanceof Exprent) {
+          if (isVarReadFirst(var, (Exprent)obj, whitelist)) {
+            return true;
+          }
+        }
+      }
+    }
+    else {
+      for (int x = index; x < stat.getExprents().size(); x++) {
+        if (isVarReadFirst(var, stat.getExprents().get(x), whitelist)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static boolean isVarReadFirst(VarVersionPair target, Exprent exp, VarExprent... whitelist) {
+    AssignmentExprent ass = exp.type == Exprent.EXPRENT_ASSIGNMENT ? (AssignmentExprent)exp : null;
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+    for (Exprent ex : lst) {
+      if (ex.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)ex;
+        if (var.getIndex() == target.var && var.getVersion() == target.version) {
+          boolean allowed = false;
+          if (ass != null) {
+            if (var == ass.getLeft()) {
+              allowed = true;
+            }
+          }
+          for (VarExprent white : whitelist) {
+            if (var == white) {
+              allowed = true;
+            }
+          }
+          if (!allowed) {
+            return true;
+          }
+        }
+      }
+    }
+    return false;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
index 9999b50..ec60c00 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
@@ -2,21 +2,26 @@
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.StartEndPair;
 import org.jetbrains.java.decompiler.util.TextUtil;
 
 import java.util.*;
 import java.util.Map.Entry;
+import java.util.stream.Collectors;
 
 public class VarProcessor {
   private final VarNamesCollector varNamesCollector = new VarNamesCollector();
   private final StructMethod method;
   private final MethodDescriptor methodDescriptor;
   private Map<VarVersionPair, String> mapVarNames = new HashMap<>();
+  private Map<VarVersionPair, LocalVariable> mapVarLVTs = new HashMap<>();
   private VarVersionsProcessor varVersions;
   private final Map<VarVersionPair, String> thisVars = new HashMap<>();
   private final Set<VarVersionPair> externalVars = new HashSet<>();
@@ -37,12 +42,12 @@ public class VarProcessor {
     new VarDefinitionHelper(root, method, this).setVarDefinitions();
   }
 
-  public void setDebugVarNames(Map<Integer, String> mapDebugVarNames) {
+  public void setDebugVarNames(Map<VarVersionPair, String> mapDebugVarNames) {
     if (varVersions == null) {
       return;
     }
 
-    Map<Integer, Integer> mapOriginalVarIndices = varVersions.getMapOriginalVarIndices();
+    Map<Integer, VarVersionPair> mapOriginalVarIndices = varVersions.getMapOriginalVarIndices();
 
     List<VarVersionPair> listVars = new ArrayList<>(mapVarNames.keySet());
     listVars.sort(Comparator.comparingInt(o -> o.var));
@@ -52,18 +57,20 @@ public class VarProcessor {
     for (VarVersionPair pair : listVars) {
       String name = mapVarNames.get(pair);
 
-      Integer index = mapOriginalVarIndices.get(pair.var);
-      if (index != null) {
-        String debugName = mapDebugVarNames.get(index);
+      boolean lvtName = false;
+      VarVersionPair key = mapOriginalVarIndices.get(pair.var);
+      if (key != null) {
+        String debugName = mapDebugVarNames.get(key);
         if (debugName != null && TextUtil.isValidIdentifier(debugName, method.getClassStruct().getBytecodeVersion())) {
           name = debugName;
+          lvtName = true;
         }
       }
 
       Integer counter = mapNames.get(name);
       mapNames.put(name, counter == null ? counter = 0 : ++counter);
 
-      if (counter > 0) {
+      if (counter > 0 && !lvtName) {
         name += String.valueOf(counter);
       }
 
@@ -76,7 +83,7 @@ public class VarProcessor {
       return null;
     }
 
-    return varVersions.getMapOriginalVarIndices().get(index);
+    return varVersions.getMapOriginalVarIndices().get(index).var;
   }
 
   public void refreshVarNames(VarNamesCollector vc) {
@@ -95,7 +102,9 @@ public class VarProcessor {
   }
 
   public void setVarType(VarVersionPair pair, VarType type) {
-    varVersions.setVarType(pair, type);
+    if (varVersions != null) {
+      varVersions.setVarType(pair, type);
+    }
   }
 
   public String getVarName(VarVersionPair pair) {
@@ -125,4 +134,68 @@ public class VarProcessor {
   public Set<VarVersionPair> getExternalVars() {
     return externalVars;
   }
+
+  public List<LocalVariable> getCandidates(int origindex) {
+    if (!hasLVT())
+        return null;
+    return method.getLocalVariableAttr().matchingVars(origindex).collect(Collectors.toList());
+  }
+
+  public void findLVT(VarExprent exprent, int start) {
+    if (!hasLVT())
+      return;
+
+    LocalVariable lvt = method.getLocalVariableAttr().getVariables()
+      .filter(v -> v.getVersion().var == exprent.getIndex() && v.getStart() == start).findFirst().orElse(null);
+
+    if (lvt != null) {
+      exprent.setLVT(lvt);
+    }
+  }
+
+  public void copyVarInfo(VarVersionPair from, VarVersionPair to) {
+    setVarName(to, getVarName(from));
+    setVarFinal(to, getVarFinal(from));
+    setVarType(to, getVarType(from));
+    varVersions.getMapOriginalVarIndices().put(to.var, varVersions.getMapOriginalVarIndices().get(from.var));
+  }
+
+  public boolean hasLVT() {
+    return method.getLocalVariableAttr() != null;
+  }
+  
+
+  public Map<Integer, LocalVariable> getLocalVariables(Statement stat) {
+    if (!hasLVT() || stat == null)
+      return new HashMap<>();
+
+    final StartEndPair sep = stat.getStartEndRange(); 
+    final Set<Integer> blacklist = new HashSet<>();
+    Map<Integer, LocalVariable> ret = method.getLocalVariableAttr().getVariables().filter(lv -> lv.getEnd() > sep.start && lv.getStart() <= sep.end)
+      .collect(Collectors.toMap(lv -> lv.getVersion().var, lv -> lv,
+        (lv1, lv2) -> 
+        {
+          //System.out.println("DUPLICATE INDEX FOR SCOPE: (" +sep +") " + lv1.toString() + " " + lv2.toString());
+          blacklist.add(lv1.getVersion().var);
+          return lv1;
+        }
+      ));
+
+    for (Integer b : blacklist)
+      ret.remove(b);
+
+    return ret;
+  }
+
+  public VarVersionsProcessor getVarVersions() {
+    return varVersions;
+  }
+
+  public void setVarLVT(VarVersionPair var, LocalVariable lvt) {
+    mapVarLVTs.put(var, lvt);
+  }
+
+  public LocalVariable getVarLVT(VarVersionPair var) {
+    return mapVarLVTs.get(var);
+  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
index 6339f9a..a2f25f0 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
@@ -96,7 +96,12 @@ public class VarTypeProcessor {
 
       for (Exprent expr : lst) {
         if (expr.type == Exprent.EXPRENT_VAR) {
-          ((VarExprent)expr).setVarType(VarType.VARTYPE_UNKNOWN);
+          VarExprent ve = (VarExprent)expr;
+          if (ve.getLVT() != null) {
+            ve.setVarType(ve.getLVT().getVarType());
+          } else {
+            ve.setVarType(VarType.VARTYPE_UNKNOWN);
+          }
         }
         else if (expr.type == Exprent.EXPRENT_CONST) {
           ConstExprent constExpr = (ConstExprent)expr;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
index eca0d0f..47e7e0c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
@@ -22,7 +22,7 @@ import java.util.Map.Entry;
 
 public class VarVersionsProcessor {
   private final StructMethod method;
-  private Map<Integer, Integer> mapOriginalVarIndices = Collections.emptyMap();
+  private Map<Integer, VarVersionPair> mapOriginalVarIndices = Collections.emptyMap();
   private final VarTypeProcessor typeProcessor;
 
   public VarVersionsProcessor(StructMethod mt, MethodDescriptor md) {
@@ -43,7 +43,7 @@ public class VarVersionsProcessor {
 
     typeProcessor.calculateVarTypes(root, graph);
 
-    simpleMerge(typeProcessor, graph, method);
+    //simpleMerge(typeProcessor, graph, method);
 
     // FIXME: advanced merging
 
@@ -215,7 +215,8 @@ public class VarVersionsProcessor {
     CounterContainer counters = DecompilerContext.getCounterContainer();
 
     final Map<VarVersionPair, Integer> mapVarPaar = new HashMap<>();
-    Map<Integer, Integer> mapOriginalVarIndices = new HashMap<>();
+    Map<Integer, VarVersionPair> mapOriginalVarIndices = new HashMap<>();
+    mapOriginalVarIndices.putAll(this.mapOriginalVarIndices);
 
     // map var-version pairs on new var indexes
     List<VarVersionPair> vvps = new ArrayList<>(mapExprentMinTypes.keySet());
@@ -236,7 +237,7 @@ public class VarVersionsProcessor {
         }
 
         mapVarPaar.put(pair, newIndex);
-        mapOriginalVarIndices.put(newIndex, pair.var);
+        mapOriginalVarIndices.put(newIndex, pair);
       }
     }
 
@@ -266,11 +267,11 @@ public class VarVersionsProcessor {
     });
 
     if (previousVersionsProcessor != null) {
-      Map<Integer, Integer> oldIndices = previousVersionsProcessor.getMapOriginalVarIndices();
+      Map<Integer, VarVersionPair> oldIndices = previousVersionsProcessor.getMapOriginalVarIndices();
       this.mapOriginalVarIndices = new HashMap<>(mapOriginalVarIndices.size());
-      for (Entry<Integer, Integer> entry : mapOriginalVarIndices.entrySet()) {
-        Integer value = entry.getValue();
-        Integer oldValue = oldIndices.get(value);
+      for (Entry<Integer, VarVersionPair> entry : mapOriginalVarIndices.entrySet()) {
+        VarVersionPair value = entry.getValue();
+        VarVersionPair oldValue = oldIndices.get(value.var);
         value = oldValue != null ? oldValue : value;
         this.mapOriginalVarIndices.put(entry.getKey(), value);
       }
@@ -297,7 +298,11 @@ public class VarVersionsProcessor {
     typeProcessor.getMapFinalVars().put(pair, finalType);
   }
 
-  public Map<Integer, Integer> getMapOriginalVarIndices() {
+  public Map<Integer, VarVersionPair> getMapOriginalVarIndices() {
     return mapOriginalVarIndices;
   }
+
+  public VarTypeProcessor getTypeProcessor() {
+    return typeProcessor;
+  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMember.java b/src/org/jetbrains/java/decompiler/struct/StructMember.java
index 7a3afc4..825fb8b 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMember.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMember.java
@@ -12,6 +12,8 @@ import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
+import static org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute.*;
+
 public class StructMember {
 
   protected int accessFlags;
@@ -49,12 +51,12 @@ public class StructMember {
       StructGeneralAttribute attribute = readAttribute(in, pool, name);
 
       if (attribute != null) {
-        if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) && attributes.containsKey(name)) {
+        if (ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) && attributes.containsKey(name)) {
           // merge all variable tables
           StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.get(name);
           table.add((StructLocalVariableTableAttribute)attribute);
         }
-        else if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name) && attributes.containsKey(name)) {
+        else if (ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name) && attributes.containsKey(name)) {
           // merge all variable tables
           StructLocalVariableTypeTableAttribute table = (StructLocalVariableTypeTableAttribute)attributes.get(name);
           table.add((StructLocalVariableTypeTableAttribute)attribute);
@@ -65,6 +67,8 @@ public class StructMember {
       }
     }
 
+    if (attributes.containsKey(ATTRIBUTE_LOCAL_VARIABLE_TABLE) && attributes.containsKey(ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE))
+      ((StructLocalVariableTableAttribute)attributes.get(ATTRIBUTE_LOCAL_VARIABLE_TABLE)).mergeSignatures((StructLocalVariableTypeTableAttribute)attributes.get(ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE));
     return attributes;
   }
 
@@ -79,4 +83,4 @@ public class StructMember {
     }
     return attribute;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
index 1c80ef0..0e5a747 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
@@ -1,12 +1,17 @@
 // Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct.attr;
 
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.BitSet;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
@@ -24,12 +29,14 @@ import java.util.stream.Stream;
 */
 public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
   private List<LocalVariable> localVariables = Collections.emptyList();
+  private Map<Integer, Integer> indexVersion = new HashMap<>();
 
   @Override
   public void initContent(DataInputFullStream data, ConstantPool pool) throws IOException {
     int len = data.readUnsignedShort();
     if (len > 0) {
       localVariables = new ArrayList<>(len);
+      indexVersion = new HashMap<>();
 
       for (int i = 0; i < len; i++) {
         int start_pc = data.readUnsignedShort();
@@ -43,6 +50,8 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
                                              pool.getPrimitiveConstant(descriptorIndex).getString(),
                                              varIndex));
       }
+      Collections.sort(localVariables);
+      versionVariables(localVariables);
     }
     else {
       localVariables = Collections.emptyList();
@@ -51,6 +60,7 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
   public void add(StructLocalVariableTableAttribute attr) {
     localVariables.addAll(attr.localVariables);
+    versionVariables(localVariables);
   }
 
   public String getName(int index, int visibleOffset) {
@@ -61,25 +71,58 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
     return matchingVars(index, visibleOffset).map(v -> v.descriptor).findFirst().orElse(null);
   }
 
-  private Stream<LocalVariable> matchingVars(int index, int visibleOffset) {
+  public Stream<LocalVariable> matchingVars(int index, int visibleOffset) {
     return localVariables.stream()
       .filter(v -> v.index == index && (visibleOffset >= v.start_pc && visibleOffset < v.start_pc + v.length));
   }
 
+  public Stream<LocalVariable> matchingVars(int index) {
+    return localVariables.stream().filter(v -> v.index == index);
+  }
+
+  public Stream<LocalVariable> matchingVars(Statement stat) {
+    BitSet values = new BitSet();
+    stat.getOffset(values);
+    return getRange(values.nextSetBit(0), values.length() - 1);
+  }
+
+  public Stream<LocalVariable> getRange(int start, int end) {
+    return localVariables.stream().filter(v -> v.getStart() >= start && v.getEnd() <= end);
+  }
+
   public boolean containsName(String name) {
     return localVariables.stream().anyMatch(v -> v.name == name);
   }
 
-  public Map<Integer, String> getMapParamNames() {
-    return localVariables.stream().filter(v -> v.start_pc == 0).collect(Collectors.toMap(v -> v.index, v -> v.name, (n1, n2) -> n2));
+  public Map<VarVersionPair, String> getMapNames() {
+    return localVariables.stream().collect(Collectors.toMap(v -> v.version, v -> v.name, (n1, n2) -> n2));
   }
 
-  private static class LocalVariable {
+  public Stream<LocalVariable> getVariables() {
+    return localVariables.stream();
+  }
+  
+  private void versionVariables(List<LocalVariable> vars) {
+    for (LocalVariable var : vars) {
+      Integer version = indexVersion.get(var.index);
+      version = version == null ? 1 : version++;
+      indexVersion.put(var.index, version);
+      var.version = new VarVersionPair(var.index, version.intValue());
+    }
+  }
+
+  public void mergeSignatures(StructLocalVariableTypeTableAttribute lvtt) {
+      lvtt.backingAttribute.localVariables.stream().forEach(type -> localVariables.stream().filter(t -> t.compareTo(type) == 0).findFirst().ifPresent(lv -> lv.signature = type.descriptor));
+  }
+
+  public static class LocalVariable implements Comparable<LocalVariable> {
     final int start_pc;
     final int length;
     final String name;
     final String descriptor;
     final int index;
+    private String signature;
+    private VarVersionPair version;
 
     private LocalVariable(int start_pc, int length, String name, String descriptor, int index) {
       this.start_pc = start_pc;
@@ -87,6 +130,53 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
       this.name = name;
       this.descriptor = descriptor;
       this.index = index;
+      this.version = new VarVersionPair(index, 0);
+    }
+
+    @Override
+    public int compareTo(LocalVariable o) {
+      if (this.index != o.index) return this.index - o.index;
+      if (this.start_pc != o.start_pc) return this.start_pc - o.start_pc;
+      return this.length - o.length;
+    }
+    
+    public String getName() {
+      return name;
+    }
+
+    public String getDescriptor() {
+      return descriptor;
+    }
+
+    public String getSignature() {
+      return signature;
+    }
+    
+    public int getStart() {
+      return start_pc;
+    }
+
+    public int getEnd() {
+      return start_pc + length;
+    }
+
+    public VarVersionPair getVersion() {
+      return version;
+    }
+
+    public VarType getVarType() {
+      return new VarType(descriptor);
+    }
+    
+    @Override
+    public String toString() {
+      return "\'("+index+","+start_pc+'-'+getEnd()+")"+descriptor+(signature!=null ? "<"+signature+"> ":" ")+name+"\'";
+    }
+
+    public LocalVariable rename(String newName) {
+      LocalVariable ret = new LocalVariable(start_pc, length, newName, descriptor, index);
+      ret.signature = signature;
+      return ret;
     }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java
index 829c78e..cfdda0f 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java
@@ -17,7 +17,7 @@ import java.io.IOException;
 */
 public class StructLocalVariableTypeTableAttribute extends StructGeneralAttribute {
   // store signature instead of descriptor
-  private final StructLocalVariableTableAttribute backingAttribute = new StructLocalVariableTableAttribute();
+  final StructLocalVariableTableAttribute backingAttribute = new StructLocalVariableTableAttribute();
 
   @Override
   public void initContent(DataInputFullStream data, ConstantPool pool) throws IOException {
diff --git a/src/org/jetbrains/java/decompiler/util/DebugPrinter.java b/src/org/jetbrains/java/decompiler/util/DebugPrinter.java
new file mode 100644
index 0000000..71d69ef
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/DebugPrinter.java
@@ -0,0 +1,94 @@
+package org.jetbrains.java.decompiler.util;
+
+import java.util.BitSet;
+import java.util.List;
+
+import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
+
+//Debug printer useful for visualizing objects, no real functional value
+public class DebugPrinter {
+  public static void printMethod(Statement root, String name, VarProcessor varProc) {
+    System.out.println(name + "{");
+    if (root == null || root.getSequentialObjects() == null) {
+      System.out.println("}");
+      return;
+    }
+
+    for (Object obj : root.getSequentialObjects()) {
+      if (obj instanceof Statement) {
+        printStatement((Statement)obj, "  ", varProc);
+      } else if (obj == null) {
+        System.out.println("  null");
+      } else {
+        System.out.println("  " + obj.getClass().getSimpleName());
+      }
+    }
+
+    if (root.type == Statement.TYPE_ROOT) {
+      printStatement(((RootStatement)root).getDummyExit(), "  ", varProc);
+    }
+    System.out.println("}");
+  }
+
+  public static void printStatement(Statement statement, String indent, VarProcessor varProc) {
+    BitSet values = new BitSet();
+    statement.getOffset(values);
+    int start = values.nextSetBit(0);
+    int end = values.length()-1;
+
+    System.out.println(indent + '{' + statement.getClass().getSimpleName() + "}:" + statement.id + "  (" + start + ", " + end + ")");
+
+    for (StatEdge edge : statement.getAllSuccessorEdges()) {
+      System.out.println(indent + " Dest: " + edge.getDestination());
+    }
+
+    if (statement.getExprents() != null) {
+      for(Exprent exp : statement.getExprents()) {
+        System.out.println(printExprent(indent + "  ", exp, varProc));
+      }
+    }
+
+    indent += "  ";
+    for (Object obj : statement.getSequentialObjects()) {
+      if (obj == null) {
+        System.out.println(indent + " Null");
+      } else if (obj instanceof Statement) {
+        printStatement((Statement)obj, indent, varProc);
+      } else if (obj instanceof Exprent) {
+          System.out.println(printExprent(indent, (Exprent) obj, varProc));
+      } else {
+        System.out.println(indent + obj.getClass().getSimpleName());
+      }
+    }
+  }
+
+  private static String printExprent(String indent, Exprent exp, VarProcessor varProc) {
+      StringBuffer sb = new StringBuffer();
+      sb.append(indent);
+      BitSet values = new BitSet();
+      exp.getBytecodeRange(values);
+      sb.append("(").append(values.nextSetBit(0)).append(", ").append(values.length()-1).append(") ");
+      sb.append(exp.getClass().getSimpleName());
+      sb.append(" ").append(exp.id).append(" ");
+      if (exp instanceof VarExprent) {
+        VarExprent varExprent = (VarExprent)exp;
+        int currindex = varExprent.getIndex();
+        int origindex = varProc == null ? -2 : varProc.getVarOriginalIndex(currindex);
+        sb.append("[").append(currindex).append(":").append(origindex).append(", ").append(varExprent.isStack()).append("]");
+        if (varProc != null) {
+          sb.append(varProc.getCandidates(origindex));
+        }
+      } else if (exp instanceof AssignmentExprent) {
+        AssignmentExprent assignmentExprent = (AssignmentExprent)exp;
+        sb.append("{").append(printExprent(" ",assignmentExprent.getLeft(),varProc)).append(" =").append(printExprent(" ",assignmentExprent.getRight(),varProc)).append("}");
+      } else if (exp instanceof IfExprent) {
+        sb.append(' ').append(exp.toJava(0, new BytecodeMappingTracer()));
+      }
+      return sb.toString();
+  }
+}
diff --git a/test/org/jetbrains/java/decompiler/LVTTest.java b/test/org/jetbrains/java/decompiler/LVTTest.java
new file mode 100644
index 0000000..71d689d
--- /dev/null
+++ b/test/org/jetbrains/java/decompiler/LVTTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2000-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler;
+
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.junit.Test;
+
+import java.io.IOException;
+
+public class LVTTest extends SingleClassesTestBase {
+  @Override
+  protected String[] getDecompilerOptions() {
+    return new String[] {
+      IFernflowerPreferences.DECOMPILE_INNER,"1",
+      IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES,"1",
+      IFernflowerPreferences.ASCII_STRING_CHARACTERS,"1",
+      IFernflowerPreferences.LOG_LEVEL, "TRACE",
+      IFernflowerPreferences.REMOVE_SYNTHETIC, "1",
+      IFernflowerPreferences.REMOVE_BRIDGE, "1",
+      IFernflowerPreferences.USE_DEBUG_VAR_NAMES, "1"
+    };
+  }
+
+  @Override
+  public void setUp() throws IOException {
+      super.setUp();
+      fixture.setCleanup(false);
+  }
+
+  @Test public void testLVT() { doTest("pkg/TestLVT"); }
+  @Test public void testScoping() { doTest("pkg/TestLVTScoping"); }
+  @Test public void testLVTComplex() { doTest("pkg/TestLVTComplex"); }
+  @Test public void testVarType() { doTest("pkg/TestVarType"); }
+  @Test public void testLoopMerging() { doTest("pkg/TestLoopMerging"); }
+}
diff --git a/test/org/jetbrains/java/decompiler/SingleClassesTest.java b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
index de78855..4513dab 100644
--- a/test/org/jetbrains/java/decompiler/SingleClassesTest.java
+++ b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
@@ -15,6 +15,7 @@ public class SingleClassesTest extends SingleClassesTestBase {
     };
   }
 
+  @Test public void testEnhancedForLoops() { doTest("pkg/TestEnhancedForLoops"); }
   @Test public void testPrimitiveNarrowing() { doTest("pkg/TestPrimitiveNarrowing"); }
   @Test public void testClassFields() { doTest("pkg/TestClassFields"); }
   @Test public void testInterfaceFields() { doTest("pkg/TestInterfaceFields"); }
diff --git a/testData/bulk/pkg/res/Loader.java b/testData/bulk/pkg/res/Loader.java
index cdb1db5..5e4c220 100644
--- a/testData/bulk/pkg/res/Loader.java
+++ b/testData/bulk/pkg/res/Loader.java
@@ -17,8 +17,8 @@ public class Loader {
             stream.read(bytes);
             stream.close();
             return new String(bytes, "UTF-8");
-         } catch (Exception var5) {
-            throw new RuntimeException("Resource load failed", var5);
+         } catch (Exception e) {
+            throw new RuntimeException("Resource load failed", e);
          }
       }
    }
diff --git a/testData/classes/pkg/TestEnhancedForLoops.class b/testData/classes/pkg/TestEnhancedForLoops.class
new file mode 100644
index 0000000000000000000000000000000000000000..bdb8a786b1c9e708620e423c250c63925ac12493
GIT binary patch
literal 1725
zcmaKsUsD@Z7{;HIY;w}D{3(#oR-uT61_;E)ib^mx)S}Tqs!%koH%nMy+pwG2Y@BlM
zm+(?=dgF~=q(kd;y!Os7;f&wF=}g7v>?S~<EyJ8W=RNOv-{13`1AqSa<QahL_%@DV
zWY6JUT#w^DEJ(Z`hlXqqX7E7|X7QmK7A10Odr9J>IC_wm_&APUWMjCYz6CWbtKp`^
zCla>=qDz)-d3k|wYI;*ZyXkD30{tb+HrJYaTc*2VY}FVUEIC!9wrRMQTDOCmw`(;7
zE|uyJb}}1g!@Fhg8g|v(UUA%#<J22Df!KGBTX0=tpS^6qqJSt0$Y8<ap?h5Ru6suH
z!KzXBOG}Ik=sa2UJkvEi$K~mU=UVoTLb-2zZ)9qQy^~q@V{9XXU6vaNwws<+%ap8!
z$IWCn{C>S7;L54orL(2;If)gCPX&fg^4zhvoQFP+uxOiQdu%=VnsP<kGj~ikmnTnr
z-D$d2bH!55UVNEx^Gc$Q1d<Y;=_ulJi7#}NuqrU*%lGy9#ww9I)=<`Q8(-@93hQ*?
zv`6ajhQRsbc$-Ma9q{HyjyD2Rmz!2?+obVw)2KDg#c>^9;~O<pblk-~feWv?_OABj
zt@~!x6X-j}R>Zu=<3RD~mQQl;H#~EXFVkr<I}vzmIhosh1|AtrV~<`2ZghvqTvtgo
zn^%)6s)rr3j#?yB(<kn!)0(B^uF+UCAF>($81C|@?JtHq`TmOw<S;vtI{R3HPPXSe
z=9l5qjvDp4X>SY6z3jx9B5mK<;Z35yW;^CN!A<dLb|D7Q9NxkZ|7)lp4dg|V;|Nz7
zeg(ggna2>nauUJ?j!{3Dz(vmWAOV-~23JHmI{XWZMHwp$M1PN0!dkhaMaq>(v|NeG
zaz)0<mDoVET$)`?Kg)*~w1hVLGe*)0ZGIv08$yXl3*jF$@#yd$)i~@oP9nnj2*$X|
zvi%~zH`rK#j58;T7)H6PvI=daF}#h-+!a)*&V~*#g^0wE!~}l@_5I5Nf@vMuKT)T~
z<hiHNDvuE<%^n~su$n%A6!?*p2Z#y$fpcploogZf=<shvshyx4Bg<t>u=6xKr#b6T
zPC()cCdtbdZORzeQ@Bcu6r;-2ATr(N?nCGW`Xy#0W}nk!!HOMR8s+0IzXCVi!R={5
z&y)BmdMT@Ku)l?Y(H73PFz9Re>$HYRQcRKTD)QtiP)SF_BxiGUT4`85(y)m6QyNr6
Sy&~m(w}xwszQbq;*Zv0xhj@4Z

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLVT.class b/testData/classes/pkg/TestLVT.class
new file mode 100644
index 0000000000000000000000000000000000000000..0477af41e18fb06d5d18e3f5b693bfbb59f4ee06
GIT binary patch
literal 1780
zcmaJ?-%}e^6#j0w*<U0OLJ~?vidrRUOCxP5HXzWJB8dU2!D#(em#_odh9r}0oZ;PP
zpLo&fgQH{ntmC9pJL4bF|Hjvj)B4?PFhQ8!$(}uX?m6H2alh<7d-3OA0ItBc@H&<Z
zTsCmUz@&kcj_VdQEa|vm!N8IdH<egc;+7ICCO*Kbg)DMGqNrsV_|QOJ$C`zhAGEF<
zHnhbjKdAMiw)nTN=(w%pBLQvRt+?KTKwmOd6p%No+m66s-mN(6&AlzBzG-ijX^G~m
zCA(a->#ln47^S!CHUz@?+WnpMrql59#mzZl?m6CWbz5LEnZIX$Yp2V0WhY(m>TYFc
z?zlze)f%O0&AFuV9E%Xp{asriSgE=VmJ{*anx0!u=iP?Ktg=zF_XLE?E2~;)1GPQY
z>>3?JP9R`UE5Ss5Mn3uA(*#c(?Qy?$*yq_EER}7(r^t=1drrxlTVR5j9yg{u!RzF>
zaKW=n_ZiV1tB#LZls`fiCDgUdYfHc?RGamZv*M}~33Ud3QS}+ZIL-(RcYD5GuiN{o
zSb>rMkMu^<EpI#Z5DM5-;u9r`A$*F@bleHyb9|xW%MiZ8*8+w={PP@@d8o3cp>C>G
zyRpma706u`^o>A&4<mS5-2(h^9WnXD;EC9^no}WdrcR(us%Lb5K&J`LeJq)M)%Fp%
z&T+lU-|(u3CB>4*9htDFpTd5_b4a_sYLk<W`&GKt^lg&eBaCD3F~C2Uqh=m*O*xe-
zj611g{w>Cmx#I<N8<)xDR1t4rjIR&1`XCe!C@1)o=3Vd}JogylH!1<Tf^QXNH1H;6
z$alb7ILjv!Z{r<WCIIma5*BR_qk*+(-+JFw8J7|3XRJhJCKwH7w5QPSJcgdppTeMG
zUTDD@4Jx5g#AOTpqk0RW7Qz|hcMOagEew7q#iN%`%vqU`F+>g?ARCQlwCJ!xi4i59
zF*<Nlhe!&<N)Rrg5ZZ92f-?!1kd{3wAHDoTbtl{1tzd|{#ZmOL(-0yE^Hn&2QyAoa
z1h=@qMtcFnxXYaq;@Cj~HH_eZUJq#h6{p+N`JQnxT*D-i2y$-*DQX&VF5n!_LnoR+
zJxOUIhbdfS6{SvuMqEEaC%TGA)9;`YVWNl)M!d@iP8rigQR^WtQ6r!53ocU&FyBx7
zL?mgM;eMihiVE#2^ZU57#C)&4CttwSag9Im9NB*mkk7GBw9J2`XtERaxi~YhI+)`e
zCsU;sMq)U%8pG+Xp-Y!>rUCgCAhRT4!lcI#M-b<T#z`DSqX`yA$PSGH^q#{!(@MOC
O_o*pfF3=-@#eV^Z#ekpy

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLVTComplex$1.class b/testData/classes/pkg/TestLVTComplex$1.class
new file mode 100644
index 0000000000000000000000000000000000000000..bac7e3274fc9774ff69494f7bffe31bae9dec986
GIT binary patch
literal 665
zcmZ`%O>fgc5PfUA*(A8sq+e+Yv;`9q4n#=YKnM}FqQYqoiNc|$jk8KN-FhS2Df}bO
zfP@f2{Q>+a#H>L=RYCIX%$uEg<9)k7etx?I@Dz`#*ur)N9Q6uCI~F!Lb}hKgaff4%
z;UFBmQ+Yh=iAA_Ln}$P~<<V%^HRlU0--oZvn87(cW+*?8wMta}g28RIM+{!qOeDiv
zq!M|uJRi$+D8`yHwaCOmk3_00{*zoC<RU(!DFvp#V5knvGL7YtvQ6t(2S1*R3qj<E
zNvut#l4(!oGc)1X=Q!|jAEA#5sy-f|>Ej_<3=P}T(IT04PRw8#&yJMTlfyJMsgE|A
z3>$R7&eb{L69)e{No3m9BFkjP5d7uokLNPZ=|tBX8Mdw`f6L_-qLnU$URu80R{J#i
zckMIM_BCl+|NlNW=|m+$7phaK6ZM0Ay3#UTF$?Ne1RD{)0iXOTp*dWNfYw*A%kS0C
za6Z}3{Q}SHe}MO<fF*(}1^ftycs8(&71T-FCV3Y(iJ?^R>|l*zhb$oT;l1U!g`Qog
du2$@=Q$OHglh(UrHLB<25tQk<ZQ|a`#xFA~koEuo

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLVTComplex$Bob.class b/testData/classes/pkg/TestLVTComplex$Bob.class
new file mode 100644
index 0000000000000000000000000000000000000000..549a629af942d8ddc3bc26f3f378c0413e0f5685
GIT binary patch
literal 1465
zcmaJ>+fEZv6kVq??U_!8i^UNO^@gZzRVuftrQ8K2Rxv3yQKNAvBMwZbq@5a#kMiP^
zPx=AG=&NF)MkC?bzwj@7689OZv=MC6bI$C&*1oKLrr&>k*#IzrnIL2&Rh&aFM>|Kq
zidGDWWl+IBm7IeDky4<G{k*VT2;w5r3Wii<Fw8N+;JY%zAWf9!8MGP4G0T&-QK^^}
zhJ)Fa<;CQjS#h)Zxye#-#Wo*z6L5$~*;xkOogdHMoXRmo?(7W>JTmO62-g{l{|6>d
zmKIEgmaOHN*Q>>Ovpi?a+hpM$fA#^xnOJtocw{7P!&yw`+_L2?4#oFQ9L|;shMhOc
zmIzdfCObxvf`<Q%#1P0>j^&ah2X;v`6VEfq?n8?@3FfRt$8f7<iX_E^L&+5E8ksFH
zumb%^(59Sg6qc_UD_(XQ5ksOb^ORF9X7*}egk)B8rE0lgPFq5Vw#G^H2rV=m5TkF`
zFp4pbajJdynQ4e(Lc=k1Y1oJT8g#K7M1*5f!zD~nbK{kT2OQHHF5?PA^N!Y{P6mI$
zE;&@k{#d-OhuQfhv*1##;eQh|4Av{@U96!x?%x?UrlMf2JC@v&ifdAOsZ@0t^liFT
zO5ULPyA;7RibQDh2#sdCJ1YWYJH)Fm<WJuG*g1M9TIp?)#v(!%fOb*_XzdWnl1D~R
z$OMKCdg`KGeAIQYkMM0mdPh%mw`mP{zJ9_-aj1qLfX}n4VL9;`{!PdN?`yyxCX2R>
z!Vw(x{4^&*iHyCF=nL?~>F6f}-h1x)bUSp8<DztQdzceYa1tlB3t{)E5smDxzCykg
z=F%r99}x5&RM~q7`M;4%TBqB6OI}AP_W|rPw5y4Yj5HkWT*KW&wC_4u(sD%JNcp8y
zKo98tHH=1NJ<ylt!lgu%jZ{!dsk*8M*KjzZ=xSd&bT-1@AheFAaPvpBtg7to){oTy
zt(&VpT3?H<Bu|tcgy=j#t@q<BQgp4)<2Ej!O8;9=k;XGRKPTG@^1Z|eME6IDTSYTY
zQTHK2ClR9)C+-cz=_DaRsC(eQkm8US+oBnB@5FK1+kq`g8EUZY_&T@X--Y0ZR3rZ+
Zzf{xx4Am`0+=DjSRnlKZAHriDzX8G5C+h$J

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLVTComplex.class b/testData/classes/pkg/TestLVTComplex.class
new file mode 100644
index 0000000000000000000000000000000000000000..b9b82623317a50adbbcf6d09eab00e5969c3d091
GIT binary patch
literal 1736
zcmZ`)T~ixX7=BK^&StZO5C{bdQkvBA5s0*yDs8a^t;L293sT#9vxF6vhAfjT3O8Q$
zFL<GM_ChYa=*R_(TDfz^@sD_+GdiP=j8nnqYyuL&OwQT&^Stl-JZF<1_P^c*FogGX
z#4!}c%gAcDqT?03Dlx1hh#|FIjo=!tt8FBVM!XhA0ylJSH#LlE7}M~&hBqW`NxUg>
zTfi7E7Om1)!7P`pvc$N6f7F>52wk&_wmU+#yJt=yFy<^+0`)n&XicuI%v+^dbG|@J
zJm=)i!kk&Mm0mRl+$Fm#(3D$!w3wN-%5H9McFb8>Em-SUdDe<)7X`!y7wh>pE^%8|
z+e51H+_L$BnJJjX#mv<FvXyt4;xp+!?wN5*c5#s&v96K_1rn9KHP<d=Zk9^sM$Rs)
z)aKd-H&zdu>^Uvr+R5r8Jfv>MHS>=q%vEndi6k+Xc*_Ivj(|Sntd;WCEn6YdSUd25
z8ppsHv`FL(Okk1-nB|4{C8i8a<85Ym6W4Zb;4WrZ!oV!vF))XF2Hr)|z$oq;cz}l-
z`?f+aH$@OkE|L~MiMK%Pzj%_ElW{3R*nEoFyA1Jv8yt77lIc37nsX~`)S5QRuC>DJ
z<E*(y<k(JTn!LG;x6BpdTA94oEFf1^P=R+O(S3}MD(C7tYW7hZ&E3a|JZz6=%O$fs
zX|1z5ukZtcUi6fv!}!`8)|Hz1(021n<TynbQne(eJQ!L|xzEa@iaDhPyJ!}?V&mvS
z17B11@j)o=xwlfw@G1BV_U=G@>ABmuhbl&#rEFB?c63k+<AuXy-)B5542Ub*GyP6)
zu5b6cf25=R38H-+1KGf1zt}wZ?U=dQGjG8c_iv-({^=V8@9!X#>)VE$NPh)Q;1kqQ
z2n$SZ9{gHk&sXg+{h2--XblVpTZ6mVkUuLEG7)-$SZgpL2eR5@$;!W+^tV*~M=hwh
z9}l(7gHN}hZy~Y`W8e#piheF1mjXzkqT~xIypH{EBBI17MdtAPIl}S!iA{v!v5Eh;
zgc!rTG}9E^0q@|C&`DWR(+IhaG$Q<E)iI1ZzFtw>Lp|TH7#y;=Mjk&#6Q1%nbcfGx
z$>w*Y<a_e@GqZn3JN_g|2j~(S&Wi|=B8rq~z(vu9ZgCF1B8jv}qhDl@5m^j+G~Z?I
zG*>6iv5%*ex+rO^H;wa1(&q4`??eiI(E&d$;6(xw5SMY0Ua-$U(2X7lp59dT_R_Ad
zPsP_qDNV~VnhrQ%K%$>tL3H;}zmJfo?BUGcFeC;fGJhfdT!m#g3p6iWnI&F2p4zyN
rNHz8B9`vLxqrT{K_#_4+?C=sR`f!;&fynvzAH+{gBYF*JzR~s%!6|RH

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLVTScoping.class b/testData/classes/pkg/TestLVTScoping.class
new file mode 100644
index 0000000000000000000000000000000000000000..b13a2da2070ddc93780406d9b74262fec5610576
GIT binary patch
literal 1024
zcma)4U2hUW6g>l5mZeZWODkY&>ldIFZPgcyNn>I{N?Q{M34L4WNVkPu0!yR+#<xD}
z0~#Ov0sbaqJhKpxRHK<>=H8h*=bU?HzW@CC4Ztp*>+lIA`WKy2T@Kx9qh4z}ear6X
z&;(-V=A~Kcns%pj+&Y(SS0M1hvMu+efInYo2xzaIQyGFEMi@&72t=!vEssXMmK@a0
zR#y_d>a@*n!yH&DpKfaInKcwhRj)IbNz#+<nR6OK3<(`^f%sfV#dc*!4#G$xC7@rL
z-H|+gE0E4t3e{_6WrdLrV-4#9LCba<s@_vy2_nOwx!(*T$KYtcX<!4lbZjnkUVA@u
zWiN~^Y_rN4(S+3rk>!-$42W5C2h!}3>JIMdxGRwKbSxf+aUXdK?yDPJn;`k$<Pw6W
zmzAZ$RG!T{nH~v5YOdM7I5hj7hdLfD%JdLOF!6487VRlrPZT}(wET(3aUu|^Iio>a
zzP8jOB^O_RN71umHq37VXpH#0oONa;u7c}Q@iT%S8Tb(5td3RbGUxE5fNO-AftA_i
zA*)qgPSd_1I>zb;7>OGPR|q7s2cK}WIL2*->Gv=*ya$plBS;JbaqgywnkBB{NfT{_
zwFMNJrC2qI9xyZDi~oR6$3uoY{}vGWyMP$U;v`CN=D*{}lKTGy7!v`dnSggw2e#)9
zM71(o&y4Z-3V)Qb;TgY9$_zWtQb3M>dV|>}pJ{6*CBnJ__Sk*Ki<B$M3k|+CgT6my
H?8CEPwhyta

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestLoopMerging.class b/testData/classes/pkg/TestLoopMerging.class
new file mode 100644
index 0000000000000000000000000000000000000000..022bd6098959508759665aea103c6d360ba4fb0a
GIT binary patch
literal 1481
zcmb_cOHUI~6#njXrbEl{DpYwCC{Lk0s({3(ffy4KlA;nSiD5N`p$?R`DT9fL8x3*e
zS~qG;+`z(^Xh0Jsgv6ac!-Y%N#2E3rV{NOjKx5i_&$;KEd(U^ibJ~yJ-|Yez!LT3Y
z==8ylF1dB9A4UN6@|N7Bb}0<_a0)$s^dh38Pe;FiFu5kU5(3_fcG`Bv1Ux;xvx3($
z3zk4t%uZWZ)>aZ$E^a1Lv;<<Ac{4R@=4^S+8&&6~y($olWtWrDxV7rUGMVg@l}p;`
z<OM$F(B!_%WEC@xIlnw*X7hJ7=^PSp<uJi4a!m>-CSO$MCS9;CdH;xje<rh*o3|!x
ziKgz4WP?lQEz>|1stp*ZFi?pK9Rmgi5!G?pz!@-A?GZ2qs^#5i%1kGtR})LtJQ0_e
zW^S)K)(VTrtkDsSxxscOdM#(Cof#)*nJcWc_6W0po|QqVG@0m`=$%CyTU5@zDG(AR
zH6ejgYSajxdks%fN+GS0w-B$WC<t)(x<(IbsT)57P=_E-0w-{iyS#h{9@jS>*@D95
zSq!L;o}eajgL*()+=gf4;B(RGefYTGOcb3j`IN^^TS*D%Xhs>%bDE0j$Mfmy>DL$)
z3Ndp-0m-vGlIckKwhKiG=tR=^8f7y58~7w9#b8!t<KWXVqj;l;t%bNG8C7JlfwG(0
zS@Jke86)~4*69+gUZ`4F4HInRFR;Q#uwK4(-?QV7^-cBfj(JAapxXQ#f&QR6II68{
zVqFy*2VaWR{WY)0<KedoBb*tqy(*E`^V3AxM%-i6<`BXX`{GdEMXOtFn03^1HPNQY
zdh&IvxW~vA)-1c#1n&Xq(sZ=y2=gmAZ~LeVg<M+N3be%YwCo+C<wb#(|3yf=WH879
zpZ%BFEg7jzw_$OKuQ)P8tQ%-2p&g{6lT>u!90%t*|0WmEgEapsA0UEFp0^qE9s?!B
lJ}nTtS0Hw$gxF5_4-@+hm4eLHhC*Lq?7Khqc4AP_@dGu?5$FH_

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestVarType.class b/testData/classes/pkg/TestVarType.class
new file mode 100644
index 0000000000000000000000000000000000000000..28473768df1fca50e12184e05997281a94d1519e
GIT binary patch
literal 375
zcmZ9Hy-veG5QJy_3&tUifl$){1#akwXpoQ)0Scn@wmF3h#*Q2ZDScju3W<V>iszw5
zjGYJ&C*AGM?(DaBA78I;0FJTc!9?Jq<02F|J)P_7RABBO3<cI%ai;|BzRuP4>@iX0
zAWkx7!hVs)*)T43tyf8_y4O=dr$2cZMFTahSRc$M>O|ls^GfNw5{Tx$5O}x6tW4Fp
zu5rO1_t7|hihWqHIrtxm&bk_9aXyM}lCerF?7`p<>Scg0hRxHViWr5_K74^ZH)WTn
z(<DQz@$N4TScgX?*!XF_qB59k1(&^r*zXI7eEvd0&H=VLcZa|(LAwpGyKGtkO=5kt
Lh!SklZ=n4R+Z#Vr

literal 0
HcmV?d00001

diff --git a/testData/results/TestAmbiguousCallWithDebugInfo.dec b/testData/results/TestAmbiguousCallWithDebugInfo.dec
index e873e7e..18beb9a 100644
--- a/testData/results/TestAmbiguousCallWithDebugInfo.dec
+++ b/testData/results/TestAmbiguousCallWithDebugInfo.dec
@@ -12,7 +12,7 @@ class TestAmbiguousCall {
       this.m1((RuntimeException)iae, "RE");// 9
       this.m1(iae, "IAE");// 10
       RuntimeException re = new IllegalArgumentException();// 12
-      this.m1((RuntimeException)re, "RE");// 13
+      this.m1(re, "RE");// 13
       this.m1((IllegalArgumentException)re, "IAE");// 14
    }// 15
 }
diff --git a/testData/results/TestEnhancedForLoops.dec b/testData/results/TestEnhancedForLoops.dec
new file mode 100644
index 0000000..a83751c
--- /dev/null
+++ b/testData/results/TestEnhancedForLoops.dec
@@ -0,0 +1,127 @@
+package pkg;
+
+import java.util.ArrayList;
+
+public class TestEnhancedForLoops {
+   public void forArray() {
+      int[] numbers = new int[]{1, 2, 3, 4, 5, 6};// 23
+
+      for(int number : numbers) {// 24
+         System.out.println(number);// 25
+      }
+// 27
+   }
+
+   public void forItterator() {// 31
+      for(String string : new ArrayList()) {// 32
+         System.out.println(string);
+      }// 34
+
+   }
+// 38
+   public void forItteratorUnboxing() {// 39
+      for(int i : new ArrayList()) {
+         System.out.println("Value: " + i);// 41
+      }
+
+   }
+}
+
+class 'pkg/TestEnhancedForLoops' {
+   method 'forArray ()V' {
+      6      6
+      a      6
+      e      6
+      12      6
+      16      6
+      1a      6
+      1b      6
+      1d      6
+      1e      8
+      1f      8
+      22      8
+      24      8
+      25      8
+      30      8
+      31      8
+      32      9
+      33      9
+      34      9
+      35      9
+      36      9
+      37      9
+      38      9
+      39      9
+      3a      8
+      3b      8
+      3c      8
+      40      11
+   }
+
+   method 'forItterator ()V' {
+      18      14
+      19      14
+      1a      14
+      1b      14
+      1c      14
+      1d      14
+      1e      14
+      1f      14
+      20      14
+      21      14
+      22      15
+      23      15
+      24      15
+      25      15
+      26      15
+      27      15
+      28      15
+      2c      17
+   }
+
+   method 'forItteratorUnboxing ()V' {
+      18      20
+      19      20
+      1a      20
+      1b      20
+      1c      20
+      1d      20
+      1e      20
+      1f      20
+      20      20
+      21      20
+      22      20
+      23      20
+      24      20
+      25      21
+      26      21
+      27      21
+      2f      21
+      30      21
+      34      21
+      38      21
+      39      21
+      3a      21
+      3b      21
+      3c      21
+      3d      21
+      41      23
+   }
+}
+
+Lines mapping:
+23 <-> 7
+24 <-> 9
+25 <-> 10
+27 <-> 12
+31 <-> 15
+32 <-> 16
+34 <-> 18
+38 <-> 21
+39 <-> 22
+41 <-> 24
+Not mapped:
+30
+33
+37
+40
diff --git a/testData/results/TestKotlinConstructorKt.dec b/testData/results/TestKotlinConstructorKt.dec
index 0e94145..e57e91a 100644
--- a/testData/results/TestKotlinConstructorKt.dec
+++ b/testData/results/TestKotlinConstructorKt.dec
@@ -1,6 +1,5 @@
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Iterator;
 import java.util.List;
 import kotlin.Metadata;
 import kotlin.TypeCastException;
@@ -17,10 +16,8 @@ public final class TestKotlinConstructorKt {
    private static final List<Mapping> foo(Collection<String> list) {
       Iterable $receiver$iv = (Iterable)list;// 2
       Collection destination$iv$iv = (Collection)(new ArrayList(CollectionsKt.collectionSizeOrDefault($receiver$iv, 10)));
-      Iterator var4 = $receiver$iv.iterator();// 10 11
 
-      while(var4.hasNext()) {
-         Object item$iv$iv = var4.next();
+      for(Object item$iv$iv : $receiver$iv) {// 10 11
          String it = (String)item$iv$iv;
          Mapping var10000 = new Mapping;
          if (it == null) {// 3
@@ -31,100 +28,81 @@ public final class TestKotlinConstructorKt {
          Mapping var11 = var10000;
          destination$iv$iv.add(var11);// 12
       }
-
-      return CollectionsKt.toList((Iterable)((List)destination$iv$iv));// 4 13
+// 4 13
+      return CollectionsKt.toList((Iterable)((List)destination$iv$iv));
    }
 }
 
 class 'TestKotlinConstructorKt' {
    method 'foo (Ljava/util/Collection;)Ljava/util/List;' {
-      0      17
-      1      17
-      2      17
-      3      17
-      4      17
+      0      16
+      1      16
+      2      16
+      3      16
+      4      16
       6      19
-      c      18
-      d      18
-      e      18
-      f      18
-      10      18
-      11      18
-      15      18
-      16      18
-      17      18
-      18      18
-      1b      19
-      1c      19
-      1d      19
-      1e      19
-      1f      19
+      c      17
+      d      17
+      e      17
+      f      17
+      10      17
+      11      17
+      15      17
+      16      17
+      17      17
+      18      17
       20      19
       21      19
-      22      21
-      23      21
-      24      21
-      25      21
-      26      21
-      27      21
-      28      21
-      2c      22
-      2d      22
-      2e      22
-      2f      22
-      30      22
-      31      22
-      32      22
-      33      22
-      34      22
-      35      31
-      36      23
-      37      23
-      38      23
-      39      23
-      3a      23
-      3b      23
-      3c      23
-      43      25
-      44      25
-      46      25
-      4d      26
-      4e      26
-      52      26
-      53      29
-      54      29
-      55      29
-      56      29
-      57      29
-      58      29
-      59      30
-      5a      30
-      5d      31
-      5e      31
-      5f      31
-      60      31
-      61      31
-      62      31
-      63      31
-      68      34
-      69      34
-      6a      34
-      6b      34
-      6c      34
-      6d      34
-      6e      34
-      6f      34
-      70      34
-      71      34
-      72      34
+      33      19
+      34      19
+      35      28
+      36      20
+      37      20
+      38      20
+      39      20
+      3a      20
+      3b      20
+      3c      20
+      43      22
+      44      22
+      46      22
+      4d      23
+      4e      23
+      52      23
+      53      26
+      54      26
+      55      26
+      56      26
+      57      26
+      58      26
+      59      27
+      5a      27
+      5d      28
+      5e      28
+      5f      28
+      60      28
+      61      28
+      62      28
+      63      28
+      68      30
+      69      30
+      6a      30
+      6b      30
+      6c      30
+      6d      30
+      6e      30
+      6f      30
+      70      30
+      71      30
+      72      30
    }
 }
 
 Lines mapping:
-2 <-> 18
-3 <-> 26
-4 <-> 35
+2 <-> 17
+3 <-> 23
+4 <-> 31
 10 <-> 20
 11 <-> 20
-12 <-> 32
-13 <-> 35
+12 <-> 29
+13 <-> 31
diff --git a/testData/results/TestLVT.dec b/testData/results/TestLVT.dec
new file mode 100644
index 0000000..a78cf6e
--- /dev/null
+++ b/testData/results/TestLVT.dec
@@ -0,0 +1,39 @@
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestLVT {
+   public static void method(String a1, String a2) {
+      String scope1 = "scope1";
+      String scope1a = "scope1a";
+
+      for(int i = 0; i < 10; ++i) {
+         String scope2 = "scope2";
+         String scope2a = "scope2a";
+         List<Object> noise = new ArrayList();
+         String spam = scope1 + scope2 + scope2a + i + noise;
+         System.out.println(spam);
+      }
+
+      for(long i = 0L; i < 10L; ++i) {
+         String scope2 = "scope2+1";
+         String scope2a = "scope2+1a";
+         Map<Object, Object> noise = new HashMap();
+         String spam = scope1a + scope2 + scope2a + i + noise;
+         System.out.println(spam);
+      }
+
+   }
+
+   public void methoda() {
+      double a = 0.0D;
+      double b = 1.0D;
+      System.out.println(a + b);
+      a = 0.1D;
+      b = 1.1D;
+      System.out.println(a + b);
+   }
+}
diff --git a/testData/results/TestLVTComplex.dec b/testData/results/TestLVTComplex.dec
new file mode 100644
index 0000000..7d492ca
--- /dev/null
+++ b/testData/results/TestLVTComplex.dec
@@ -0,0 +1,84 @@
+package pkg;
+
+import java.util.ArrayList;
+
+public class TestLVTComplex {
+   public static void main() {
+      int[] x = new int[5];
+
+      for(int y : x) {
+         ;
+      }
+
+      for(int y : x) {
+         System.out.println("asdf");
+      }
+
+      ArrayList<Object> x1 = new ArrayList();
+
+      for(Object y : x1) {
+         ;
+      }
+
+      for(Object y : x1) {
+         int[] x2 = new int[10];
+
+         for(int y2 : x2) {
+            ;
+
+         }
+
+         for(int y2 : x2) {
+            System.out.println("asdf");
+
+         }
+
+         System.out.println("asdf");
+      }
+
+      switch(Bob.HI) {
+      case HI:
+         System.out.println("HI");
+         break;
+      case LO:
+         System.out.println("LO");
+      }
+
+      if (TestLVTComplex.Bob.HI == TestLVTComplex.Bob.HI) {
+         String a = "a";
+      } else {
+         String b = "b";
+      }
+
+      String a2;
+      if (TestLVTComplex.Bob.HI == TestLVTComplex.Bob.HI) {
+         a2 = "a";
+      } else {
+         a2 = "b";
+      }
+
+      if (TestLVTComplex.Bob.HI == TestLVTComplex.Bob.HI) {
+         a2 = "a";
+      }
+
+      System.out.println(a2);
+   }
+
+   private static enum Bob {
+      HI,
+      LO;
+
+      static {
+         for(TestLVTComplex.Bob b : values()) {
+            for(TestLVTComplex.Bob c : values()) {
+               for(TestLVTComplex.Bob d : values()) {
+                  if (b == c) {
+                     System.out.println("Asdf");
+                  }
+               }
+            }
+         }
+
+      }
+   }
+}
diff --git a/testData/results/TestLVTScoping.dec b/testData/results/TestLVTScoping.dec
new file mode 100644
index 0000000..74941fb
--- /dev/null
+++ b/testData/results/TestLVTScoping.dec
@@ -0,0 +1,35 @@
+package pkg;
+
+public class TestLVTScoping {
+   public static void method() {
+      String a;
+      if (1 == Integer.valueOf(1).intValue()) {
+         a = "YAY";
+      } else {
+         a = "NAY";
+      }
+
+      System.out.println(a);
+   }
+
+   public static void method2() {
+      if (1 == Integer.valueOf(1).intValue()) {
+         String a = "YAY";
+      } else {
+         String a = "NAY";
+         System.out.println(a);
+      }
+
+   }
+
+   public static void method3() {
+      if (1 == Integer.valueOf(1).intValue()) {
+         boolean a = true;
+         System.out.println(a);
+      } else {
+         String a = "NAY";
+         System.out.println(a);
+      }
+
+   }
+}
diff --git a/testData/results/TestLocalsNames.dec b/testData/results/TestLocalsNames.dec
index 59563dd..1041a54 100644
--- a/testData/results/TestLocalsNames.dec
+++ b/testData/results/TestLocalsNames.dec
@@ -7,21 +7,18 @@ public class TestLocalsNames {
       if (file.isDirectory()) {// 22
          long start = System.currentTimeMillis();// 23
          File[] files = file.listFiles();// 25
-         File[] var5 = files;
-         int var6 = files.length;
 
-         for(int var7 = 0; var7 < var6; ++var7) {// 26
-            File s = var5[var7];
+         for(File s : files) {// 26
             File dest = new File(s.getAbsolutePath() + ".tmp");// 27
 
             assert s.renameTo(dest) : "unable to rename " + s + " to " + dest;// 28
          }
-
-         long elapsed = System.currentTimeMillis() - start;// 31
-         System.out.println("took " + elapsed + "ms (" + elapsed / (long)files.length + "ms per dir)");// 32
+// 31
+         long elapsed = System.currentTimeMillis() - start;// 32
+         System.out.println("took " + elapsed + "ms (" + elapsed / (long)files.length + "ms per dir)");
       }
-
-   }// 34
+// 34
+   }
 }
 
 class 'pkg/TestLocalsNames' {
@@ -41,91 +38,79 @@ class 'pkg/TestLocalsNames' {
       e      8
       f      8
       10      8
-      11      9
-      12      9
-      13      9
-      14      9
-      17      10
+      11      10
+      12      10
+      13      10
+      14      10
       18      10
       19      10
-      1a      12
-      1b      12
-      1c      12
-      1d      12
-      1e      12
-      1f      12
-      20      12
-      21      12
-      24      13
-      25      13
-      26      13
-      27      13
-      28      13
-      29      13
-      2a      13
-      36      14
-      37      14
-      38      14
-      39      14
-      3a      14
-      3e      14
-      3f      14
-      43      14
-      44      14
-      45      14
-      49      14
-      4a      14
-      51      16
-      52      16
-      53      16
-      54      16
-      55      16
-      56      16
-      57      16
-      66      16
-      67      16
-      6b      16
-      6c      16
-      70      16
-      71      16
-      75      16
-      76      16
-      7a      16
-      7b      16
-      7c      16
-      81      12
-      82      12
-      83      12
-      87      19
-      88      19
-      89      19
-      8a      19
-      8b      19
-      8c      19
-      8d      19
-      8e      20
-      8f      20
-      90      20
-      98      20
-      99      20
-      9d      20
-      9e      20
-      a2      20
-      a3      20
-      a7      20
-      a8      20
-      a9      20
-      aa      20
-      ab      20
-      ac      20
-      ad      20
-      b1      20
-      b2      20
-      b6      20
-      b7      20
-      b8      20
-      b9      20
-      bc      23
+      1b      10
+      1c      10
+      29      10
+      2a      10
+      36      11
+      37      11
+      38      11
+      39      11
+      3a      11
+      3e      11
+      3f      11
+      43      11
+      44      11
+      45      11
+      49      11
+      4a      11
+      51      13
+      52      13
+      53      13
+      54      13
+      55      13
+      56      13
+      57      13
+      66      13
+      67      13
+      6b      13
+      6c      13
+      70      13
+      71      13
+      75      13
+      76      13
+      7a      13
+      7b      13
+      7c      13
+      81      10
+      82      10
+      83      10
+      87      15
+      88      15
+      89      15
+      8a      15
+      8b      15
+      8c      15
+      8d      15
+      8e      16
+      8f      16
+      90      16
+      98      16
+      99      16
+      9d      16
+      9e      16
+      a2      16
+      a3      16
+      a7      16
+      a8      16
+      a9      16
+      aa      16
+      ab      16
+      ac      16
+      ad      16
+      b1      16
+      b2      16
+      b6      16
+      b7      16
+      b8      16
+      b9      16
+      bc      19
    }
 }
 
@@ -133,9 +118,9 @@ Lines mapping:
 22 <-> 7
 23 <-> 8
 25 <-> 9
-26 <-> 13
-27 <-> 15
-28 <-> 17
-31 <-> 20
-32 <-> 21
-34 <-> 24
+26 <-> 11
+27 <-> 12
+28 <-> 14
+31 <-> 16
+32 <-> 17
+34 <-> 20
diff --git a/testData/results/TestLoopMerging.dec b/testData/results/TestLoopMerging.dec
new file mode 100644
index 0000000..703203a
--- /dev/null
+++ b/testData/results/TestLoopMerging.dec
@@ -0,0 +1,82 @@
+package pkg;
+
+public class TestLoopMerging {
+   public float a;
+   public float b;
+
+   public float test() {
+      while(this.a - this.b < -180.0F) {
+         this.b -= 360.0F;
+      }
+
+      while(this.a - this.b >= 180.0F) {
+         this.b += 360.0F;
+      }
+
+      return this.a;
+   }
+
+   public float test2() {
+      for(this.a = 0.0F; this.a < 10.0F; ++this.a) {
+         System.out.println(this.a);
+      }
+
+      for(this.a = 0.0F; this.a < 10.0F; ++this.a) {
+         System.out.println(this.a);
+      }
+
+      return this.a;
+   }
+
+   public float test3() {
+      int[] as = new int[0];
+
+      for(int f : as) {
+         ++f;
+      }
+
+      while(this.a - this.b < -180.0F) {
+         this.b -= 360.0F;
+      }
+
+      while(this.a - this.b >= 180.0F) {
+         this.b += 360.0F;
+      }
+
+      for(this.a = 0.0F; this.a < 10.0F; ++this.a) {
+         System.out.println(this.a);
+      }
+
+      return this.a;
+   }
+
+   public float test4() {
+      int[] as = new int[0];
+
+      for(int f : as) {
+         ++f;
+
+         while(this.a - this.b < -180.0F) {
+            this.b -= 360.0F;
+         }
+
+         while(this.a - this.b >= 180.0F) {
+            this.b += 360.0F;
+         }
+
+         for(this.a = 0.0F; this.a < 10.0F; ++this.a) {
+            System.out.println(this.a);
+
+            while(this.a - this.b < -180.0F) {
+               this.b -= 360.0F;
+            }
+
+            while(this.a - this.b >= 180.0F) {
+               this.b += 360.0F;
+            }
+         }
+      }
+
+      return this.a;
+   }
+}
diff --git a/testData/results/TestTryCatchFinally.dec b/testData/results/TestTryCatchFinally.dec
index b3e3ac2..33da522 100644
--- a/testData/results/TestTryCatchFinally.dec
+++ b/testData/results/TestTryCatchFinally.dec
@@ -4,10 +4,10 @@ public class TestTryCatchFinally {
    public void test1(String var1) {
       try {
          System.out.println("sout1");// 24
-      } catch (Exception var9) {
+      } catch (Exception var2) {
          try {
             System.out.println("sout2");// 27
-         } catch (Exception var8) {// 28
+         } catch (Exception var3) {// 28
             ;
          }
       } finally {
diff --git a/testData/results/TestVarType.dec b/testData/results/TestVarType.dec
new file mode 100644
index 0000000..56fb422
--- /dev/null
+++ b/testData/results/TestVarType.dec
@@ -0,0 +1,9 @@
+package pkg;
+
+public class TestVarType {
+   public void byteint() {
+      int i = 75;
+      i = i + 5;
+      i = i + 500;
+   }
+}
diff --git a/testData/src/pkg/TestEnhancedForLoops.java b/testData/src/pkg/TestEnhancedForLoops.java
new file mode 100644
index 0000000..d808218
--- /dev/null
+++ b/testData/src/pkg/TestEnhancedForLoops.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pkg;
+
+import java.util.List;
+import java.util.ArrayList;
+
+public class TestEnhancedForLoops {
+  public void forArray() {
+    int[] numbers = {1, 2, 3, 4, 5, 6};
+    for (int number : numbers) {
+      System.out.println(number);
+    }
+  }
+
+  public void forItterator() {
+    List<String> strings = new ArrayList<>();
+    for (String string : strings) {
+      System.out.println(string);
+    }
+  }
+
+  public void forItteratorUnboxing() {
+    List<Integer> ints = new ArrayList<>();
+    for (int i : ints) {
+      System.out.println("Value: " + i);
+    }
+  }
+}
diff --git a/testData/src/pkg/TestLVT.java b/testData/src/pkg/TestLVT.java
new file mode 100644
index 0000000..b9eed0d
--- /dev/null
+++ b/testData/src/pkg/TestLVT.java
@@ -0,0 +1,36 @@
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestLVT {
+  public static void method(String a1, String a2) {
+    String scope1 = "scope1";
+    String scope1a = "scope1a";
+    for (int i=0; i<10; i++) {
+      String scope2 = "scope2";
+      String scope2a = "scope2a";
+      List<Object> noise = new ArrayList<Object>();
+      String spam = scope1 + scope2 + scope2a + i + noise;
+      System.out.println(spam);
+    }
+    for (long i=0; i<10; i++) {
+      String scope2 = "scope2+1";
+      String scope2a = "scope2+1a";
+      Map<Object,Object> noise = new HashMap<Object,Object>();
+      String spam = scope1a + scope2 + scope2a + i + noise;
+      System.out.println(spam);
+    }
+  }
+
+  public void methoda() {
+    double a = 0D;
+    double b = 1D;
+    System.out.println(a+b);
+    a = 0.1D;
+    b = 1.1D;
+    System.out.println(a+b);
+  }
+}
diff --git a/testData/src/pkg/TestLVTComplex.java b/testData/src/pkg/TestLVTComplex.java
new file mode 100644
index 0000000..548b9fd
--- /dev/null
+++ b/testData/src/pkg/TestLVTComplex.java
@@ -0,0 +1,64 @@
+package pkg;
+
+import java.util.ArrayList;
+
+public class TestLVTComplex {
+    public static void main() {
+        int[] x = new int[5];
+        for (int y : x)
+            ;
+        for (int y : x) {
+            System.out.println("asdf");
+        }
+        ArrayList<Object> x1 = new ArrayList<Object>();
+        for (Object y : x1)
+            ;
+        for (Object y : x1) {
+            int[] x2 = new int[10];
+            for (int y2 : x2)
+                ;
+            for (int y2 : x2) {
+                System.out.println("asdf");
+            }
+            System.out.println("asdf");
+        }
+        switch (Bob.HI) {
+        case HI:
+            System.out.println("HI");
+            break;
+        case LO:
+            System.out.println("LO");
+            break;
+        }
+        if (Bob.HI == Bob.HI) {
+            String a = "a";
+        } else {
+            String b = "b";
+        }
+        String a2;
+        if (Bob.HI == Bob.HI) {
+            a2 = "a";
+        } else {
+            a2 = "b";
+        }
+        if (Bob.HI == Bob.HI) {
+            a2 = "a";
+        }
+        System.out.println(a2);
+
+    }
+
+    private static enum Bob {
+        HI, LO;
+        static {
+            for (Bob b : Bob.values()) {
+                for (Bob c : values()) {
+                    for (Bob d : values()) {
+                        if (b == c)
+                            System.out.println("Asdf");
+                    }
+                }
+            }
+        };
+    }
+}
diff --git a/testData/src/pkg/TestLVTScoping.java b/testData/src/pkg/TestLVTScoping.java
new file mode 100644
index 0000000..ab57832
--- /dev/null
+++ b/testData/src/pkg/TestLVTScoping.java
@@ -0,0 +1,34 @@
+package pkg;
+
+
+public class TestLVTScoping {
+    public static void method() {
+        String a;
+        if (1 == Integer.valueOf(1)) {
+            a = "YAY";
+        } else {
+            a = "NAY";
+        }
+        System.out.println(a);
+    }
+    public static void method2() {
+        String a;
+        if (1 == Integer.valueOf(1)) {
+            a = "YAY";
+        } else {
+            a = "NAY";
+            System.out.println(a);
+        }
+    }
+    public static void method3() {
+        if (1 == Integer.valueOf(1)) {
+            boolean a;
+            a = true;
+            System.out.println(a);
+        } else {
+            String a;
+            a = "NAY";
+            System.out.println(a);
+        }
+    }
+}
diff --git a/testData/src/pkg/TestLoopMerging.java b/testData/src/pkg/TestLoopMerging.java
new file mode 100644
index 0000000..1643c81
--- /dev/null
+++ b/testData/src/pkg/TestLoopMerging.java
@@ -0,0 +1,47 @@
+package pkg;
+
+public class TestLoopMerging {
+  public float a;
+  public float b;
+  public float test() {
+    while(a - b < -180) b -= 360;
+    while(a - b >= 180) b += 360;
+    return a;
+  }
+  public float test2() {
+     for (a = 0; a < 10; a++) {
+      System.out.println(a);
+    }
+    for (a = 0; a < 10; a++) {
+      System.out.println(a);
+    }
+    return a;
+  }
+
+  public float test3() {
+    int[] as = new int[0];
+    for (int f: as) {
+      f++;
+    }
+    while(this.a - this.b < -180) this.b -= 360;
+    while(this.a - this.b >= 180) this.b += 360;
+    for (a = 0; a < 10; a++) {
+      System.out.println(a);
+    }
+    return this.a;
+  }
+  public float test4() {
+    int[] as = new int[0];
+    for (int f: as) {
+      f++;
+      while(this.a - this.b < -180) this.b -= 360;
+      while(this.a - this.b >= 180) this.b += 360;
+      for (a = 0; a < 10; a++) {
+        System.out.println(a);
+        while(this.a - this.b < -180) this.b -= 360;
+        while(this.a - this.b >= 180) this.b += 360;
+      }
+    }
+    return this.a;
+  }
+}
diff --git a/testData/src/pkg/TestVarType.java b/testData/src/pkg/TestVarType.java
new file mode 100644
index 0000000..15e2171
--- /dev/null
+++ b/testData/src/pkg/TestVarType.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pkg;
+
+public class TestVarType {
+  public void byteint() {
+    int i = 75;
+    i+=5;
+    i+=500;
+  }
+}
-- 
2.17.0

