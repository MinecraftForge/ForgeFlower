From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Sun, 13 Sep 2015 17:49:00 -0700
Subject: [PATCH] Fixup NPE from PPMM helper, and expand PPMM test to include
 more edge cases.


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
index d93bad6bd760a6de8e546411b1f2798b4bbd03ad..f39946d1c839333a69c91521f6714b183028567d 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
@@ -34,6 +34,7 @@ import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 public class PPandMMHelper {
 
@@ -183,13 +184,23 @@ public class PPandMMHelper {
 
     VarExprent v1 = (VarExprent)e1;
     VarExprent v2 = (VarExprent)e2;
-    return varProc.getRemapped(v1.getIndex()) == varProc.getRemapped(v2.getIndex())
-            && InterpreterUtil.equalObjects(v1.getVarType(), v2.getVarType());
+    return varProc.getRemapped(v1.getIndex()) == varProc.getRemapped(v2.getIndex());
+    //Probably should up this to checking if the types are in the same family, Like byte == int == long
+            //&& InterpreterUtil.equalObjects(v1.getVarType(), v2.getVarType());
   }
 
 
   private void updateVersions(DirectGraph graph) {
     if (remaps.isEmpty()) return;
+
+    for (Entry<VarVersionPair, VarVersionPair> remap : remaps.entrySet()) {
+      VarVersionPair target = remap.getValue();
+      while (remaps.containsKey(target)) {
+        target = remaps.get(target);
+      }
+      remaps.put(remap.getKey(), target);
+    }
+
     graph.iterateExprents(new DirectGraph.ExprentIterator() {
       @Override
       public int processExprent(Exprent exprent) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
index 312f6c8a51e96e8f1a8dc27b509716022e22cc39..3398924fabb57daddb0f6b51daafdd266cc371b6 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
@@ -416,6 +416,11 @@ public class ConstExprent extends Exprent {
     measureBytecode(values);
   }
 
+  @Override
+  public String toString() {
+    return "const(" + toJava(0, new BytecodeMappingTracer()) + ")";
+  }
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
diff --git a/testData/classes/pkg/TestPPMM.class b/testData/classes/pkg/TestPPMM.class
index e493a99dbb742f1f20c3cb134d7366db47c5d4b4..38580c978dbdec1baf1fe2a0d4c7bbb11e2d2a11 100644
GIT binary patch
literal 936
zcmb`F&rZTX5XQfuMYI+{RQ!X67%%9Bg9i^1FCGjDL=J@ef)$Gt8flCVzzccOc<=#y
zDDhiMiqR%=pxMs1JJb2?bTS{GZ|?w3v2Ve|js*j|DeR?C5G+;Pfg4;1jM8ySU|tSy
z96_!&?5KWAJ-DjfcbeKT7Tmcb!CK9~@0Od+C}=e5^>b#rzAq5Px5|_6yV~b@w4TSk
z$@ndW0WFMZVTd9Dx23ASTApkqv1DTld4c`&5<#}79#y%o2Ho;?yXSNQ9P%$r{uN+B
zbRunvrz5IRlP52bXKn<`w07vk3P0Dr)hOYNrv!Z&qcRqW)+{w2hNr0sqzOwiiLF=!
zBohyrjAgp!sU*7y$a)01n)ak<R0{0KD-yBtyRu@`ql2hNxi~191wvzG9_U6KlqF8W
oO8?3{(9Jj~nPH_d@;}tl!^~dl!7P5y9cOQr77nFgoAboy3oV9k<p2Nx

literal 371
zcmYjL%}&BV7@V&yEtFyr6A#|JsRx^Qm3T2RF)2zS!Sl9maIv;cDL#QO<jKT?58y)?
zr+{d7cfS38X1@9Q{`drNhCL6KASj<^(L^um@pv@y;0XG2^`fFo<+JEEnd`I`xI>eh
z`a)nI9Zv<$W$~bW*ysdk!4-tD$@R_hInmWbC7Bis;v!YqR8^+QH$|s@Gz-B_{D0@U
zz$#0DD86ffe^)H4R9~4!ruXaYv@wN4&;rc^7Jpn#^q57A!q_@_NBeEn_K8g!By@?v
zdVsOVj3&0^duA4Ep*?&R+1@{y1CCOgLoU%no2QEoCH$52{+hm#wzwcfpQ3_Y@+=H~
E0NOq`X8-^I

diff --git a/testData/results/TestPPMM.dec b/testData/results/TestPPMM.dec
new file mode 100644
index 0000000000000000000000000000000000000000..ba3a5fc1b4a29798078399358a7e560326aa2044
--- /dev/null
+++ b/testData/results/TestPPMM.dec
@@ -0,0 +1,70 @@
+package pkg;
+
+public class TestPPMM {
+   public void ipp() {
+      int a = 0;
+      ++a;
+      ++a;
+      ++a;
+      ++a;
+   }
+
+   public void ppi() {
+      int a = 0;
+      ++a;
+      ++a;
+      ++a;
+      ++a;
+   }
+
+   public void imm() {
+      int a = 0;
+      --a;
+      --a;
+      --a;
+      --a;
+   }
+
+   public void mmi() {
+      int a = 0;
+      --a;
+      --a;
+      --a;
+      --a;
+   }
+
+   public void ippf() {
+      int a = 0;
+      t(a++);
+      t(a++);
+      t(a++);
+      t(a++);
+   }
+
+   public void ppif() {
+      int a = 0;
+      t(++a);
+      t(++a);
+      t(++a);
+      t(++a);
+   }
+
+   public void immf() {
+      int a = 0;
+      t(a--);
+      t(a--);
+      t(a--);
+      t(a--);
+   }
+
+   public void mmif() {
+      int a = 0;
+      t(--a);
+      t(--a);
+      t(--a);
+      t(--a);
+   }
+
+   private static void t(int x) {
+   }
+}
diff --git a/testData/src/pkg/TestPPMM.java b/testData/src/pkg/TestPPMM.java
index 02eecf4b565584b5644ad5898565593494aad285..21c7f2eab8296554f3fdb5d23efba4832e42e745 100644
--- a/testData/src/pkg/TestPPMM.java
+++ b/testData/src/pkg/TestPPMM.java
@@ -1,11 +1,66 @@
 package pkg;
 
 public class TestPPMM {
-    public void pp() {
-        int a = 0;
-        a++;
-        a++;
-        a++;
-        a++;
-    }
+   // Bytecode wise ipp and ppi are identical when not using the intermediate value. 
+   // We keep these seperate tests just to see the bytecode.
+   public void ipp() {
+      int a = 0;
+      a++;
+      a++;
+      a++;
+      a++;
+   }
+   public void ppi() {
+      int a = 0;
+      ++a;
+      ++a;
+      ++a;
+      ++a;
+   }
+   public void imm() {
+      int a = 0;
+      a--;
+      a--;
+      a--;
+      a--;
+   }
+   public void mmi() {
+      int a = 0;
+      --a;
+      --a;
+      --a;
+      --a;
+   }
+   
+   // These versions actually use the intermediate value
+   public void ippf() {
+      int a = 0;
+      t(a++);
+      t(a++);
+      t(a++);
+      t(a++);
+   }
+   public void ppif() {
+      int a = 0;
+      t(++a);
+      t(++a);
+      t(++a);
+      t(++a);
+   }
+   public void immf() {
+      int a = 0;
+      t(a--);
+      t(a--);
+      t(a--);
+      t(a--);
+   }
+   public void mmif() {
+      int a = 0;
+      t(--a);
+      t(--a);
+      t(--a);
+      t(--a);
+   }
+   private static void t(int x){
+   }
 }
\ No newline at end of file
