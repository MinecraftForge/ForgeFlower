From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Tue, 25 Aug 2015 12:03:36 -0700
Subject: [PATCH] Make Loop Enhancement retain all bytecode data. And support
 iterator/listIterator.


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
index d994c26c65b45e18e54622865e3bc454b22feb0a..3172b5e6754fc9e2d5570f1d7110dc452b77b510 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
@@ -118,6 +118,10 @@ public class MergeHelper {
           if (ifedge.getType() == StatEdge.TYPE_BREAK) {
             ifexpr.negateIf();
           }
+          if (stat.getConditionExprent() != null) {
+            ifexpr.getCondition().addBytecodeOffsets(stat.getConditionExprent().bytecode);
+          }
+          ifexpr.getCondition().addBytecodeOffsets(lastif.getHeadexprent().bytecode);
           stat.setConditionExprent(ifexpr.getCondition());
           lastif.getFirst().removeSuccessor(ifedge);
           lastif.removeSuccessor(elseedge);
@@ -175,6 +179,10 @@ public class MergeHelper {
               // negate condition (while header)
               IfExprent ifexpr = (IfExprent)firstif.getHeadexprent().copy();
               ifexpr.negateIf();
+              if (stat.getConditionExprent() != null) {
+                ifexpr.getCondition().addBytecodeOffsets(stat.getConditionExprent().bytecode);
+              }
+              ifexpr.getCondition().addBytecodeOffsets(firstif.getHeadexprent().bytecode);
               stat.setConditionExprent(ifexpr.getCondition());
 
               // remove edges
@@ -213,7 +221,12 @@ public class MergeHelper {
               stat.setLooptype(DoStatement.LOOP_WHILE);
 
               // no need to negate the while condition
-              stat.setConditionExprent(((IfExprent)firstif.getHeadexprent().copy()).getCondition());
+              IfExprent ifexpr = (IfExprent)firstif.getHeadexprent().copy();
+              if (stat.getConditionExprent() != null) {
+                ifexpr.getCondition().addBytecodeOffsets(stat.getConditionExprent().bytecode);
+              }
+              ifexpr.getCondition().addBytecodeOffsets(firstif.getHeadexprent().bytecode);
+              stat.setConditionExprent(ifexpr.getCondition());
 
               // remove edges
               StatEdge ifedge = firstif.getIfEdge();
@@ -369,9 +382,17 @@ public class MergeHelper {
 
       stat.setLooptype(DoStatement.LOOP_FOR);
       if (hasinit) {
-        stat.setInitExprent(preData.getExprents().remove(preData.getExprents().size() - 1));
+        Exprent exp = preData.getExprents().remove(preData.getExprents().size() - 1);
+        if (stat.getInitExprent() != null) {
+          exp.addBytecodeOffsets(stat.getInitExprent().bytecode);
+        }
+        stat.setInitExprent(exp);
       }
-      stat.setIncExprent(lastData.getExprents().remove(lastData.getExprents().size() - 1));
+      Exprent exp = lastData.getExprents().remove(lastData.getExprents().size() - 1);
+      if (stat.getIncExprent() != null) {
+        exp.addBytecodeOffsets(stat.getIncExprent().bytecode);
+      }
+      stat.setIncExprent(exp);
     }
 
     cleanEmptyStatements(stat, lastData);
@@ -425,20 +446,29 @@ public class MergeHelper {
 
     if (stat.getLooptype() == DoStatement.LOOP_WHILE && initDoExprent != null && firstDoExprent != null) {
       if (initDoExprent.type == Exprent.EXPRENT_ASSIGNMENT &&
-          isInvoke(((AssignmentExprent)initDoExprent).getRight(), null, "iterator", "()Ljava/util/Iterator;")) {
+          isIteratorCall(((AssignmentExprent)initDoExprent).getRight())) {
 
-        if (!isInvoke(drillNots(stat.getConditionExprent()), "java/util/Iterator", "hasNext", "()Z") ||
+        if (!isHasNextCall(drillNots(stat.getConditionExprent())) ||
             firstDoExprent.type != Exprent.EXPRENT_ASSIGNMENT) {
           return false;
         }
 
         AssignmentExprent ass = (AssignmentExprent)firstDoExprent;
-        if (!isInvoke(ass.getRight(), "java/util/Iterator", "next", "()Ljava/lang/Object;") ||
-            ass.getLeft().type != Exprent.EXPRENT_VAR) {
+        if (!isNextCall(ass.getRight()) || ass.getLeft().type != Exprent.EXPRENT_VAR) {
           return false;
         }
 
         InvocationExprent holder = (InvocationExprent)((AssignmentExprent)initDoExprent).getRight();
+
+        holder.getInstance().addBytecodeOffsets(initDoExprent.bytecode);
+        ass.getLeft().addBytecodeOffsets(firstDoExprent.bytecode);
+        if (stat.getIncExprent() != null) {
+          holder.getInstance().addBytecodeOffsets(stat.getIncExprent().bytecode);
+        }
+        if (stat.getInitExprent() != null) {
+          ass.getLeft().addBytecodeOffsets(stat.getInitExprent().bytecode);
+        }
+
         stat.setLooptype(DoStatement.LOOP_FOREACH);
         stat.setInitExprent(ass.getLeft());
         stat.setIncExprent(holder.getInstance());
@@ -448,24 +478,48 @@ public class MergeHelper {
     }
     else if (stat.getLooptype() == DoStatement.LOOP_FOR) {
       if (isType(stat.getInitExprent(), Exprent.EXPRENT_ASSIGNMENT) &&
-          isInvoke(((AssignmentExprent)stat.getInitExprent()).getRight(), null, "iterator", "()Ljava/util/Iterator;") &&
+          isIteratorCall(((AssignmentExprent)stat.getInitExprent()).getRight()) &&
           isType(stat.getConditionExprent(), Exprent.EXPRENT_FUNCTION)) {
 
-        if (!isInvoke(drillNots(stat.getConditionExprent()), "java/util/Iterator", "hasNext", "()Z") ||
+        Exprent exp = drillNots(stat.getConditionExprent());
+        if (!isHasNextCall(exp) ||
             !isType(stat.getIncExprent(), Exprent.EXPRENT_ASSIGNMENT)) {
           return false;
         }
 
         AssignmentExprent ass = (AssignmentExprent)stat.getIncExprent();
-        if (!isInvoke(ass.getRight(), "java/util/Iterator", "next", "()Ljava/lang/Object;") ||
-            ass.getLeft().type != Exprent.EXPRENT_VAR) {
-          return false;
+        if (!isNextCall(ass.getRight()) || ass.getLeft().type != Exprent.EXPRENT_VAR) {
+
+          if (firstDoExprent == null || !isNextCall(firstDoExprent.getRight()) ||
+              firstDoExprent.getLeft().type != Exprent.EXPRENT_VAR) {
+            return false;
+          }
+
+          //Move the inc exprent back to the end of the body and remove the .next call
+          Statement last = getLastDirectData(stat.getFirst());
+          InvocationExprent holder = (InvocationExprent)getUncast(((AssignmentExprent)stat.getInitExprent()).getRight());
+
+          firstData.getExprents().remove(firstDoExprent);
+          last.getExprents().add(stat.getIncExprent());
+
+          firstDoExprent.getLeft().addBytecodeOffsets(stat.getInitExprent().bytecode);
+          firstDoExprent.getLeft().addBytecodeOffsets(stat.getIncExprent().bytecode);
+          firstDoExprent.getLeft().addBytecodeOffsets(firstDoExprent.bytecode);
+
+          stat.setLooptype(DoStatement.LOOP_FOREACH);
+          stat.setInitExprent(firstDoExprent.getLeft());
+          stat.setIncExprent(holder.getInstance());
         }
+        else {
+          InvocationExprent holder = (InvocationExprent)getUncast(((AssignmentExprent)stat.getInitExprent()).getRight());
 
-        InvocationExprent holder = (InvocationExprent)((AssignmentExprent)stat.getInitExprent()).getRight();
-        stat.setLooptype(DoStatement.LOOP_FOREACH);
-        stat.setInitExprent(ass.getLeft());
-        stat.setIncExprent(holder.getInstance());
+          holder.getInstance().addBytecodeOffsets(stat.getInitExprent().bytecode);
+          ass.getLeft().addBytecodeOffsets(stat.getIncExprent().bytecode);
+
+          stat.setLooptype(DoStatement.LOOP_FOREACH);
+          stat.setInitExprent(ass.getLeft());
+          stat.setIncExprent(holder.getInstance());
+        }
       }
       else if (initDoExprent != null && initDoExprent.getRight().type == Exprent.EXPRENT_FUNCTION) {
         if (firstDoExprent == null ||
@@ -496,23 +550,31 @@ public class MergeHelper {
           return false;
         }
 
+        funcRight.getLstOperands().get(0).addBytecodeOffsets(initDoExprent.bytecode);
+        funcRight.getLstOperands().get(0).addBytecodeOffsets(stat.getIncExprent().bytecode);
+        firstDoExprent.getLeft().addBytecodeOffsets(firstDoExprent.bytecode);
+        firstDoExprent.getLeft().addBytecodeOffsets(stat.getInitExprent().bytecode);
+
         stat.setLooptype(DoStatement.LOOP_FOREACH);
         stat.setInitExprent(firstDoExprent.getLeft());
         stat.setIncExprent(funcRight.getLstOperands().get(0));
         preData.getExprents().remove(initDoExprent);
         firstData.getExprents().remove(firstDoExprent);
 
+
         if (initCopyExprent != null && initCopyExprent.getLeft().type == Exprent.EXPRENT_VAR) {
           VarExprent copy = (VarExprent)initCopyExprent.getLeft();
           if (copy.getIndex() == array.getIndex() && copy.getVersion() == array.getVersion()) {
             preData.getExprents().remove(initCopyExprent);
+            initCopyExprent.getRight().addBytecodeOffsets(initCopyExprent.bytecode);
+            initCopyExprent.getRight().addBytecodeOffsets(stat.getIncExprent().bytecode);
             stat.setIncExprent(initCopyExprent.getRight());
           }
         }
       }
     }
 
-    cleanEmptyStatements(stat, firstData);
+    //cleanEmptyStatements(stat, firstData); //TODO: Look into this and see what it does...
 
     return true;
   }
@@ -520,8 +582,8 @@ public class MergeHelper {
   private static boolean isType(Exprent exp, int type) { //This is just a helper macro, Wish java had real macros.
     return exp != null && exp.type == type;
   }
-
   private static boolean isInvoke(Exprent exp, String cls, String method, String desc) {
+    exp = getUncast(exp);
     if (!isType(exp,  Exprent.EXPRENT_INVOCATION)) {
       return false;
     }
@@ -591,15 +653,13 @@ public class MergeHelper {
       return stat;
     }
 
-    switch (stat.type) {
-      case Statement.TYPE_SEQUENCE:
-        for (int i = stat.getStats().size() - 1; i >= 0; i--) {
-          Statement tmp = getLastDirectData(stat.getStats().get(i));
-          if (tmp == null || !tmp.getExprents().isEmpty()) {
-            return tmp;
-          }
-        }
+    for (int i = stat.getStats().size() - 1; i >= 0; i--) {
+      Statement tmp = getLastDirectData(stat.getStats().get(i));
+      if (tmp == null || !tmp.getExprents().isEmpty()) {
+        return tmp;
+      }
     }
+
     return null;
   }
 
@@ -608,14 +668,37 @@ public class MergeHelper {
       return stat;
     }
 
-    if (stat.type == Statement.TYPE_SEQUENCE) {
-      for (Statement tmp : stat.getStats()) {
-        Statement ret = getFirstDirectData(tmp);
-        if (ret != null) {
-          return ret;
-        }
+    for (Statement tmp : stat.getStats()) {
+      Statement ret = getFirstDirectData(tmp);
+      if (ret != null) {
+        return ret;
       }
     }
     return null;
   }
+
+  private static Exprent getUncast(Exprent exp) {
+    if (exp.type == Exprent.EXPRENT_FUNCTION) {
+      FunctionExprent func = (FunctionExprent)exp;
+      if (func.getFuncType() == FunctionExprent.FUNCTION_CAST) {
+        return getUncast(func.getLstOperands().get(0));
+      }
+    }
+    return exp;
+  }
+
+  private static boolean isIteratorCall(Exprent exp) {
+    return isInvoke(exp, null, "iterator",     "()Ljava/util/Iterator;"    ) ||
+           isInvoke(exp, null, "listIterator", "()Ljava/util/ListIterator;");
+  }
+
+  private static boolean isHasNextCall(Exprent exp) {
+    return isInvoke(exp, "java/util/Iterator",     "hasNext", "()Z") ||
+           isInvoke(exp, "java/util/ListIterator", "hasNext", "()Z");
+  }
+
+  private static boolean isNextCall(Exprent exp) {
+    return isInvoke(exp, "java/util/Iterator",     "next", "()Ljava/lang/Object;") ||
+           isInvoke(exp, "java/util/ListIterator", "next", "()Ljava/lang/Object;");
+  }
 }
