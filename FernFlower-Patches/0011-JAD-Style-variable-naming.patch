From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Tue, 11 Apr 2017 22:37:40 -0700
Subject: [PATCH] JAD Style variable naming


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 31236841f1b4bf4f452f30d6b95f21fcc99ec5b9..aa990406ef8d91838aa2d928bdfb183fe9e19333 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -117,15 +117,20 @@ public class ClassWriter {
                 buffer.append(", ");
               }
 
+              List<TypeAnnotation> iParameterTypeAnnotations = TargetInfo.FormalParameterTarget.extract(parameterTypeAnnotations, i);
+              VarType type = md_content.params[i];
+              String typeName = ExprProcessor.getCastTypeName(type, explicitlyTyped, TypeAnnotationWriteHelper.create(iParameterTypeAnnotations));
               if (explicitlyTyped) {
-                List<TypeAnnotation> iParameterTypeAnnotations = TargetInfo.FormalParameterTarget.extract(parameterTypeAnnotations, i);
-                VarType type = md_content.params[i];
-                buffer.append(ExprProcessor.getCastTypeName(type, TypeAnnotationWriteHelper.create(iParameterTypeAnnotations)));
+                buffer.append(typeName);
                 buffer.append(' ');
               }
 
               String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));
-              buffer.append(parameterName == null ? "param" + index : parameterName); // null iff decompiled with errors
+              if (parameterName == null) {
+                parameterName = "param" + index; // null iff decompiled with errors
+              }
+              parameterName = methodWrapper.methodStruct.getVariableNamer().renameParameter(mt.getAccessFlags(), typeName, parameterName, index);
+              buffer.append(parameterName);
 
               firstParameter = false;
             }
@@ -747,7 +752,11 @@ public class ClassWriter {
             buffer.append(' ');
 
             String parameterName = methodWrapper.varproc.getVarName(pair);
-            buffer.append(parameterName == null ? "param" + index : parameterName); // null iff decompiled with errors
+            if (parameterName == null) {
+              parameterName = "param" + index; // null iff decompiled with errors
+            }
+            parameterName = methodWrapper.methodStruct.getVariableNamer().renameParameter(flags, typeName, parameterName, index);
+            buffer.append(parameterName);
 
             paramCount++;
           }
@@ -919,7 +928,11 @@ public class ClassWriter {
             buffer.append(" ");
 
             String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));
-            buffer.append(parameterName == null ? "param" + index : parameterName); // null iff decompiled with errors
+            if (parameterName == null) {
+              parameterName = "param" + index; // null iff decompiled with errors
+            }
+            parameterName = methodWrapper.methodStruct.getVariableNamer().renameParameter(mt.getAccessFlags(), typeName, parameterName, index);
+            buffer.append(parameterName);
 
             firstParameter = false;
           }
diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 8173ecd04da97e5e9a8f5f9a2e309726439697e0..3398f884985021a324fc5ae6ac6a461f8e5b2f33 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -146,6 +146,7 @@ public class ClassesProcessor implements CodeConstants {
         node.access = cl.getAccessFlags();
         mapRootClasses.put(cl.qualifiedName, node);
       }
+      linkEnclosingMethods(cl);
     }
 
     // set non-sealed if class extends or implements a sealed class and is not final or sealed itself
@@ -256,6 +257,25 @@ public class ClassesProcessor implements CodeConstants {
     }
   }
 
+  private void linkEnclosingMethods(StructClass cl) {
+      StructEnclosingMethodAttribute attr = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_ENCLOSING_METHOD);
+      if (attr == null || attr.getMethodName() == null) {
+        return;
+      }
+      StructClass parent = context.getClasses().get(attr.getClassName());
+      if (parent == null) {
+        return;
+      }
+      StructMethod method = parent.getMethod(attr.getMethodName(), attr.getMethodDescriptor());
+      if (method == null) {
+        return;
+      }
+      if (method.enclosedClasses == null) {
+        method.enclosedClasses = new HashSet<>();
+      }
+      method.enclosedClasses.add(cl.qualifiedName);
+  }
+
   private static boolean isAnonymous(StructClass cl, StructClass enclosingCl) {
     // checking super class and interfaces
     int[] interfaces = cl.getInterfaces();
@@ -441,6 +461,7 @@ public class ClassesProcessor implements CodeConstants {
   private static void destroyWrappers(ClassNode node) {
     node.wrapper = null;
     node.classStruct.releaseResources();
+    node.classStruct.getMethods().forEach(m -> m.clearVariableNamer());
 
     for (ClassNode nd : node.nested) {
       destroyWrappers(nd);
@@ -563,4 +584,4 @@ public class ClassesProcessor implements CodeConstants {
       public boolean is_content_method_static;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
index 654d0ddf34821ce4ea800cd5421f6268e2ca3236..bb7b5b4e4a590219939a8f7e883b9c259c1adf73 100644
--- a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
+++ b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
@@ -7,6 +7,7 @@ import org.jetbrains.java.decompiler.main.collectors.ImportCollector;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
 import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
 import org.jetbrains.java.decompiler.struct.StructContext;
 
@@ -20,12 +21,14 @@ public class DecompilerContext {
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
   public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
   public static final String IN_CLASS_TYPE_PARAMS = "IN_CLASS_TYPE_PARAMS";
+  public static final String RENAMER_FACTORY = "RENAMER_FACTORY";
 
   private final Map<String, Object> properties;
   private final IFernflowerLogger logger;
   private final StructContext structContext;
   private final ClassesProcessor classProcessor;
   private final PoolInterceptor poolInterceptor;
+  private final IVariableNamingFactory renamerFactory;
   private ImportCollector importCollector;
   private VarProcessor varProcessor;
   private CounterContainer counterContainer;
@@ -35,7 +38,8 @@ public class DecompilerContext {
                            IFernflowerLogger logger,
                            StructContext structContext,
                            ClassesProcessor classProcessor,
-                           PoolInterceptor interceptor) {
+                           PoolInterceptor interceptor,
+                           IVariableNamingFactory renamerFactory) {
     Objects.requireNonNull(properties);
     Objects.requireNonNull(logger);
     Objects.requireNonNull(structContext);
@@ -46,6 +50,7 @@ public class DecompilerContext {
     this.structContext = structContext;
     this.classProcessor = classProcessor;
     this.poolInterceptor = interceptor;
+    this.renamerFactory = renamerFactory;
     this.counterContainer = new CounterContainer();
   }
 
@@ -113,6 +118,10 @@ public class DecompilerContext {
     return getCurrentContext().poolInterceptor;
   }
 
+  public static IVariableNamingFactory getNamingFactory() {
+    return getCurrentContext().renamerFactory;
+  }
+
   public static ImportCollector getImportCollector() {
     return getCurrentContext().importCollector;
   }
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index f8c413c7b7302b201a739310677d0103e2878d3e..aa8b1132b84fc44bf6decd96ebaf5c021c185ac1 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -10,6 +10,7 @@ import org.jetbrains.java.decompiler.struct.IDecompiledData;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructContext;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
+import org.jetbrains.java.decompiler.util.JADNameProvider;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 import org.jetbrains.java.decompiler.util.ClasspathScanner;
 
@@ -52,7 +53,25 @@ public class Fernflower implements IDecompiledData {
       converter = null;
     }
 
-    DecompilerContext context = new DecompilerContext(properties, logger, structContext, classProcessor, interceptor);
+    IVariableNamingFactory renamerFactory = null;
+    String factoryClazz = (String) properties.get(DecompilerContext.RENAMER_FACTORY);
+    if (factoryClazz != null) {
+      try {
+        renamerFactory = Class.forName(factoryClazz).asSubclass(IVariableNamingFactory.class).getDeclaredConstructor().newInstance();
+      } catch (Exception e) {
+        logger.writeMessage("Error loading renamer factory class: " + factoryClazz, e);
+      }
+    }
+    if (renamerFactory == null) {
+      if("1".equals(properties.get(IFernflowerPreferences.USE_JAD_VARNAMING))) {
+        boolean renameParams = "1".equals(properties.get(IFernflowerPreferences.USE_JAD_PARAMETER_RENAMING));
+        renamerFactory = new JADNameProvider.JADNameProviderFactory(renameParams);
+      } else {
+        renamerFactory = new IdentityRenamerFactory();
+      }
+    }
+
+    DecompilerContext context = new DecompilerContext(properties, logger, structContext, classProcessor, interceptor, renamerFactory);
     DecompilerContext.setCurrentContext(context);
 
     String vendor = System.getProperty("java.vendor", "missing vendor");
diff --git a/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..872ec764f11131d384e59f08c4aac9551add771b
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public class IdentityRenamerFactory implements IVariableNamingFactory, IVariableNameProvider {
+  @Override
+  public IVariableNameProvider createFactory(StructMethod method) {
+    return this;
+  }
+
+  @Override
+  public Map<VarVersionPair, String> rename(Map<VarVersionPair, String> variables) {
+    return null;
+  }
+
+  @Override
+  public void addParentContext(IVariableNameProvider renamer) {
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index 79108dd8772dc9444d66e6ba0cdd7f56ca382fbd..3cbbb19b4dd705f67d0b2450996f704a9e293168 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -52,6 +52,9 @@ public interface IFernflowerPreferences {
   String LINE_SEPARATOR_WIN = "\r\n";
   String LINE_SEPARATOR_UNX = "\n";
 
+  String USE_JAD_VARNAMING = "jvn"; // Overwrites any Local Variable names with JAD style names
+  String USE_JAD_PARAMETER_RENAMING = "jpr"; // Include parameter names in JAD naming
+
   Map<String, Object> DEFAULTS = getDefaults();
 
   static Map<String, Object> getDefaults() {
@@ -95,7 +98,9 @@ public interface IFernflowerPreferences {
     defaults.put(BANNER, "");
     defaults.put(UNIT_TEST_MODE, "0");
     defaults.put(DUMP_ORIGINAL_LINES, "0");
+    defaults.put(USE_JAD_VARNAMING, "0");
+    defaults.put(USE_JAD_PARAMETER_RENAMING, "0");
 
     return Collections.unmodifiableMap(defaults);
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c47d21eef640037a0c8ce69d9b4d5815be9ccd9
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main.extern;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+
+public interface IVariableNameProvider {
+  public Map<VarVersionPair,String> rename(Map<VarVersionPair,String> variables);
+
+  default String renameAbstractParameter(String name, int index) {
+     return name;
+  }
+
+  default String renameParameter(int flags, String type, String name, int index) {
+     if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0)
+        return renameAbstractParameter(name, index);
+     return name;
+  }
+
+  public void addParentContext(IVariableNameProvider renamer);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc1d7d67864ab12e894fcdf0ed8e1297ce057bee
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main.extern;
+
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public interface IVariableNamingFactory {
+  public IVariableNameProvider createFactory(StructMethod structMethod);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
index c1126a2b7559e2f8a69a54ee0b7db2ceda3d9776..964bff5a00b35969fa08e48ca355801fe2882ce8 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
@@ -158,7 +158,8 @@ public class ClassWrapper {
   }
 
   private static void applyDebugInfo(StructMethod mt, VarProcessor varProc, MethodWrapper methodWrapper) {
-    if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_VAR_NAMES)) {
+    // Only rename parameters in the var processor if we aren't already renaming them with JAD naming
+    if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_VAR_NAMES) && (!DecompilerContext.getOption(IFernflowerPreferences.USE_JAD_VARNAMING) || !DecompilerContext.getOption(IFernflowerPreferences.USE_JAD_PARAMETER_RENAMING))) {
       StructLocalVariableTableAttribute attr = mt.getLocalVariableAttr();
       if (attr != null) {
         // only param names here
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index f9a7e55c108959b9696cb52cfd91aee341e40b06..b35985211d1f0488f76cbd6e87f18e3732b2d589 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -2,6 +2,7 @@
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -11,6 +12,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.ExitExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.FieldExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.InvocationExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.NewExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
@@ -25,6 +27,7 @@ import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribu
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
+import org.jetbrains.java.decompiler.util.StatementIterator;
 
 import java.util.*;
 import java.util.Map.Entry;
@@ -842,6 +845,53 @@ public class VarDefinitionHelper {
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
       typeNames.put(e.getKey(), e.getValue().getCast());
     }
+
+    Map<VarVersionPair, String> renames = this.mt.getVariableNamer().rename(typeNames);
+
+    // Stuff the parent context into enclosed child methods
+    StatementIterator.iterate(root, (exprent) -> {
+      List<StructMethod> methods = new ArrayList<>();
+      if (exprent.type == Exprent.EXPRENT_VAR) {
+        VarExprent var = (VarExprent)exprent;
+        if (var.isClassDef()) {
+          ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(var.getVarType().getValue());
+          if (child != null)
+            methods.addAll(child.classStruct.getMethods());
+        }
+      }
+      else if (exprent.type == Exprent.EXPRENT_NEW) {
+        NewExprent _new = (NewExprent)exprent;
+        if (_new.isAnonymous()) { //TODO: Check for Lambda here?
+          ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(_new.getNewType().getValue());
+          if (child != null) {
+            if (_new.isLambda()) {
+              if (child.lambdaInformation.is_method_reference) {
+                //methods.add(child.getWrapper().getClassStruct().getMethod(child.lambdaInformation.content_method_key));
+              } else {
+                methods.add(child.classStruct.getMethod(child.lambdaInformation.content_method_name, child.lambdaInformation.content_method_descriptor));
+              }
+            } else {
+              methods.addAll(child.classStruct.getMethods());
+            }
+          }
+        }
+      }
+
+      for (StructMethod meth : methods) {
+        meth.getVariableNamer().addParentContext(VarDefinitionHelper.this.mt.getVariableNamer());
+      }
+      return 0;
+    });
+
+    if (mt.enclosedClasses != null) {
+      for (String cls : mt.enclosedClasses) {
+        StructClass cl = DecompilerContext.getStructContext().getClass(cls);
+        for (StructMethod meth : cl.getMethods()) {
+          meth.getVariableNamer().addParentContext(this.mt.getVariableNamer());
+        }
+      }
+    }
+
     Map<VarVersionPair, LocalVariable> lvts = new HashMap<>();
 
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
@@ -851,7 +901,16 @@ public class VarDefinitionHelper {
         continue;
       }
       LocalVariable lvt = e.getValue().getLVT();
+      String rename = renames == null ? null : renames.get(idx);
+
+      if (rename != null) {
+        varproc.setVarName(idx, rename);
+      }
+
       if (lvt != null) {
+        if (rename != null) {
+          lvt = lvt.rename(rename);
+        }
         varproc.setVarLVT(idx, lvt);
         lvts.put(idx, lvt);
       }
@@ -985,7 +1044,7 @@ public class VarDefinitionHelper {
 
     private VarInfo(LocalVariable lvt, VarType type) {
       if (lvt != null && lvt.getSignature() != null)
-        this.cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSignature()), true, Collections.emptyList());
+        this.cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSignature()), false, Collections.emptyList());
       else if (lvt != null)
         this.cast = ExprProcessor.getCastTypeName(lvt.getVarType(), false, Collections.emptyList());
       else if (type != null)
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index d48e950e7511d2a00ac9885d5dc7d4ff524bbb37..08efdbaa173380dbbc0cd30c5ec5d43b0c2cf074 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -4,6 +4,7 @@ package org.jetbrains.java.decompiler.struct;
 import org.jetbrains.java.decompiler.code.*;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
 import org.jetbrains.java.decompiler.struct.attr.StructCodeAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
@@ -20,6 +21,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static org.jetbrains.java.decompiler.code.CodeConstants.*;
 
@@ -72,6 +74,8 @@ public class StructMethod extends StructMember {
   private boolean expanded = false;
   private final String classQualifiedName;
   private final GenericMethodDescriptor signature;
+  private IVariableNameProvider renamer;
+  public Set<String> enclosedClasses; // Dirty hack, but the management of nested classes is trash.
 
   private StructMethod(int accessFlags,
                        Map<String, StructGeneralAttribute> attributes,
@@ -338,6 +342,17 @@ public class StructMethod extends StructMember {
     return seq;
   }
 
+  public IVariableNameProvider getVariableNamer() {
+    if (renamer == null) {
+      this.renamer = DecompilerContext.getNamingFactory().createFactory(this);
+    }
+    return renamer;
+  }
+
+  public void clearVariableNamer() {
+    this.renamer = null;
+  }
+
   public StructLocalVariableTableAttribute getLocalVariableAttr() {
     return getAttribute(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
   }
diff --git a/src/org/jetbrains/java/decompiler/util/JADNameProvider.java b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..15d798679efb2b6a14d93e665a5e2a2e1bc64102
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
+public class JADNameProvider implements IVariableNameProvider {
+  private HashMap<String, Holder> last = null;
+  private HashMap<String, String> remap = null;
+  private final HashMap<Integer, String> parameters = new HashMap<>();
+  private final StructMethod method;
+  private final boolean renameParameters;
+  private static final Pattern CAPS_START = Pattern.compile("^[A-Z]");
+  private static final Pattern ARRAY = Pattern.compile("(\\[|\\.\\.\\.)");
+
+  public JADNameProvider(boolean renameParameters, StructMethod wrapper) {
+    last = new HashMap<>();
+    last.put("int",     new Holder(0, true,  "i", "j", "k", "l"));
+    last.put("byte",    new Holder(0, false, "b"       ));
+    last.put("char",    new Holder(0, false, "c"       ));
+    last.put("short",   new Holder(1, false, "short"   ));
+    last.put("boolean", new Holder(0, true,  "flag"    ));
+    last.put("double",  new Holder(0, false, "d"       ));
+    last.put("float",   new Holder(0, true,  "f"       ));
+    last.put("File",    new Holder(1, true,  "file"    ));
+    last.put("String",  new Holder(0, true,  "s"       ));
+    last.put("Class",   new Holder(0, true,  "oclass"  ));
+    last.put("Long",    new Holder(0, true,  "olong"   ));
+    last.put("Byte",    new Holder(0, true,  "obyte"   ));
+    last.put("Short",   new Holder(0, true,  "oshort"  ));
+    last.put("Boolean", new Holder(0, true,  "obool"   ));
+    last.put("Package", new Holder(0, true,  "opackage"));
+    last.put("Enum",    new Holder(0, true,  "oenum"   ));
+
+    remap = new HashMap<>();
+    remap.put("long", "int");
+
+    this.method = wrapper;
+    this.renameParameters = renameParameters;
+  }
+
+  @Override
+  public synchronized void addParentContext(IVariableNameProvider iparent) {
+    JADNameProvider parent = (JADNameProvider) iparent;
+    HashMap<String, Holder> temp = new HashMap<>();
+    for (Entry<String, Holder> e : parent.last.entrySet()) {
+      temp.put(e.getKey(), e.getValue().copy());
+    }
+    this.last = temp;
+    this.remap = new HashMap<>(parent.remap);
+  }
+
+  private static class Holder {
+    public int id;
+    public boolean skip_zero;
+    public final List<String> names = new ArrayList<>();
+
+    public Holder(int t1, boolean skip_zero, String... names) {
+      this.id = t1;
+      this.skip_zero = skip_zero;
+      Collections.addAll(this.names, names);
+    }
+
+    public Holder(int t1, boolean skip_zero, List<String> names) {
+      this.id = t1;
+      this.skip_zero = skip_zero;
+      this.names.addAll(names);
+    }
+
+    @Override
+    public String toString() {
+      return "Holder[" + id + ", " + skip_zero + ", " + names.stream().collect(Collectors.joining(", ")) + "]";
+    }
+
+    public Holder copy() {
+        return new Holder(this.id, this.skip_zero, new ArrayList<>(this.names));
+    }
+  }
+
+  @Override
+  public Map<VarVersionPair,String> rename(Map<VarVersionPair, String> entries) {
+    int params = 0;
+    if ((this.method.getAccessFlags() & CodeConstants.ACC_STATIC) != CodeConstants.ACC_STATIC) {
+      params++;
+    }
+
+    MethodDescriptor md = MethodDescriptor.parseDescriptor(this.method.getDescriptor());
+    for (VarType param : md.params) {
+      params += param.getStackSize();
+    }
+
+    List<VarVersionPair> keys = new ArrayList<>(entries.keySet());
+    Collections.sort(keys, (o1, o2) -> (o1.var != o2.var) ? o1.var - o2.var : o1.version - o2.version);
+
+    Map<VarVersionPair, String> result = new LinkedHashMap<>();
+    for (VarVersionPair ver : keys) {
+      String type = cleanType(entries.get(ver));
+      if ("this".equals(type)) {
+        continue;
+      }
+      if (ver.var >= params) {
+        result.put(ver, getNewName(type));
+      } else if (renameParameters) {
+        result.put(ver, this.parameters.computeIfAbsent(ver.var, k -> getNewName(type)));
+      }
+    }
+    return result;
+  }
+
+  private String cleanType(String type) {
+     if (type.indexOf('<') != -1) {
+        type = type.substring(0, type.indexOf('<'));
+     }
+     if (type.indexOf('.') != -1) {
+        type = type.substring(type.lastIndexOf('.') + 1);
+     }
+     return type;
+  }
+
+  protected synchronized String getNewName(String type) {
+    String index = null;
+    String findtype = type;
+
+    while (findtype.contains("[][]")) {
+      findtype = findtype.replaceAll("\\[\\]\\[\\]", "[]");
+    }
+    if (last.containsKey(findtype)) {
+      index = findtype;
+    }
+    else if (last.containsKey(findtype.toLowerCase(Locale.ENGLISH))) {
+      index = findtype.toLowerCase(Locale.ENGLISH);
+    }
+    else if (remap.containsKey(type)) {
+      index = remap.get(type);
+    }
+
+    if ((index == null || index.length() == 0) && (CAPS_START.matcher(type).find() || ARRAY.matcher(type).find())) { // replace multi things with arrays.
+      type = type.replace("...", "[]");
+
+      while (type.contains("[][]")) {
+        type = type.replaceAll("\\[\\]\\[\\]", "[]");
+      }
+
+      String name = type.toLowerCase(Locale.ENGLISH);
+      // Strip single dots that might happen because of inner class references
+      name = name.replace(".", "");
+      boolean skip_zero = true;
+
+      if (Pattern.compile("\\[").matcher(type).find()) {
+        skip_zero = true;
+        name = "a" + name.replace("[]", "").replace("...", "");
+      }
+
+      last.put(type.toLowerCase(Locale.ENGLISH), new Holder(0, skip_zero, name));
+      index = type.toLowerCase(Locale.ENGLISH);
+    }
+
+    if (index == null || index.length() == 0) {
+      return type.toLowerCase(Locale.ENGLISH);
+    }
+
+    Holder holder = last.get(index);
+    int id = holder.id;
+    List<String> names = holder.names;
+
+    int ammount = names.size();
+
+    String name;
+    if (ammount == 1) {
+      name = names.get(0) + (id == 0 && holder.skip_zero ? "" : id);
+    }
+    else {
+      int num = id / ammount;
+      name = names.get(id % ammount) + (id < ammount && holder.skip_zero ? "" : num);
+    }
+
+    holder.id++;
+    return name;
+  }
+
+  @Override
+  public String renameParameter(int flags, String type, String name, int index) {
+     if (!this.renameParameters)
+         return IVariableNameProvider.super.renameParameter(flags, type, name, index);
+     return this.parameters.computeIfAbsent(index, k -> getNewName(cleanType(type)));
+  }
+
+  public static class JADNameProviderFactory implements IVariableNamingFactory {
+    private final boolean renameParameters;
+    public JADNameProviderFactory(boolean renameParameters) {
+        this.renameParameters = renameParameters;
+    }
+    @Override
+    public IVariableNameProvider createFactory(StructMethod method) {
+      return new JADNameProvider(renameParameters, method);
+    }
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/util/StatementIterator.java b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
new file mode 100644
index 0000000000000000000000000000000000000000..a41c910e58c3c0e16e6b13a90fe9f34acea09662
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.util;
+
+import java.util.List;
+
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph.ExprentIterator;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+
+public class StatementIterator {
+  public static void iterate(Statement stat, ExprentIterator itr) {
+    if (stat == null) {
+      return;
+    }
+
+    for (Exprent exp : stat.getVarDefinitions()) {
+      iterate(exp, itr);
+    }
+
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          iterate((Statement)obj, itr);
+        }
+        else if (obj instanceof Exprent) {
+          iterate((Exprent)obj, itr);
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        iterate(exp, itr);
+      }
+    }
+  }
+
+  private static void iterate(Exprent exp, ExprentIterator itr) {
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+    for (Exprent exprent : lst) {
+      itr.processExprent(exprent);
+    }
+  }
+}
diff --git a/test/org/jetbrains/java/decompiler/JADTest.java b/test/org/jetbrains/java/decompiler/JADTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..5348637179299ad07934495be8216583da36897b
--- /dev/null
+++ b/test/org/jetbrains/java/decompiler/JADTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler;
+
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.junit.Test;
+
+import java.util.Map;
+
+public class JADTest extends SingleClassesTestBase {
+
+    @Override
+    protected Map<String, String> getDecompilerOptions() {
+      return Map.of(
+        IFernflowerPreferences.BYTECODE_SOURCE_MAPPING, "1",
+        IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1",
+        IFernflowerPreferences.USE_JAD_VARNAMING, "1"
+      );
+    }
+
+    @Test public void testClassFields() { doTest("pkg/TestJADNaming"); }
+
+}
diff --git a/testData/classes/pkg/TestJADNaming.class b/testData/classes/pkg/TestJADNaming.class
new file mode 100644
index 0000000000000000000000000000000000000000..ce5676d7c337af79875dd42852333b71b071644c
GIT binary patch
literal 379
zcmY+8J5Iwu5QhJ?*Iqvo93vSCkrYq`3fv&mgh&XK0zoJe(XWkVIS(faHdo*n$rY$T
z6dZtxV{i(>*g;54F^~VB{dPXS-`)Y7pkYBpU0_SVVbD8imgZdswS9QUz%OR^F@tlR
zW^uomhVf!3!wD(8S7Z@GeUQs&d?V+TOb`ZZFe?^O+)K-~?P2_oU!7m}<uuKb<B@!n
zHE?JQ?tGm1|6GPf>H8CzCH`$VilZF+Q0Tfc6ws&8DC;z}s4}YB(F@o!H4K8Xz7Z)K
zf2&XQ)FkiJRlho}_&js%*RJcV0>0N=!fbhb1(gSy8t6O_YG8Ppr!Qf7!ZXMz;YtPH
nAtb1C3Em`R8x{iC75o6onnX>&Vidp{yD)#JjY3D+6|43GV%Iy?

literal 0
HcmV?d00001

diff --git a/testData/results/TestJADNaming.dec b/testData/results/TestJADNaming.dec
new file mode 100644
index 0000000000000000000000000000000000000000..b5d7ed54d77cc30c25688e1989a5a63eafaf863f
--- /dev/null
+++ b/testData/results/TestJADNaming.dec
@@ -0,0 +1,81 @@
+package pkg;
+
+public class TestJADNaming {
+   public void Func() {
+      short short1 = 1000;// 7
+      short short2 = 2000;
+      short short3 = 3000;
+      short short4 = 4000;
+      if (short1 != short2 && short3 == short4) {// 8
+         ;
+      }
+
+      boolean flag = true;// 9
+      boolean flag1 = false;
+      boolean flag2 = true;
+      boolean flag3 = false;
+      if (flag != flag1 && flag2 == flag3) {// 10
+         ;
+      }
+
+   }// 11
+}
+
+class 'pkg/TestJADNaming' {
+   method 'Func ()V' {
+      0      4
+      1      4
+      2      4
+      3      4
+      4      5
+      5      5
+      6      5
+      7      5
+      8      6
+      9      6
+      a      6
+      b      6
+      c      7
+      d      7
+      e      7
+      f      7
+      10      7
+      11      8
+      12      8
+      13      8
+      16      8
+      17      8
+      18      8
+      19      8
+      1c      12
+      1d      12
+      1e      12
+      1f      13
+      20      13
+      21      13
+      22      14
+      23      14
+      24      14
+      25      15
+      26      15
+      27      15
+      28      16
+      29      16
+      2a      16
+      2b      16
+      2c      16
+      2f      16
+      30      16
+      31      16
+      32      16
+      33      16
+      36      20
+   }
+}
+
+Lines mapping:
+7 <-> 5
+8 <-> 9
+9 <-> 13
+10 <-> 17
+11 <-> 21
diff --git a/testData/src/pkg/TestJADNaming.java b/testData/src/pkg/TestJADNaming.java
new file mode 100644
index 0000000000000000000000000000000000000000..87e1c035ea3a6fd049bb95ba09935cc674afacd4
--- /dev/null
+++ b/testData/src/pkg/TestJADNaming.java
@@ -0,0 +1,12 @@
+package pkg;
+
+import java.io.File;
+
+public class TestJADNaming {
+    public void Func() {
+        int a = 1000, b = 2000, c = 3000, d = 4000;
+        if (a == b || c == d);
+        boolean flag1 = true, flag2 = false, flag3 = true, flag4 = false;
+        if (flag1 == flag2 || flag3 == flag4);
+    }
+}
\ No newline at end of file
