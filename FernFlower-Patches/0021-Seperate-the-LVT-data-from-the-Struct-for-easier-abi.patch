From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Thu, 6 Aug 2015 13:52:24 -0700
Subject: [PATCH] Seperate the LVT data from the Struct for easier ability to
 pass around.


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
new file mode 100644
index 0000000000000000000000000000000000000000..0533981f9da54787c55fd9b54e1f1d555bdbed12
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
@@ -0,0 +1,70 @@
+package org.jetbrains.java.decompiler.modules.decompiler.vars;
+
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+public class LVTVariable implements Comparable<LVTVariable> {
+  public static final Comparator<LVTVariable> INDEX_SORTER = new Comparator<LVTVariable>() {
+    @Override
+    public int compare(LVTVariable o1, LVTVariable o2) {
+      if (o1.index != o2.index) return o1.index - o2.index;
+      if (o1.start != o2.start) return o1.start - o2.start;
+      return o1.end - o2.end;
+    }
+  };
+
+  public final String name;
+  public final int start;
+  public final int end;
+  public final int index;
+  private String desc;
+  private String sig;
+  private boolean isLVTT;
+
+  public LVTVariable(String name, String desc, int start, int end, int index, boolean isLVTT) {
+    this.name = name;
+    this.desc = desc;
+    this.start = start;
+    this.end = end;
+    this.index = index;
+    this.isLVTT = isLVTT;
+  }
+
+  void merge(LVTVariable other) {
+    if (other.isLVTT && this.sig == null) {
+      this.sig = other.desc;
+    }
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof LVTVariable))
+      return false;
+    return ((LVTVariable) obj).index == index && ((LVTVariable) obj).start == start;
+  }
+
+  @Override
+  public int hashCode() {
+    return index * 31 + start;
+  }
+
+  public void addTo(Map<Integer, Set<LVTVariable>> startpoints) {
+    Set<LVTVariable> starts = startpoints.get(this.start);
+    if (starts == null) {
+      starts = new HashSet<LVTVariable>();
+      startpoints.put(this.start, starts);
+    }
+    starts.add(this);
+  }
+
+  @Override
+  public int compareTo(LVTVariable o) {
+    if (o.start > start) return -1;
+    if (o.start < start) return 1;
+    if (o.index > index) return -1;
+    if (o.index < index) return 1;
+    return 0;
+  }
+}
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..75f144dccacee0a214fad16f9cde138ec64de256
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java
@@ -0,0 +1,72 @@
+package org.jetbrains.java.decompiler.modules.decompiler.vars;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class LocalVariableTable {
+  private Map<Integer, Set<LVTVariable>> startpoints;
+  private ArrayList<LVTVariable> allLVT;
+  private Map<VarVersionPair, String> mapVarNames;
+
+  public LocalVariableTable(int len) {
+    startpoints = new HashMap<Integer,Set<LVTVariable>>(len);
+    allLVT = new ArrayList<LVTVariable>(len);
+  }
+
+  public void addVariable(LVTVariable v) {
+    allLVT.add(v);
+    v.addTo(startpoints);
+  }
+
+  public void mergeLVTs(LocalVariableTable otherLVT) {
+   for (LVTVariable other : otherLVT.allLVT) {
+      int idx = allLVT.indexOf(other);
+      if (idx < 0) {
+        allLVT.add(other);
+      }
+      else {
+        LVTVariable mine = allLVT.get(idx);
+        mine.merge(other);
+      }
+    }
+    mapVarNames = null; // Invalidate the cache and rebuild it.
+  }
+
+  public LVTVariable find(Integer index, List<Integer> offsets) {
+    for (Integer offset : offsets) {
+      Set<LVTVariable> lvs = startpoints.get(offset);
+      if (lvs == null || lvs.isEmpty())
+        continue;
+      int idx = index.intValue();
+
+      for (LVTVariable lv : lvs) {
+        if (lv.index == idx)
+          return lv;
+      }
+    }
+    return null;
+  }
+
+  public Map<VarVersionPair, String> getMapVarNames() {
+    if (mapVarNames == null)
+      buildNameMap();
+    return mapVarNames;
+  }
+
+  private void buildNameMap() {
+    Map<Integer, Integer> versions = new HashMap<Integer, Integer>();
+    mapVarNames = new HashMap<VarVersionPair, String>();
+    for (LVTVariable lvt : allLVT) {
+      Integer idx = versions.get(lvt.index);
+      if (idx == null)
+        idx = 0;
+      else
+        idx++;
+      versions.put(lvt.index, idx);
+      mapVarNames.put(new VarVersionPair(lvt.index, idx.intValue()), lvt.name);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
index 5f55537fc80d50a1b22919165eb117f51f0b86b8..44557858b5cf5ef1a6b05c79c34bb41f6ae6e5eb 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
@@ -15,20 +15,15 @@
  */
 package org.jetbrains.java.decompiler.struct.attr;
 
+import org.jetbrains.java.decompiler.modules.decompiler.vars.LVTVariable;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.LocalVariableTable;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
 /*
   u2 local_variable_table_length;
@@ -42,69 +37,8 @@ import java.util.Set;
 */
 public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
 
-  public static class LVTVariable implements Comparable<LVTVariable> {
-      public final String name;
-      public final int start;
-      public final int end;
-      public final int index;
-      private String desc;
-      private String sig;
-      private boolean isLVTT;
-      LVTVariable(String name, String desc, int start, int end, int index, boolean isLVTT) {
-          this.name = name;
-          this.desc = desc;
-          this.start = start;
-          this.end = end;
-          this.index = index;
-          this.isLVTT = isLVTT;
-      }
-
-    void merge(LVTVariable other) {
-        if (other.isLVTT && this.sig == null) {
-            this.sig = other.desc;
-        }
-    }
-    @Override
-    public boolean equals(Object obj) {
-        return ((LVTVariable) obj).index == index && ((LVTVariable) obj).end == end;
-    }
-    @Override
-    public int hashCode() {
-        return index * 31 + end;
-    }
-
-    public void addTo(Map<Integer, Set<LVTVariable>> endpoints) {
-        Set<LVTVariable> ends = endpoints.get(this.end);
-        if (ends == null) {
-            ends = new HashSet<LVTVariable>();
-            endpoints.put(this.end, ends);
-        }
-        ends.add(this);
-    }
-
-    @Override
-    public int compareTo(LVTVariable o) {
-        if (o.end > end) return -1;
-        if (o.end < end) return 1;
-        if (o.index > index) return -1;
-        if (o.index < index) return 1;
-        return 0;
-    }
-  }
-
-  private static Comparator<LVTVariable> comp = new Comparator<LVTVariable>() {
-    @Override
-    public int compare(LVTVariable o1, LVTVariable o2)
-    {
-      if (o1.index != o2.index) return o1.index - o2.index;
-      if (o1.start != o2.start) return o1.start - o2.start;
-      return o1.end - o2.end;
-    }
-  };
-  private Map<VarVersionPair, String> mapVarNames = Collections.emptyMap();
-
-  private Map<Integer, Set<LVTVariable>> endpoints = Collections.emptyMap();
-  private ArrayList<LVTVariable> allLVT;
+  private Map<VarVersionPair, String> EMPTY_LVT = Collections.emptyMap();
+  private LocalVariableTable lvt;
 
   @Override
   public void initContent(ConstantPool pool) throws IOException {
@@ -113,9 +47,7 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
     int len = data.readUnsignedShort();
     boolean isLVTT = this.getName().equals(ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE);
     if (len > 0) {
-      mapVarNames = new HashMap<VarVersionPair, String>(len);
-      endpoints = new HashMap<Integer,Set<LVTVariable>>(len);
-      allLVT = new ArrayList<LVTVariable>(len);
+      lvt = new LocalVariableTable(len);
       for (int i = 0; i < len; i++) {
         int start = data.readUnsignedShort();
         int vlen = data.readUnsignedShort();
@@ -123,47 +55,17 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
         int descIndex = data.readUnsignedShort(); // either descriptor or signature
         int varIndex = data.readUnsignedShort();
         LVTVariable v = new LVTVariable(pool.getPrimitiveConstant(nameIndex).getString(), pool.getPrimitiveConstant(descIndex).getString(),start,start+vlen,varIndex,isLVTT);
-        allLVT.add(v);
-        v.addTo(endpoints);
+        lvt.addVariable(v);
       }
-      Collections.sort(allLVT, comp);
-      buildNameMap();
-    }
-    else {
-      mapVarNames = Collections.emptyMap();
     }
   }
 
   public void addLocalVariableTable(StructLocalVariableTableAttribute attr) {
-    mapVarNames.putAll(attr.getMapVarNames());
-    for (LVTVariable other : attr.allLVT) {
-      int idx = allLVT.indexOf(other);
-      if (idx < 0) {
-        allLVT.add(other);
-      }
-      else {
-        LVTVariable mine = allLVT.get(idx);
-        mine.merge(other);
-      }
-    }
-    Collections.sort(allLVT, comp);
-  }
-
-  private void buildNameMap() {
-    Map<Integer, Integer> versions = new HashMap<Integer, Integer>();
-    mapVarNames.clear();
-    for (LVTVariable lvt : allLVT) {
-      Integer idx = versions.get(lvt.index);
-      if (idx == null)
-        idx = 0;
-      else
-        idx++;
-      versions.put(lvt.index, idx);
-      mapVarNames.put(new VarVersionPair(lvt.index, idx.intValue()), lvt.name);
-    }
+    lvt.mergeLVTs(attr.lvt);
+    attr.lvt = lvt;
   }
 
   public Map<VarVersionPair, String> getMapVarNames() {
-    return mapVarNames;
+    return lvt == null ? EMPTY_LVT : lvt.getMapVarNames();
   }
 }
