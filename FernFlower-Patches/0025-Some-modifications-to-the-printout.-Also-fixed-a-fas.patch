From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Sat, 8 Aug 2015 16:13:27 -0400
Subject: [PATCH] Some modifications to the printout. Also, fixed a fascinating
 bug in VarVersionsProcessor where it dumped the original indexes because
 setVarVersions is called multiple times (seems to be some sort of reparse
 loop). Preserving an existing origvarstable across the that method seems to
 have improved accuracy a LOT.


diff --git a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
index 18f05a34329a4750249225ce7fbe44e4870d2469..4e865569886a79b208df09e2449106bea16ba87b 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
@@ -170,9 +170,13 @@ public class ClassWrapper {
 
         if (attr != null) {
           varProc.setDebugVarNames(attr.getMapVarNames());
+          varProc.setLVT(attr.getLVT());
         }
       }
 
+      MethodProcessorRunnable.printMethod(root, mt.getClassStruct().qualifiedName+"."+mt.getName()+mt.getDescriptor(),varProc);
+
+
       DecompilerContext.getLogger().endMethod();
     }
 
diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index dc6f2f0e61563f8132d99b70d3d81278f224da04..f0b17a55f189e6dd356a3188bb6e2ce01074393d 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -26,16 +26,20 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.code.DeadCodeHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.*;
 import org.jetbrains.java.decompiler.modules.decompiler.deobfuscator.ExceptionDeobfuscator;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.DummyExitStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.LVTVariable;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 
 import java.io.IOException;
 import java.util.BitSet;
+import java.util.List;
 
 public class MethodProcessorRunnable implements Runnable {
 
@@ -204,8 +208,6 @@ public class MethodProcessorRunnable implements Runnable {
 
     varProc.setVarDefinitions(root);
 
-    printMethod(root);
-
     // must be the last invocation, because it makes the statement structure inconsistent
     // FIXME: new edge type needed
     LabelHelper.replaceContinueWithBreak(root);
@@ -225,17 +227,17 @@ public class MethodProcessorRunnable implements Runnable {
     return finished;
   }
 
-  private static void printMethod(RootStatement root) {
-    System.out.println("{");
+  public static void printMethod(RootStatement root, String name, VarProcessor varProc) {
+    System.out.println(name + " {");
 
     for (Object obj : root.getSequentialObjects()) {
       if (obj instanceof Statement) {
-        printStatement((Statement)obj, "  ");
+        printStatement((Statement)obj, "  ",varProc);
       } else {
         System.out.println("  " + obj.getClass().getSimpleName());
       }
     }
-    printStatement(root.getDummyExit(), "  ");
+    printStatement(root.getDummyExit(), "  ",varProc);
     System.out.println("}");
   }
 
@@ -259,7 +261,7 @@ public class MethodProcessorRunnable implements Runnable {
     }
   }
 
-  private static void printStatement(Statement statement, String indent) {
+  private static void printStatement(Statement statement, String indent, VarProcessor varProc) {
     BitSet values = new BitSet();
     getOffset(statement, values);
     int start = values.nextSetBit(0);
@@ -269,7 +271,7 @@ public class MethodProcessorRunnable implements Runnable {
 
     if (statement.getExprents() != null) {
       for(Exprent exp : statement.getExprents()) {
-        System.out.println(indent + "  " + exp.getClass().getSimpleName());
+          System.out.println(printExprent(indent + "  ", exp,varProc));
       }
     }
     /*
@@ -332,10 +334,32 @@ public class MethodProcessorRunnable implements Runnable {
     indent += "  ";
     for (Object obj : statement.getSequentialObjects()) {
       if (obj instanceof Statement) {
-        printStatement((Statement)obj, indent);
+        printStatement((Statement)obj, indent,varProc);
+      } else if (obj instanceof Exprent) {
+          System.out.println(printExprent(indent, (Exprent) obj, varProc));
       } else {
         System.out.println(indent + obj.getClass().getSimpleName());
       }
     }
   }
+  private static String printExprent(String indent, Exprent exp, VarProcessor varProc) {
+      StringBuffer sb = new StringBuffer();
+      sb.append(indent);
+      BitSet values = new BitSet();
+      exp.getBytecodeRange(values);
+      sb.append("(").append(values.nextSetBit(0)).append(", ").append(values.length()-1).append(") ");
+      sb.append(exp.getClass().getSimpleName());
+      sb.append(" ").append(exp.id).append(" ");
+      if (exp instanceof VarExprent) {
+          VarExprent varExprent = (VarExprent)exp;
+        int currindex = varExprent.getIndex();
+        int origindex = varProc.getRemapped(currindex);
+        List<LVTVariable> candidates = varProc.getLVT().getCandidates(origindex);
+        sb.append("[").append(currindex).append(":").append(origindex).append(", ").append(varExprent.isStack()).append("]").append(candidates);
+      } else if (exp instanceof AssignmentExprent) {
+          AssignmentExprent assignmentExprent = (AssignmentExprent)exp;
+        sb.append("{").append(printExprent(" ",assignmentExprent.getLeft(),varProc)).append(" =").append(printExprent(" ",assignmentExprent.getRight(),varProc)).append("}");
+      }
+      return sb.toString();
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
index 0533981f9da54787c55fd9b54e1f1d555bdbed12..13cfa70a586a82cbcea81553680e8d59b5bfd343 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
@@ -67,4 +67,8 @@ public class LVTVariable implements Comparable<LVTVariable> {
     if (o.index < index) return 1;
     return 0;
   }
+  @Override
+    public String toString() {
+        return "\'("+index+","+start+")"+desc+(sig!=null ? "<"+sig+"> ":" ")+name+"\'";
+    }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java
index 75f144dccacee0a214fad16f9cde138ec64de256..027e81652438e7648ec02c49feb2afcb1e2f234c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LocalVariableTable.java
@@ -10,6 +10,7 @@ public class LocalVariableTable {
   private Map<Integer, Set<LVTVariable>> startpoints;
   private ArrayList<LVTVariable> allLVT;
   private Map<VarVersionPair, String> mapVarNames;
+private Map<Integer, List<LVTVariable>> mapLVT;
 
   public LocalVariableTable(int len) {
     startpoints = new HashMap<Integer,Set<LVTVariable>>(len);
@@ -59,6 +60,7 @@ public class LocalVariableTable {
   private void buildNameMap() {
     Map<Integer, Integer> versions = new HashMap<Integer, Integer>();
     mapVarNames = new HashMap<VarVersionPair, String>();
+    mapLVT = new HashMap<Integer,List<LVTVariable>>();
     for (LVTVariable lvt : allLVT) {
       Integer idx = versions.get(lvt.index);
       if (idx == null)
@@ -66,7 +68,17 @@ public class LocalVariableTable {
       else
         idx++;
       versions.put(lvt.index, idx);
+      List<LVTVariable> lvtList = mapLVT.get(lvt.index);
+      if (lvtList == null) {
+          lvtList = new ArrayList<LVTVariable>();
+          mapLVT.put(lvt.index, lvtList);
+      }
+      lvtList.add(lvt);
       mapVarNames.put(new VarVersionPair(lvt.index, idx.intValue()), lvt.name);
     }
   }
+
+public List<LVTVariable> getCandidates(int index) {
+    return mapLVT.get(index);
+}
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
index fbd3455dae324f21854b6374448c0c50f0c1e1ce..07b5398d4ccd7b6a06e91056a88b2b6e0df94291 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
@@ -31,10 +31,18 @@ public class VarProcessor {
   private VarVersionsProcessor varVersions;
   private final Map<VarVersionPair, String> thisVars = new HashMap<VarVersionPair, String>();
   private final Set<VarVersionPair> externalVars = new HashSet<VarVersionPair>();
+private LocalVariableTable lvt;
 
   public void setVarVersions(RootStatement root) {
+    Map<Integer, Integer> mapOriginalVarIndices = null;
+    if (varVersions != null) {
+        mapOriginalVarIndices = varVersions.getMapOriginalVarIndices();
+    }
     varVersions = new VarVersionsProcessor();
     varVersions.setVarVersions(root);
+    if (mapOriginalVarIndices != null) {
+        varVersions.getMapOriginalVarIndices().putAll(mapOriginalVarIndices);
+    }
   }
 
   public void setVarDefinitions(Statement root) {
@@ -121,4 +129,17 @@ public class VarProcessor {
   public Set<VarVersionPair> getExternalVars() {
     return externalVars;
   }
+
+public void setLVT(LocalVariableTable lvt) {
+    this.lvt = lvt;
+}
+public LocalVariableTable getLVT() {
+    return this.lvt;
+}
+
+public int getRemapped(int index) {
+    Integer res = varVersions.getMapOriginalVarIndices().get(index);
+    if (res == null) return index;
+    return res;
+}
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
index 4751052a5468ffc469d7166bce648d5b658e040d..0de789a6f2278edc1e327d741b800fdba4a9dfcc 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
@@ -233,6 +233,7 @@ public class VarVersionsProcessor {
 
     final Map<VarVersionPair, Integer> mapVarPaar = new HashMap<VarVersionPair, Integer>();
     Map<Integer, Integer> mapOriginalVarIndices = new HashMap<Integer, Integer>();
+    mapOriginalVarIndices.putAll(this.mapOriginalVarIndices);
 
     // map var-version pairs on new var indexes
     List<VarVersionPair> lst = new ArrayList<VarVersionPair>(mapExprentMinTypes.keySet());
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
index 44557858b5cf5ef1a6b05c79c34bb41f6ae6e5eb..4b00061fcee269a40b24f80b6147d4940caa9db6 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
@@ -68,4 +68,8 @@ public class StructLocalVariableTableAttribute extends StructGeneralAttribute {
   public Map<VarVersionPair, String> getMapVarNames() {
     return lvt == null ? EMPTY_LVT : lvt.getMapVarNames();
   }
+
+public LocalVariableTable getLVT() {
+    return lvt;
+}
 }
