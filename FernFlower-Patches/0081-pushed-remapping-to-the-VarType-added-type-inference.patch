From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RainWarrior <rainwarrior@fry.su>
Date: Wed, 14 Oct 2015 14:18:10 +0300
Subject: [PATCH] pushed remapping to the VarType, added type inference to a
 couple more places


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 3be3b6fb3db44ef1320c3106e7d432dd1579e335..60832d3af2925a806c852e72209e676fb293d882 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -853,6 +853,7 @@ public class ExprProcessor implements CodeConstants {
     lst = Exprent.sortIndexed(lst);
 
     for (Exprent expr : lst) {
+      expr.getInferredExprType(null);
       TextBuffer content = expr.toJava(indent, tracer);
       if (content.length() > 0) {
         if (expr.type != Exprent.EXPRENT_VAR || !((VarExprent)expr).isClassDef()) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
index 8276abdbc032467bcff47d2be07729c0f0e53d44..68f58305f21314d969c79cd0bdcdc14c5b0ae003 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
@@ -112,7 +112,7 @@ public class AssignmentExprent extends Exprent {
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     VarType leftType = left.getExprType();
-    VarType rightType = right.getInferredExprType(leftType);
+    VarType rightType = right.getInferredExprType(left.getInferredExprType(null));
 
     boolean fieldInClassInit = false, hiddenField = false;
     if (left.type == Exprent.EXPRENT_FIELD) { // first assignment to a final field. Field name without "this" in front of it
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index 884a2d7ed927eb6f402b05a169ca772764bf9c61..4c4b8981d0e7b3e12d7024e5dc7e05c31476ea8d 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -167,10 +167,10 @@ public class InvocationExprent extends Exprent {
 
   @Override
   public VarType getInferredExprType(VarType upperBound) {
-    //System.out.println("infer: " + instance + " " + classname + "." + name + " " + getExprType() + " " + upperBound);
     List<StructMethod> matches = getMatchedDescriptors();
     StructMethod desc = null;
     if(matches.size() == 1) desc = matches.get(0);
+    //System.out.println("infer: " + instance + " " + classname + "." + name + " " + getExprType() + " " + upperBound + " " + desc);
 
     VarType type = getExprType();
 
@@ -403,15 +403,15 @@ public class InvocationExprent extends Exprent {
     if(cl != null && cl.getSignature() != null && instance != null && instance.getInferredExprType(null).isGeneric()) {
       GenericType genType = (GenericType)instance.getInferredExprType(null);
       if(genType.getArguments().size() == cl.getSignature().fparameters.size()) {
-		/*System.out.println("remap: " + classname + "." + name);
-		if(instance instanceof FieldExprent) {
-			System.out.println(((FieldExprent)instance).getClassname() + "." + ((FieldExprent)instance).getName());
-		}*/
+        /*System.out.println("remap: " + classname + "." + name + " " + genType);
+        if(instance instanceof FieldExprent) {
+            System.out.println(((FieldExprent)instance).getClassname() + "." + ((FieldExprent)instance).getName());
+        }*/
         for(int i = 0; i < cl.getSignature().fparameters.size(); i++) {
           VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
           VarType to = genType.getArguments().get(i);
-          //System.out.println("(" + from.type + " " + from.value + " -> " + to.type + " " + to.value + ")");
-          if(from != null && to != null && to.type == CodeConstants.TYPE_OBJECT) {
+          if(from != null && to != null /*&& to.type == CodeConstants.TYPE_OBJECT*/) {
+            //System.out.println("(" + from.type + " " + from + " -> " + to.type + " " + to + ")");
             genArgs.put(from, to);
           }
         }
@@ -428,57 +428,65 @@ public class InvocationExprent extends Exprent {
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
         VarType type = descriptor.params[i];
-		VarType newType = null;
-        if(desc != null && desc.getSignature() != null && genericArgs.size() != 0 && desc.getSignature().params.size() == lstParameters.size()) {
+        VarType newType = null;
+        if(desc != null && desc.getSignature() != null && /*genericArgs.size() != 0 && */desc.getSignature().params.size() == lstParameters.size()) {
           newType = desc.getSignature().params.get(i);
-          boolean free = false;
+          /*boolean free = false;
           for(String param : desc.getSignature().fparameters) {
             if(param.equals(newType.value)) {
               free = true;
               break;
             }
           }
-          if(!free) {
+
+          if(!free) {*/
             type = newType;
-          }
+          //}
         }
-        if(genArgs.containsKey(type)) {
+        //System.out.println("check: " + type + " " + type.remap(genArgs) + " " + type.isGeneric() + " " + type.remap(genArgs).isGeneric());
+        /*if(genArgs.containsKey(type)) {
           type = genArgs.get(type);
+        }*/
+        VarType remappedType = type.remap(genArgs);
+        if(type != remappedType) {
+          type = remappedType;
+        }
+        else if(desc != null && desc.getSignature() != null && genericArgs.size() != 0) {
+          Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
+          for(int j = 0; j < genericArgs.size(); j++) {
+            VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
+            VarType to = genericArgs.get(j);
+            genMap.put(from, to);
+            //System.out.println("map: (" + from + " -> " + to + ")");
+          }
+          type = type.remap(genMap);
+          /*if(genMap.containsKey(type)) {
+            type = genMap.get(type);
+          }
+          // this only checks 1 level deep right now
+          else if(type.isGeneric()) {
+            GenericType genType = (GenericType)type;
+            List<VarType> toArgs = new ArrayList<VarType>();
+            boolean changed = false;
+            VarType parent = genType.getParent();
+            if(genMap.containsKey(parent)) {
+              parent = genMap.get(parent);
+              changed = true;
+            }
+            for(VarType arg : genType.getArguments()) {
+              if(genMap.containsKey(arg)) {
+                toArgs.add(genMap.get(arg));
+                changed = true;
+              } else {
+                toArgs.add(arg);
+              }
+            }
+            System.out.println("gen: " + changed + " " + parent + " ");
+            if(changed) {
+              type = new GenericType(type.type, type.arrayDim, type.value, parent, toArgs, genType.getWildcard());
+            }
+          }*/
         }
-		else if(desc != null && desc.getSignature() != null && genericArgs.size() != 0) {
-			Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
-			for(int j = 0; j < genericArgs.size(); j++) {
-				VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
-				VarType to = genericArgs.get(j);
-				genMap.put(from, to);
-				//System.out.println("map: (" + from + " -> " + to + ")");
-			}
-			if(genMap.containsKey(type)) {
-				type = genMap.get(type);
-			}
-			// this only checks 1 level deep right now
-			else if(type.isGeneric()) {
-				GenericType genType = (GenericType)type;
-				List<VarType> toArgs = new ArrayList<VarType>();
-				boolean changed = false;
-				VarType parent = genType.getParent();
-				if(genMap.containsKey(parent)) {
-					parent = genMap.get(parent);
-					changed = true;
-				}
-				for(VarType arg : genType.getArguments()) {
-					if(genMap.containsKey(arg)) {
-						toArgs.add(genMap.get(arg));
-						changed = true;
-					} else {
-						toArgs.add(arg);
-					}
-				}
-				if(changed) {
-					type = new GenericType(type.type, type.arrayDim, type.value, parent, toArgs, genType.getWildcard());
-				}
-			}
-		}
         /*if(desc != null && desc.getSignature() != null) {
           for(String ps: desc.getSignature().fparameters) {
             VarType param = GenericType.parse("T" + ps + ";");
@@ -488,12 +496,12 @@ public class InvocationExprent extends Exprent {
             }
           }
         }*/
-		VarType exprType = lstParameters.get(i).getInferredExprType(type);
-		if(exprType != null && exprType.type != CodeConstants.TYPE_NULL && type != null && type.type == CodeConstants.TYPE_GENVAR) {
-		  type = exprType;
-		}
-		//System.out.println("param: " + i + " " + newType + " " + exprType + " " + type + " " + lstParameters.get(i));
-        ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, true, ambiguous, tracer);
+        VarType exprType = lstParameters.get(i).getInferredExprType(type);
+        if(exprType != null /*&& exprType.type != CodeConstants.TYPE_NULL*/ && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+          type = exprType;
+        }
+        //System.out.println("param: " + i + " " + newType + " " + exprType + " " + type + " " + lstParameters.get(i));
+        ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, type.type != CodeConstants.TYPE_NULL, ambiguous, tracer);
         buf.append(buff);
 
         firstParameter = false;
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
index af06b8e0d37763abcbabbca680dee2539831f978..81342ed8f18463360e9c31f77e5091aa68ec7cdb 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
@@ -19,6 +19,8 @@ import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
+import java.util.Map;
+
 public class VarType {  // TODO: optimize switch
 
   public static final VarType[] EMPTY_ARRAY = {};
@@ -428,4 +430,11 @@ public class VarType {  // TODO: optimize switch
         throw new IllegalArgumentException("Invalid type: " + c);
     }
   }
+
+  public VarType remap(Map<VarType, VarType> map) {
+    if(map.containsKey(this)) {
+      return map.get(this);
+    }
+    return this;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index 9319bf76366d189afd5bdb98b018c8e0425a58b0..9ad5a1fe83d6f2e43f257bad5982e1b524e9d3af 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -23,6 +23,7 @@ import org.jetbrains.java.decompiler.struct.gen.VarType;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 public class GenericType extends VarType {
 
@@ -326,16 +327,47 @@ public class GenericType extends VarType {
   @Override
   public String toString() {
     StringBuilder buf = new StringBuilder();
-	switch(getWildcard()) {
+    switch(getWildcard()) {
       case GenericType.WILDCARD_EXTENDS:
         buf.append("? extends ");
         break;
       case GenericType.WILDCARD_SUPER:
         buf.append("? super ");
       break;
-	}
-	buf.append(super.toString());
+    }
+    buf.append(super.toString());
     buf.append(getTypeArguments());
-	return buf.toString();
+    return buf.toString();
+  }
+
+  @Override
+  public VarType remap(Map<VarType, VarType> map) {
+    VarType main = super.remap(map);
+    if(main != this) {
+      return main;
+    }
+    boolean changed = false;
+    VarType parent = getParent();
+    if(map.containsKey(parent)) {
+      parent = map.get(parent);
+      changed = true;
+    }
+    List<VarType> newArgs = new ArrayList<VarType>();
+    for(VarType arg : getArguments()) {
+      VarType newArg = null;
+      if(arg != null) {
+        newArg = arg.remap(map);
+      }
+      if(newArg != arg) {
+        newArgs.add(newArg);
+        changed = true;
+      } else {
+        newArgs.add(arg);
+      }
+    }
+    if(changed) {
+      return new GenericType(main.type, main.arrayDim, main.value, parent, newArgs, getWildcard());
+    }
+    return this;
   }
 }
