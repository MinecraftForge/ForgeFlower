From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Fri, 6 Nov 2015 01:36:47 -0500
Subject: [PATCH] Add variable renaming option and interface

"jvn" argument enables JAD-style variable naming (int i, j, k etc).
Can pass a "RENAMER_FACTORY" to the decompiler context: this is the
name of a class implementing IVariableNamingFactory, that will be
loaded and instantiated, overriding other variable naming options.

diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 808c5e1bb2c32a5f85eaac548040522697e60fc8..b90f2ec58cc54cdd9b72257824ec6ceaefbc536e 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -18,7 +18,6 @@ package org.jetbrains.java.decompiler.main;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
-import org.jetbrains.java.decompiler.main.extern.IAbstractParameterRenamer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.main.rels.ClassWrapper;
@@ -732,7 +731,7 @@ public class ClassWriter {
             buffer.append(' ');
             String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));
             if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
-                parameterName = renameParameterIfPossible(parameterName, index, methodWrapper, flags);
+                parameterName = methodWrapper.methodStruct.getRenamer().renameAbstractParameter(parameterName, index);
             }
             buffer.append(parameterName == null ? "param" + index : parameterName); // null iff decompiled with errors
 
@@ -839,13 +838,7 @@ public class ClassWriter {
     return !hideMethod;
   }
 
-  private String renameParameterIfPossible(String parameterName, int index, MethodWrapper methodWrapper, int flags) {
-    if (DecompilerContext.getProperty("abstractparamrenamer")==null) return parameterName;
-    IAbstractParameterRenamer property = (IAbstractParameterRenamer) DecompilerContext.getProperty("abstractparamrenamer");
-    return property.renameParameter(parameterName, index, methodWrapper, flags);
-}
-
-private static void mapLines(TextBuffer code, StructLineNumberTableAttribute table, BytecodeMappingTracer tracer, int startLine) {
+  private static void mapLines(TextBuffer code, StructLineNumberTableAttribute table, BytecodeMappingTracer tracer, int startLine) {
     // build line start offsets map
     HashMap<Integer, Set<Integer>> lineStartOffsets = new HashMap<Integer, Set<Integer>>();
     for (Map.Entry<Integer, Integer> entry : tracer.getMapping().entrySet()) {
diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 00600213ac4a4a39de72131a9cc6dc22424dc7a0..e0fdaacc5d6f16c5eea148540b2c90758779deae 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -24,6 +24,7 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.main.extern.IIdentifierRenamer;
 import org.jetbrains.java.decompiler.main.rels.ClassWrapper;
 import org.jetbrains.java.decompiler.main.rels.LambdaProcessor;
+import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.main.rels.NestedClassProcessor;
 import org.jetbrains.java.decompiler.main.rels.NestedMemberAccess;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.InvocationExprent;
@@ -353,6 +354,9 @@ public class ClassesProcessor {
 
     node.wrapper = null;
     node.classStruct.releaseResources();
+    for (StructMethod m : node.classStruct.getMethods()) {
+        m.unloadRenamer();
+    }
 
     for (ClassNode nd : node.nested) {
       destroyWrappers(nd);
diff --git a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
index 15c6e406640315e5fbe82d48006b1a15f97020c8..f946bb46ab04b018786a72371af431d42f65cf1c 100644
--- a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
+++ b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
@@ -21,8 +21,10 @@ import org.jetbrains.java.decompiler.main.collectors.ImportCollector;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
 import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
 import org.jetbrains.java.decompiler.struct.StructContext;
+import org.jetbrains.java.decompiler.util.JADNameProvider;
 
 import java.util.HashMap;
 import java.util.Locale;
@@ -36,6 +38,7 @@ public class DecompilerContext {
   public static final String CURRENT_METHOD_DESCRIPTOR = "CURRENT_METHOD_DESCRIPTOR";
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
   public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
+  public static final String RENAMER_FACTORY = "RENAMER_FACTORY";
 
   private static final ThreadLocal<DecompilerContext> currentContext = new ThreadLocal<DecompilerContext>();
 
@@ -48,17 +51,34 @@ public class DecompilerContext {
   private PoolInterceptor poolInterceptor;
   private IFernflowerLogger logger;
   private BytecodeSourceMapper bytecodeSourceMapper;
+  private IVariableNamingFactory renamerFactory;
 
   private DecompilerContext(Map<String, Object> properties) {
     this.properties = properties;
   }
 
-  public static void initContext(Map<String, Object> propertiesCustom) {
+  public static void initContext(Map<String, Object> propertiesCustom, IFernflowerLogger logger) {
     Map<String, Object> properties = new HashMap<String, Object>(IFernflowerPreferences.DEFAULTS);
     if (propertiesCustom != null) {
       properties.putAll(propertiesCustom);
     }
     currentContext.set(new DecompilerContext(properties));
+    setLogger(logger);
+    // Default a no-op renamer factory if none is provided
+    if (DecompilerContext.getProperty(RENAMER_FACTORY) != null) {
+      try {
+        currentContext.get().renamerFactory = Class.forName((String) DecompilerContext.getProperty(RENAMER_FACTORY)).asSubclass(IVariableNamingFactory.class).newInstance();
+      } catch (Exception e) {
+        getLogger().writeMessage("Error loading renamer factory class", e);
+      }
+    }
+    if (DecompilerContext.getNamingFactory() == null) {
+      if (DecompilerContext.getOption(IFernflowerPreferences.USE_JAD_VARNAMING)) {
+        currentContext.get().renamerFactory = new JADNameProvider.JADNameProviderFactory();
+      } else {
+        currentContext.get().renamerFactory = new IdentityRenamerFactory();
+      }
+    }
   }
 
   public static DecompilerContext getCurrentContext() {
@@ -141,6 +161,10 @@ public class DecompilerContext {
     return getCurrentContext().logger;
   }
 
+  public static IVariableNamingFactory getNamingFactory() {
+      return getCurrentContext().renamerFactory;
+  }
+
   public static void setLogger(IFernflowerLogger logger) {
     if (logger != null) {
       String level = (String)getProperty(IFernflowerPreferences.LOG_LEVEL);
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index 6afe975fe2034ad25b7810a0bdc59ebcff8453e1..320e250ce1fe0eeca0194b296a3944cc710127bc 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -27,6 +27,7 @@ import org.jetbrains.java.decompiler.struct.IDecompiledData;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructContext;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
+import org.jetbrains.java.decompiler.util.JADNameProvider;
 
 import java.io.File;
 import java.util.HashSet;
@@ -40,9 +41,8 @@ public class Fernflower implements IDecompiledData {
 
   public Fernflower(IBytecodeProvider provider, IResultSaver saver, Map<String, Object> options, IFernflowerLogger logger) {
     structContext = new StructContext(saver, this, new LazyLoader(provider));
-    DecompilerContext.initContext(options);
+    DecompilerContext.initContext(options,logger);
     DecompilerContext.setCounterContainer(new CounterContainer());
-    DecompilerContext.setLogger(logger);
 
     if (DecompilerContext.getOption(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH)) {
       addAllClasspath();
diff --git a/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..e8c33402d6b7e0c07dbe2aacf73c2f8f500fc8c3
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
@@ -0,0 +1,28 @@
+package org.jetbrains.java.decompiler.main;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public class IdentityRenamerFactory implements IVariableNamingFactory, IVariableNameProvider {
+  @Override
+  public IVariableNameProvider createFactory(StructMethod method) {
+    return this;
+  }
+
+  @Override
+  public String renameAbstractParameter(String abstractParam, int index) {
+    return abstractParam;
+  }
+
+  @Override
+  public Map<VarVersionPair, String> rename(Map<VarVersionPair, String> variables) {
+    return null;
+  }
+  @Override
+  public void addParentContext(IVariableNameProvider renamer) {
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IAbstractParameterRenamer.java b/src/org/jetbrains/java/decompiler/main/extern/IAbstractParameterRenamer.java
deleted file mode 100644
index 4c509eb6633f575b4f7cc93ad781885e8581be70..0000000000000000000000000000000000000000
--- a/src/org/jetbrains/java/decompiler/main/extern/IAbstractParameterRenamer.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.jetbrains.java.decompiler.main.extern;
-
-import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
-
-public interface IAbstractParameterRenamer {
-  public String renameParameter(String orig, int index, MethodWrapper wrapper, int flags);
-}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index 79dd8e890cd37e88bfbe9f0c22c825b3c2549bb8..7940dcfbd89ec1427459aeeac1aebaea30db1899 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -62,6 +62,8 @@ public interface IFernflowerPreferences {
 
   String INCLUDE_ENTIRE_CLASSPATH = "iec";
 
+  String USE_JAD_VARNAMING = "jvn";
+
   Map<String, Object> DEFAULTS = Collections.unmodifiableMap(new HashMap<String, Object>() {{
     put(REMOVE_BRIDGE, "1");
     put(REMOVE_SYNTHETIC, "0");
@@ -96,5 +98,6 @@ public interface IFernflowerPreferences {
     put(UNIT_TEST_MODE, "0");
     put(DUMP_ORIGINAL_LINES, "0");
     put(INCLUDE_ENTIRE_CLASSPATH, "0");
+    put(USE_JAD_VARNAMING, "0");
   }});
 }
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..26f10715a8d594f00480a80e9c94c8b3bf011998
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
@@ -0,0 +1,11 @@
+package org.jetbrains.java.decompiler.main.extern;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+
+public interface IVariableNameProvider {
+  public Map<VarVersionPair,String> rename(Map<VarVersionPair,String> variables);
+  public String renameAbstractParameter(String abstractParam, int index);
+  public void addParentContext(IVariableNameProvider renamer);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..2f6c3ec033f37a1ff88c1fb0ab75413144867ddc
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
@@ -0,0 +1,7 @@
+package org.jetbrains.java.decompiler.main.extern;
+
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public interface IVariableNamingFactory {
+  public IVariableNameProvider createFactory(StructMethod structMethod);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/MethodWrapper.java
index 0f44e42c44c68b178fced0d0c362fe6a027b5a8a..c277392bd6bace5efee52426204b6eeb61e35964 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodWrapper.java
@@ -15,7 +15,9 @@
  */
 package org.jetbrains.java.decompiler.main.rels;
 
+import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.FlattenStatementsHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index 3975d8cf93f8a2ce22b57ca3a666f3be77b5dcb4..9be9edbb36ecd3082cb15f5ff5a6ba8a627f3d89 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -577,7 +577,6 @@ public class NestedClassProcessor {
     for (final MethodWrapper meth : child.getWrapper().getMethods()) {
 
       if (meth.root != null) { // neither abstract nor native
-
         // local var names
         HashMap<VarVersionPair, String> mapNewNames = new HashMap<VarVersionPair, String>();
         // local var types
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
index cb376d9b480f06971c71647037a17a166764e805..16f2bfb5fbc04312c21d10d26441786ac0604657 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/LVTVariable.java
@@ -88,6 +88,8 @@ public class LVTVariable implements Comparable<LVTVariable> {
   }
 
   public LVTVariable rename(String newName) {
-    return new LVTVariable(newName, desc, start, end, index, isLVTT);
+    LVTVariable lvtVariable = new LVTVariable(newName, desc, start, end, index, isLVTT);
+    lvtVariable.sig = this.sig;
+    return lvtVariable;
   }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 164ddb5639ed92ae8bcab25a62713211d2e904fe..fcd8c64de9c7d3af4e9ce943c41dd58ced598014 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -16,13 +16,16 @@
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.ConstExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.NewExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph.ExprentIterator;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.DoStatement;
@@ -33,6 +36,7 @@ import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
+import org.jetbrains.java.decompiler.util.StatementIterator;
 
 import java.util.*;
 import java.util.Map.Entry;
@@ -424,35 +428,77 @@ public class VarDefinitionHelper {
 
   private void propogateLVTs(Statement stat) {
     MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
-    Map<VarVersionPair, VarInfo> types = new HashMap<VarVersionPair, VarInfo>();
+    Map<VarVersionPair, VarInfo> types = new LinkedHashMap<VarVersionPair, VarInfo>();
 
     int index = 0;
     if (!mt.hasModifier(CodeConstants.ACC_STATIC)) {
-      types.put(new VarVersionPair(index, 0), new VarInfo(varproc.getLVT().getCandidates(index++).get(0), new VarType(mt.getClassStruct().qualifiedName)));
+      types.put(new VarVersionPair(index++, 0), new VarInfo(null,null));
     }
 
     for (VarType var : md.params) {
-      List<LVTVariable> vars = varproc.getLVT().getCandidates(index);
-      if (vars != null) {
-        types.put(new VarVersionPair(index, 0), new VarInfo(vars.get(0), var));
+      if (varproc.getLVT() != null) {
+        List<LVTVariable> vars = varproc.getLVT().getCandidates(index);
+        if (vars != null) {
+          types.put(new VarVersionPair(index, 0), new VarInfo(null,null));
+        }
       }
       index += var.stackSize;
     }
 
     findTypes(stat, types);
 
-    //renameTypes(types);
-
+    Map<VarVersionPair,String> typeNames = new LinkedHashMap<VarVersionPair,String>();
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
-      if (e.getValue().lvt != null) {
-        varproc.setVarLVT(e.getKey(), e.getValue().lvt);
+      typeNames.put(e.getKey(), e.getValue().typeName());
+    }
+    final StructMethod current_meth = (StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
+    Map<VarVersionPair, String> renames = current_meth.getRenamer().rename(typeNames);
+
+    // Stuff the parent context into enclosed child methods
+    StatementIterator.iterate(root, new ExprentIterator(){
+      @Override
+      public int processExprent(Exprent exprent){
+        ClassNode child = null;
+        if (exprent.type == Exprent.EXPRENT_VAR) {
+          VarExprent var = (VarExprent)exprent;
+          if (var.isClassDef()) {
+            child = DecompilerContext.getClassProcessor().getMapRootClasses().get(var.getVarType().value);
+          }
+        }
+        else if (exprent.type == Exprent.EXPRENT_NEW) {
+          NewExprent _new = (NewExprent)exprent;
+          if (_new.isAnonymous()) { //TODO: Check for Lambda here?
+            child = DecompilerContext.getClassProcessor().getMapRootClasses().get(_new.getNewType().value);
+          }
+        }
+
+        if (child != null) {
+          for (StructMethod meth : child.classStruct.getMethods()) {
+            meth.getRenamer().addParentContext(current_meth.getRenamer());
+          }
+        }
+        return 0;
       }
-    }
+    });
 
     Map<VarVersionPair, LVTVariable> lvts = new HashMap<VarVersionPair, LVTVariable>();
+
     for (Entry<VarVersionPair, VarInfo> e : types.entrySet()) {
-      if (e.getValue().lvt != null) {
-        lvts.put(e.getKey(), e.getValue().lvt);
+      VarVersionPair idx = e.getKey();
+      // skip this. we can't rename it
+      if (idx.var == 0 && !mt.hasModifier(CodeConstants.ACC_STATIC)) {
+        continue;
+      }
+      LVTVariable lvt = e.getValue().lvt;
+      if (renames!=null) {
+        varproc.setVarName(idx, renames.get(idx));
+      }
+      if (lvt != null) {
+        if (renames!=null) {
+          lvt = lvt.rename(renames.get(idx));
+        }
+        varproc.setVarLVT(idx, lvt);
+        lvts.put(idx, lvt);
       }
     }
 
@@ -508,14 +554,21 @@ public class VarDefinitionHelper {
     String cast;
     private VarInfo(LVTVariable lvt, VarType type) {
       if (lvt != null && lvt.getSig() != null) {
-        cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSig()));
+        cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSig()),false);
       }
       else if (lvt != null) {
-        cast = ExprProcessor.getCastTypeName(lvt.getVarType());
+        cast = ExprProcessor.getCastTypeName(lvt.getVarType(),false);
+      }
+      else if (type != null) {
+        cast = ExprProcessor.getCastTypeName(type,false);
       }
       else {
-        cast = ExprProcessor.getCastTypeName(type);
+        cast = "this";
       }
+      this.lvt = lvt;
+    }
+    public String typeName() {
+      return cast;
     }
   }
 
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index 8f0da2b8eeed9428133834dbf4bd8be3f6e38ee5..d7ede2e3ab1f542a7223cc79e2f139d29c29cec4 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -18,6 +18,7 @@ package org.jetbrains.java.decompiler.struct;
 import org.jetbrains.java.decompiler.code.*;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
@@ -60,6 +61,7 @@ public class StructMethod extends StructMember {
   private InstructionSequence seq;
   private boolean expanded = false;
   private VBStyleCollection<StructGeneralAttribute, String> codeAttributes;
+  private IVariableNameProvider renamer;
 
   public StructMethod(DataInputFullStream in, StructClass clStruct) throws IOException {
     classStruct = clStruct;
@@ -118,10 +120,17 @@ public class StructMethod extends StructMember {
     if (containsCode && !expanded) {
       byte[] code = classStruct.getLoader().loadBytecode(this, codeFullLength);
       seq = parseBytecode(new DataInputFullStream(code), codeLength, classStruct.getPool());
+      loadRenamer();
       expanded = true;
     }
   }
 
+  private void loadRenamer() {
+    if (this.renamer == null) {
+      this.renamer = DecompilerContext.getNamingFactory().createFactory(this);
+    }
+  }
+
   public void releaseResources() throws IOException {
     if (containsCode && expanded) {
       seq = null;
@@ -405,4 +414,13 @@ public class StructMethod extends StructMember {
   public GenericMethodDescriptor getSignature() {
     return signature;
   }
+
+  public IVariableNameProvider getRenamer() {
+    loadRenamer();
+    return renamer;
+  }
+
+  public void unloadRenamer() {
+    this.renamer = null;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/util/JADNameProvider.java b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..b588cec7b138dfffeb1d57a11aeb7e4b41fa5a38
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
@@ -0,0 +1,194 @@
+package org.jetbrains.java.decompiler.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public class JADNameProvider implements IVariableNameProvider {
+    private HashMap<String, Holder> last = null;
+    private HashMap<String, String> remap = null;
+    private static final Pattern CAPS_START = Pattern.compile("^[A-Z]");
+    private static final Pattern ARRAY = Pattern.compile("(\\[|\\.\\.\\.)");
+
+    public JADNameProvider(StructMethod wrapper) {
+      last = new HashMap<String, Holder>();
+      last.put("int",     new Holder(0, true,  "i", "j", "k", "l"));
+      last.put("byte",    new Holder(0, false, "b"       ));
+      last.put("char",    new Holder(0, false, "c"       ));
+      last.put("short",   new Holder(1, false, "short"   ));
+      last.put("boolean", new Holder(0, true,  "flag"    ));
+      last.put("double",  new Holder(0, false, "d"       ));
+      last.put("float",   new Holder(0, true,  "f"       ));
+      last.put("File",    new Holder(1, true,  "file"    ));
+      last.put("String",  new Holder(0, true,  "s"       ));
+      last.put("Class",   new Holder(0, true,  "oclass"  ));
+      last.put("Long",    new Holder(0, true,  "olong"   ));
+      last.put("Byte",    new Holder(0, true,  "obyte"   ));
+      last.put("Short",   new Holder(0, true,  "oshort"  ));
+      last.put("Boolean", new Holder(0, true,  "obool"   ));
+      last.put("Package", new Holder(0, true,  "opackage"));
+      last.put("Enum",    new Holder(0, true,  "oenum"   ));
+
+      remap = new HashMap<String, String>();
+      remap.put("long", "int");
+    }
+
+    @Override
+    public void addParentContext(IVariableNameProvider iparent) {
+        JADNameProvider parent = (JADNameProvider) iparent;
+        last = new HashMap<String, Holder>();
+        for (Entry<String, Holder> e : parent.last.entrySet()) {
+            Holder v = e.getValue();
+            last.put(e.getKey(), new Holder(v.id, v.skip_zero, v.names));
+        }
+
+        remap = new HashMap<String, String>();
+        for (Entry<String, String> e : parent.remap.entrySet()) {
+            remap.put(e.getKey(), e.getValue());
+        }
+    }
+
+    private static class Holder {
+      public int id;
+      public boolean skip_zero;
+      public final List<String> names = new ArrayList<String>();
+
+      public Holder(int t1, boolean skip_zero, String... names) {
+        this.id = t1;
+        this.skip_zero = skip_zero;
+        Collections.addAll(this.names, names);
+      }
+
+      public Holder(int t1, boolean skip_zero, List<String> names) {
+        this.id = t1;
+        this.skip_zero = skip_zero;
+        this.names.addAll(names);
+      }
+    }
+
+    public Map<VarVersionPair,String> rename(Map<VarVersionPair, String> entries) {
+      List<VarVersionPair> keys = new ArrayList<VarVersionPair>(entries.keySet());
+      Collections.sort(keys, new Comparator<VarVersionPair>(){
+        @Override
+        public int compare(VarVersionPair o1, VarVersionPair o2) {
+          if (o1.var != o2.var) return o1.var - o2.var;
+          return o1.version - o2.version;
+        }
+      });
+      Map<VarVersionPair,String> result = new LinkedHashMap<VarVersionPair,String>();
+      for (VarVersionPair ver : keys) {
+        String type = entries.get(ver);
+        if ("this".equals(type)) {
+          continue;
+        }
+        if (type.indexOf('<') != -1) {
+          type = type.substring(0, type.indexOf('<'));
+        }
+        if (type.indexOf('.') != -1) {
+          type = type.substring(type.lastIndexOf('.')+1);
+        }
+        result.put(ver, getNewName(type));
+      }
+      return result;
+    }
+
+    protected String getNewName(String type) {
+        String index = null;
+        String findtype = type;
+
+        while (findtype.contains("[][]"))
+        {
+            findtype = findtype.replaceAll("\\[\\]\\[\\]", "[]");
+        }
+        if (last.containsKey(findtype))
+        {
+            index = findtype;
+        }
+        else if (last.containsKey(findtype.toLowerCase(Locale.ENGLISH)))
+        {
+            index = findtype.toLowerCase(Locale.ENGLISH);
+        }
+        else if (remap.containsKey(type))
+        {
+            index = remap.get(type);
+        }
+
+        if ((index == null || index.length() == 0) && (CAPS_START.matcher(type).find() || ARRAY.matcher(type).find()))
+        {
+            // replace multi things with arrays.
+            type = type.replace("...", "[]");
+
+            while (type.contains("[][]"))
+            {
+                type = type.replaceAll("\\[\\]\\[\\]", "[]");
+            }
+
+            String name = type.toLowerCase(Locale.ENGLISH);
+            // Strip single dots that might happen because of inner class references
+            name = name.replace(".", "");
+            boolean skip_zero = true;
+
+            if (Pattern.compile("\\[").matcher(type).find())
+            {
+                skip_zero = true;
+                name = "a" + name;
+                name = name.replace("[]", "").replace("...", "");
+            }
+
+            last.put(type.toLowerCase(Locale.ENGLISH), new Holder(0, skip_zero, name));
+            index = type.toLowerCase(Locale.ENGLISH);
+        }
+
+        if (index == null || index.length() == 0)
+        {
+            return type.toLowerCase(Locale.ENGLISH);
+        }
+
+        Holder holder = last.get(index);
+        int id = holder.id;
+        List<String> names = holder.names;
+
+        int ammount = names.size();
+
+        String name;
+        if (ammount == 1)
+        {
+            name = names.get(0) + (id == 0 && holder.skip_zero ? "" : id);
+        }
+        else
+        {
+            int num = id / ammount;
+            name = names.get(id % ammount) + (id < ammount && holder.skip_zero ? "" : num);
+        }
+
+        holder.id++;
+        return name;
+    }
+
+    @Override
+    public String renameAbstractParameter(String abstractParam, int index) {
+      return abstractParam;
+    }
+
+
+    public static class JADNameProviderFactory implements IVariableNamingFactory {
+        @Override
+        public IVariableNameProvider createFactory(StructMethod method) {
+            return new JADNameProvider(method);
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/util/StatementIterator.java b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e4c8b475a4fdf4d6452ebe57621fc36bc2a2e38
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/StatementIterator.java
@@ -0,0 +1,43 @@
+package org.jetbrains.java.decompiler.util;
+
+import java.util.List;
+
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph.ExprentIterator;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+
+public class StatementIterator {
+  public static void iterate(Statement stat, ExprentIterator itr) {
+    if (stat == null) {
+      return;
+    }
+
+    for (Exprent exp : stat.getVarDefinitions()) {
+      iterate(exp, itr);
+    }
+
+    if (stat.getExprents() == null) {
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          iterate((Statement)obj, itr);
+        }
+        else if (obj instanceof Exprent) {
+          iterate((Exprent)obj, itr);
+        }
+      }
+    }
+    else {
+      for (Exprent exp : stat.getExprents()) {
+        iterate(exp, itr);
+      }
+    }
+  }
+
+  private static void iterate(Exprent exp, ExprentIterator itr) {
+    List<Exprent> lst = exp.getAllExprents(true);
+    lst.add(exp);
+    for (Exprent exprent : lst) {
+      itr.processExprent(exprent);
+    }
+  }
+}
diff --git a/test/org/jetbrains/java/decompiler/DecompilerTestFixture.java b/test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
index 77eda8797ac72262d0c6dabbbd06a0ed0f481596..f2c344a925dda9d1081aa867987147fd3fb3664e 100644
--- a/test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
+++ b/test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
@@ -46,26 +46,23 @@ public class DecompilerTestFixture {
     assertTrue("current dir: " + new File("").getAbsolutePath(), isTestDataDir(testDataDir));
 
     //noinspection SSBasedInspection
-    tempDir = getRandomDir();
-    if (tempDir.exists()) tempDir.delete();
+    tempDir = File.createTempFile("decompiler_test_", "_dir");
+    assertTrue(tempDir.delete());
+
     targetDir = new File(tempDir, "decompiled");
-    targetDir.mkdirs();
+    assertTrue(targetDir.mkdirs());
     decompiler = new ConsoleDecompiler(this.targetDir, new HashMap<String, Object>() {{
       put(IFernflowerPreferences.LOG_LEVEL, "warn");
       put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES, "1");
       put(IFernflowerPreferences.REMOVE_SYNTHETIC, "1");
       put(IFernflowerPreferences.REMOVE_BRIDGE, "1");
       put(IFernflowerPreferences.LITERALS_AS_IS, "1");
-      put(IFernflowerPreferences.MAX_PROCESSING_METHOD, "60000");
+      put(IFernflowerPreferences.UNIT_TEST_MODE, "1");
       putAll(options);
     }});
   }
 
-  protected File getRandomDir() throws IOException {
-	  return File.createTempFile("decompiler_test_", "_dir");
-  }
-
-public void tearDown() {
+  public void tearDown() {
     if (tempDir != null && cleanup) {
       delete(tempDir);
     }
@@ -98,5 +95,6 @@ public void tearDown() {
         for (File f : files) delete(f);
       }
     }
+    assertTrue(file.delete());
   }
 }
diff --git a/test/org/jetbrains/java/decompiler/LVTTest.java b/test/org/jetbrains/java/decompiler/LVTTest.java
index 368407ef017b524f7e26940606e7b50714c7d96a..b4af1f7cfd661fe456121f999a495c89dffb1d0f 100644
--- a/test/org/jetbrains/java/decompiler/LVTTest.java
+++ b/test/org/jetbrains/java/decompiler/LVTTest.java
@@ -59,4 +59,5 @@ public class LVTTest extends SingleClassesTestBase {
 //  @Test public void testMCAbstractResourcePack() { doTest("net/minecraft/client/resources/AbstractResourcePack"); }
 //  @Test public void testMCGuiShareToLan() { doTest("net/minecraft/client/gui/GuiShareToLan"); }
 //  @Test public void testMCContainerPlayer() { doTest("net/minecraft/inventory/ContainerPlayer"); }
+  @Test public void testMCContainerPlayer() { doTest("net/minecraft/command/PlayerSelector"); }
 }
diff --git a/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
index 2ae6da55e0d8ecb2fbdb39a6e42d1f179ac32203..087c8102c11b1258d8e3f1615fe64f745b8587d6 100644
--- a/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
+++ b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
@@ -16,83 +16,47 @@
 package org.jetbrains.java.decompiler;
 
 import org.hamcrest.Matchers;
-import org.jetbrains.java.decompiler.code.CodeConstants;
-import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler;
-import org.jetbrains.java.decompiler.main.extern.IAbstractParameterRenamer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
-import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 import org.junit.After;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.io.*;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
 public class MinecraftDecompilationTest {
-  public static final Pattern p = Pattern.compile("func_(\\d+)_.*");
   private DecompilerTestFixture fixture;
-  public static final int LOOPS = Integer.parseInt(System.getProperty("fftestloops","50"));
-  public static final String OUTROOT = System.getProperty("fftestout","C:/TEMP/FFTEST");
-  public static final String MD5IN = System.getProperty("ffmd5in",null);
 
   private static final String MC_JAR = "minecraft_ff_in.jar";
   @Before
   public void setUp() throws IOException {
-    fixture = new DecompilerTestFixture() {
-      @Override
-      public File getRandomDir() {
-        return new File(OUTROOT,"fftest");
-      }
-    };
+    fixture = new DecompilerTestFixture();
+    // -din=1 -rbr=0 -dgs=1 -asc=1 -rsy=0
     Map<String,Object> mcFFOptions = new HashMap<String,Object>() {{
         put(IFernflowerPreferences.DECOMPILE_INNER,"1");
         put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES,"1");
         put(IFernflowerPreferences.ASCII_STRING_CHARACTERS,"1");
         put(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH, "1");
-        put(IFernflowerPreferences.REMOVE_BRIDGE, "1");
-        put(IFernflowerPreferences.REMOVE_SYNTHETIC, "1");
-        put(IFernflowerPreferences.NEW_LINE_SEPARATOR, "1");
-        put(IFernflowerPreferences.LITERALS_AS_IS, "0");
     }};
     fixture.setUp(mcFFOptions);
-    DecompilerContext.setProperty("abstractparamrenamer", new IAbstractParameterRenamer() {
-        @Override
-        public String renameParameter(String orig, int index, MethodWrapper wrapper, int flags) {
-            String result = orig;
-            if ((flags & CodeConstants.ACC_ABSTRACT) != 0) {
-                String methName = wrapper.methodStruct.getName();
-                Matcher m = p.matcher(methName);
-                if (m.matches()) {
-                    result = String.format("p_%s_%d_", m.group(1),index);
-                }
-            }
-            return result;
-        }
-    });
     if (!new File(fixture.getTestDataDir(), MC_JAR).exists()) {
-      throw new RuntimeException("Missing "+MC_JAR+" in testData dir - aborting");
+        throw new RuntimeException("Missing "+MC_JAR+" in testData dir - aborting");
     }
   }
 
   @After
   public void tearDown() {
-    fixture.tearDown();
-    fixture = null;
+//    fixture.tearDown();
+//    fixture = null;
   }
 
 //  @Test
@@ -108,116 +72,32 @@ public class MinecraftDecompilationTest {
 //  }
 
   @Test
-  public void testJar() throws IOException {
-    Map<String,String> md5s = new HashMap<String,String>();
-    MessageDigest md5;
-    try {
-      md5 = MessageDigest.getInstance("MD5");
-    } catch (NoSuchAlgorithmException e1) {
-      md5 = null;
-    }
-    System.out.printf("TEST SETUP: MD5: %s, OUTPUT: %s, LOOPS %d\n",MD5IN, OUTROOT, LOOPS);
+  public void testJar() {
     ConsoleDecompiler decompiler = fixture.getDecompiler();
-    Map<String, String> valid = new HashMap<String,String>();
-    if (MD5IN != null) {
-        byte[] bytes = InterpreterUtil.getBytes(new File(MD5IN));
-        String md5list = new String(bytes,"UTF-8");
-        for (String line : md5list.split("\n")) {
-            String[] parts = line.split(",");
-            md5s.put(parts[0],parts[1]);
-        }
-    } else {
-
-        System.out.println("Decompiling base");
-        decompiler.addSpace(new File(fixture.getTestDataDir(), MC_JAR), true);
-        decompiler.decompileContext();
-
-
-        readJar(new File(fixture.getTargetDir(), MC_JAR),md5s,md5);
-        File outmd5 = new File(fixture.getRandomDir(),"md5s.csv");
-        FileWriter fos = new FileWriter(outmd5);
-        for (Entry<String, String> md5sum : md5s.entrySet()) {
-          fos.write(String.format("%s,%s\n", md5sum.getKey(),md5sum.getValue()));
-        }
-        fos.close();
-    }
-    Map<String, HashSet<String>> variants = new HashMap<String, HashSet<String>>();
-    File outRoot = new File(OUTROOT,"ffbulk");
-    outRoot.mkdirs();
-    for (int x = 0; x < LOOPS; x++) {
-      this.tearDown();
-      this.setUp();
-      System.out.printf("%d/%s Starting Decompile",x,LOOPS);
-      decompiler = fixture.getDecompiler();
-      decompiler.addSpace(new File(fixture.getTestDataDir(), MC_JAR), true);
-      decompiler.decompileContext();
-      System.gc();
+    decompiler.addSpace(new File(fixture.getTestDataDir(), MC_JAR), true);
+    decompiler.decompileContext();
 
-      Map<String, String> data = readJar(new File(fixture.getTargetDir(), MC_JAR),null,null);
+    File unpacked = new File(fixture.getTempDir(), "unpacked");
+    unpack(new File(fixture.getTargetDir(), "bulk.jar"), unpacked);
 
-      for (Entry<String, String> e : data.entrySet()) {
-        String fname = e.getKey();
-        String found = e.getValue();
-        String md5digest = md5digest(found, md5);
-        String expected = null;
-        if (md5digest.equals(md5s.get(fname)) && !valid.containsKey(fname)) {
-          valid.put(fname, found);
-          expected = found;
-        } else if (valid.containsKey(fname)) {
-          expected = valid.get(fname);
-        }
-        HashSet<String> set = variants.get(fname);
-        if (set == null) {
-          set = new HashSet<String>();
-          set.add(md5s.get(fname));
-          variants.put(fname, set);
-        }
-        if (!set.contains(md5digest)) {
-            System.out.println("New Variant: " + fname);
-            set.add(md5digest);
-            System.out.println("Orig md5:"+md5s.get(fname));
-            System.out.println("Variant md5: "+md5digest);
-            if (expected != null) writeFile(expected,fname,outRoot);
-            writeFile(found,fname+"."+md5digest,outRoot);
-        } else if (!md5digest.equals(md5s.get(fname))) {
-          System.out.println("Existing Variant: " + fname);
-          System.out.println("Variant md5: "+md5digest);
-        }
-      }
-    }
 //    compareDirectories(new File(fixture.getTestDataDir(), "bulk"), unpacked);
   }
 
-  private static void writeFile(String fl, String path, File outRoot) {
-      File out = new File(outRoot,path);
-      out.getParentFile().mkdirs();
-      try {
-        FileWriter fw = new FileWriter(out.getAbsoluteFile());
-          fw.write(fl);
-          fw.close();
-    } catch (IOException e) {
-        e.printStackTrace();
-    }
-  }
-  private static Map<String, String> readJar(File archive, Map<String, String> md5s, MessageDigest md5) {
-    Map<String, String> ret = new HashMap<String, String>();
+  private static void unpack(File archive, File targetDir) {
     try {
       ZipFile zip = new ZipFile(archive);
       try {
         Enumeration<? extends ZipEntry> entries = zip.entries();
         while (entries.hasMoreElements()) {
           ZipEntry entry = entries.nextElement();
-          if (!entry.isDirectory() && entry.getName().endsWith(".java")) {
+          if (!entry.isDirectory()) {
+            File file = new File(targetDir, entry.getName());
+            assertTrue(file.getParentFile().mkdirs() || file.getParentFile().isDirectory());
             InputStream in = zip.getInputStream(entry);
-            ByteArrayOutputStream out = new ByteArrayOutputStream((int)entry.getSize());
+            OutputStream out = new FileOutputStream(file);
             InterpreterUtil.copyStream(in, out);
             out.close();
             in.close();
-            String fileContent = new String(out.toByteArray());
-            ret.put(entry.getName(), fileContent);
-            if (md5!=null && md5s != null) {
-                md5s.put(entry.getName(), md5digest(fileContent, md5));
-            }
           }
         }
       }
@@ -228,14 +108,17 @@ public class MinecraftDecompilationTest {
     catch (IOException e) {
       throw new RuntimeException(e);
     }
-    return ret;
   }
-  private static String md5digest(String input, MessageDigest md5) {
-      md5.reset();
-      try {
-        return String.format("0%032x",new BigInteger(1,md5.digest(input.getBytes("UTF-8"))));
-    } catch (UnsupportedEncodingException e) {
-        return null;
+
+  private static void compareDirectories(File expected, File actual) {
+    String[] expectedList = expected.list();
+    String[] actualList = actual.list();
+    assertThat(actualList, Matchers.arrayContainingInAnyOrder(expectedList));
+    for (String name : expectedList) {
+      File child = new File(expected, name);
+      if (child.isDirectory()) {
+        compareDirectories(child, new File(actual, name));
+      }
     }
   }
 }
