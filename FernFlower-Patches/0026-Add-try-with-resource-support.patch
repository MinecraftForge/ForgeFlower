From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Justin <jrd2558@gmail.com>
Date: Mon, 6 Aug 2018 20:26:59 -0700
Subject: [PATCH] Add try with resource support


diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index 76d057fb3970d07a2fc7c07efc756e77e2d53222..ff258b0e6a4d92b242932578d5529e3998634d7a 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -179,6 +179,10 @@ public class MethodProcessorRunnable implements Runnable {
 
       LabelHelper.identifyLabels(root);
 
+      if (TryHelper.enhanceTryStats(root, mt)) {
+        continue;
+      }
+
       if (InlineSingleBlockHelper.inlineSingleBlocks(root)) {
         continue;
       }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
index 05e945fa82190610c0147389204d579d3d1d61e4..f5e696aeed8749f5ecf3d816f1e2d12924526ec1 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
@@ -57,7 +57,7 @@ public final class LabelHelper {
               lst.addAll(((SwitchStatement)parent).getCaseStatements());
             }
 
-            for (int i = 0; i < lst.size(); i++) {
+            for (int i = 1; i < lst.size(); i++) {
               if (lst.get(i) == dest) {
                 lst.get(i - 1).addLabeledEdge(edge);
                 break;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/TryHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/TryHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..35df7b22c37c2357679df262ce16a9f40739d059
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/TryHelper.java
@@ -0,0 +1,577 @@
+package org.jetbrains.java.decompiler.modules.decompiler;
+
+import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.BasicBlockStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class TryHelper
+{
+  public static boolean enhanceTryStats(RootStatement root, StructMethod mt) {
+    boolean ret = makeTryWithResourceRec(root, mt);
+    if (ret) {
+      SequenceHelper.condenseSequences(root);
+      if (collapseTryRec(root, mt)) {
+        SequenceHelper.condenseSequences(root);
+      }
+    }
+    return ret;
+  }
+
+  private static boolean makeTryWithResourceRec(Statement stat, StructMethod mt) {
+    if (stat.type == Statement.TYPE_CATCHALL && ((CatchAllStatement)stat).isFinally()) {
+      if (makeTryWithResource((CatchAllStatement)stat)) {
+        return true;
+      }
+    }
+
+    if (mt.getBytecodeVersion() >= CodeConstants.BYTECODE_JAVA_11 && stat.type == Statement.TYPE_TRYCATCH) {
+      if (makeTryWithResourceJ11((CatchStatement) stat)) {
+        return true;
+      }
+    }
+
+    for (Statement st : stat.getStats()) {
+      if (makeTryWithResourceRec(st, mt)) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  private static boolean collapseTryRec(Statement stat, StructMethod mt) {
+    // This method uses two different algorithms as the J11 code expects to process everything that it can without returning, while the J8 expects to return early.
+    // Future work could be done to improve the flow of things here.
+    if (mt.getBytecodeVersion() >= CodeConstants.BYTECODE_JAVA_11) {
+      boolean ret = false;
+      if (stat.type == Statement.TYPE_TRYCATCH) {
+        CatchStatement tryStat = (CatchStatement) stat;
+        if (collapseTryJ11(tryStat)) {
+          ret = true;
+        }
+      }
+
+      for (Statement st : stat.getStats()) {
+        ret |= collapseTryRec(st, mt);
+      }
+
+      return ret;
+    } else {
+      if (stat.type == Statement.TYPE_TRYCATCH) {
+        CatchStatement tryStat = (CatchStatement) stat;
+        if (collapseTry(tryStat)) {
+          return true;
+        }
+      }
+
+      for (Statement st : stat.getStats()) {
+        if (collapseTryRec(st, mt)) {
+          return true;
+        }
+      }
+
+      return false;
+    }
+  }
+
+  private static boolean makeTryWithResource(CatchAllStatement finallyStat) {
+    Statement handler = finallyStat.getHandler();
+
+    // The finally block has a specific statement structure we can check for
+    if (handler.getStats().size() != 2) {
+      return false;
+    }
+
+    Statement toCheck = finallyStat.getHandler().getFirst();
+    if (toCheck.type != Statement.TYPE_IF || ((IfStatement)toCheck).getIfstat().type != Statement.TYPE_IF) {
+      return false;
+    }
+
+    toCheck = ((IfStatement)toCheck).getIfstat();
+
+    if (((IfStatement)toCheck).getElsestat() == null) {
+      return false;
+    }
+
+    Statement elseBlock = ((IfStatement)toCheck).getElsestat();
+    VarExprent var = null;
+
+    if (elseBlock.getExprents() != null && elseBlock.getExprents().size() == 1) {
+      Exprent exp = elseBlock.getExprents().get(0);
+
+      if (isCloseable(exp)) {
+        var = (VarExprent)((InvocationExprent)exp).getInstance();
+      }
+    }
+
+    if (var != null) {
+      AssignmentExprent ass = null;
+      BasicBlockStatement initBlock = null;
+      for (StatEdge edge : finallyStat.getAllPredecessorEdges()) {
+        if (edge.getDestination().equals(finallyStat) && edge.getSource().type == Statement.TYPE_BASICBLOCK) {
+          ass = findResourceDef(var, edge.getSource());
+          if (ass != null) {
+            initBlock = (BasicBlockStatement)edge.getSource();
+            break;
+          }
+        }
+      }
+
+      if (ass != null) {
+        Statement stat = finallyStat.getParent();
+        Statement stat2 = finallyStat.getFirst();
+
+        if (stat2.type == Statement.TYPE_TRYCATCH) {
+          CatchStatement child = (CatchStatement)stat2;
+
+          AssignmentExprent resourceDef = (AssignmentExprent)ass.copy();
+          if (ass.getRight().getExprType().equals(VarType.VARTYPE_NULL)) {
+            if (child.getFirst() != null) {
+              fixResourceAssignment(resourceDef, child.getFirst());
+            }
+          }
+
+          if (resourceDef.getRight().getExprType().equals(VarType.VARTYPE_NULL)) {
+            return false;
+          }
+
+          child.setTryType(CatchStatement.RESOURCES);
+          initBlock.getExprents().remove(ass);
+          child.getResources().add(0, resourceDef);
+
+          if (!finallyStat.getVarDefinitions().isEmpty()) {
+            child.getVarDefinitions().addAll(0, finallyStat.getVarDefinitions());
+          }
+
+          stat.replaceStatement(finallyStat, child);
+          removeRedundantThrow(initBlock, child);
+          return true;
+        }
+      }
+    }
+
+    return false;
+  }
+
+  public static boolean makeTryWithResourceJ11(CatchStatement tryStatement) {
+    // Doesn't have a catch block, probably already processed
+    if (tryStatement.getStats().size() < 2) {
+      return false;
+    }
+
+    Statement inner = tryStatement.getStats().get(1); // Get catch block
+
+    AutoCloseableInfo info = findAutoCloseable(inner);
+    VarExprent closeable = info.closeable;
+    boolean nullable = info.nullable;
+
+    if (closeable == null) {
+      return false;
+    }
+
+    // Sometimes there's edges going to weird places. To be careful, we don't want to create try with resources in those instances.
+    List<StatEdge> regedges = tryStatement.getSuccessorEdges(StatEdge.TYPE_REGULAR);
+    if (!regedges.isEmpty()) {
+      Statement destination = regedges.get(0).getDestination();
+      if (destination.type == Statement.TYPE_IF) {
+        List<StatEdge> breaks = destination.getSuccessorEdges(StatEdge.TYPE_BREAK);
+
+        if (!breaks.isEmpty()) {
+
+          if (!tryStatement.getParent().containsStatement(breaks.get(0).closure)) {
+            return false;
+          }
+        }
+      }
+    }
+
+    // Find basic block that contains the resource assignment
+    for (StatEdge edge : tryStatement.getPredecessorEdges(StatEdge.TYPE_REGULAR)) {
+      // Find predecessors that lead towards the target try statement
+      if (edge.getDestination().equals(tryStatement) && edge.getSource().type == Statement.TYPE_BASICBLOCK) {
+        AssignmentExprent assignment = findResourceDef(closeable, edge.getSource());
+
+        if (assignment != null) {
+          edge.getSource().getExprents().remove(assignment);
+
+          tryStatement.setTryType(CatchStatement.RESOURCES);
+
+          // Add resource assignment
+          tryStatement.getResources().add(0, assignment);
+
+          // Destroy catch block
+          tryStatement.getStats().remove(1);
+
+          Statement parent = tryStatement.getParent();
+
+          boolean processedClose = false;
+          for (int i = 0; i < parent.getStats().size(); i++) {
+            Statement stat = parent.getStats().get(i);
+
+            if (stat == tryStatement) {
+              continue;
+            }
+
+            if (nullable) {
+              // Check for if statement that contains a null check and a close()
+              if (stat.type == Statement.TYPE_IF) {
+                IfStatement ifStat = (IfStatement) stat;
+                Exprent condition = ifStat.getHeadexprent().getCondition();
+
+                if (condition.type == Exprent.EXPRENT_FUNCTION) {
+                  FunctionExprent func = unwrapNegations((FunctionExprent) condition);
+
+                  // Ensure the exprent is the one we want to remove
+                  if (func.getFuncType() == FunctionExprent.FUNCTION_NE && func.getLstOperands().get(0).type == Exprent.EXPRENT_VAR && func.getLstOperands().get(1).getExprType().equals(VarType.VARTYPE_NULL)) {
+                    if (func.getLstOperands().get(0).type == Exprent.EXPRENT_VAR && ((VarExprent)func.getLstOperands().get(0)).getVarVersionPair().equals(closeable.getVarVersionPair())) {
+
+                      Statement ifBlock = ifStat.getIfstat();
+
+                      // Disconnect edges to and from the inside of block's contents
+                      for (StatEdge suc : ifBlock.getAllSuccessorEdges()) {
+                        ifBlock.removeSuccessor(suc);
+                      }
+
+                      // Disconnect predecessors
+                      for (StatEdge pred : ifBlock.getAllPredecessorEdges()) {
+                        pred.getSource().removeSuccessor(pred);
+                        ifBlock.removePredecessor(pred);
+                      }
+
+                      // Remove inner block from the statement
+                      ifStat.getStats().removeWithKey(ifBlock.id);
+
+                      StatEdge successor = ifStat.getAllSuccessorEdges().get(0);
+
+                      for (StatEdge pred : ifStat.getAllPredecessorEdges()) {
+                        Statement predStat = pred.getSource();
+
+                        predStat.removeSuccessor(pred);
+
+                        // When the predecessor is the try statement, we add normal control flow, as the successor is located next to the try statement. When it is not, it must be inside the try, so we break out of it.
+                        // This prevents successor blocks from being inlined, as there are still multiple breaks to the successor and not a singular one that can be inlined
+                        StatEdge newEdge = new StatEdge(predStat == tryStatement ? StatEdge.TYPE_REGULAR : StatEdge.TYPE_BREAK, predStat, successor.getDestination());
+                        predStat.addSuccessor(newEdge);
+                      }
+
+                      ifStat.removeSuccessor(successor);
+                      successor.getDestination().removePredecessor(successor);
+
+                      parent.getStats().removeWithKey(ifStat.id);
+
+                      processedClose = true;
+                    }
+                  }
+                }
+              }
+            } else {
+              if (stat.getExprents() != null) {
+                Iterator<Exprent> itr = stat.getExprents().iterator();
+
+                while (itr.hasNext()) {
+                  Exprent exprent = itr.next();
+
+                  if (exprent.type == Exprent.EXPRENT_INVOCATION) {
+                    Exprent inst = ((InvocationExprent) exprent).getInstance();
+
+                    // Ensure the var exprent we want to remove is the right one
+                    if (inst.type == Exprent.EXPRENT_VAR && ((VarExprent)inst).getVarVersionPair().equals(closeable.getVarVersionPair()) && isCloseable(exprent)) {
+                      itr.remove();
+
+                      processedClose = true;
+                    }
+                  }
+                }
+              }
+            }
+
+            if (processedClose) {
+              break;
+            }
+          }
+
+          if (processedClose) {
+            return true;
+          }
+        }
+      }
+    }
+
+    return false;
+  }
+
+  private static class AutoCloseableInfo {
+    private final VarExprent closeable;
+    private final boolean nullable;
+
+    private AutoCloseableInfo(VarExprent closeable, boolean nullable) {
+      this.closeable = closeable;
+      this.nullable = nullable;
+    }
+  }
+
+  private static AutoCloseableInfo findAutoCloseable(Statement inner) {
+    while (inner.type == Statement.TYPE_SEQUENCE) {
+      inner = inner.getFirst();
+    }
+
+    VarExprent closeable = null;
+    boolean nullable = false;
+
+    // If the catch statement contains a simple try catch, then it's a nonnull resource
+    if (inner.type == Statement.TYPE_TRYCATCH) {
+      Statement inTry = inner.getStats().get(0);
+
+      // Catch block contains a basic block inside which has the closeable invocation
+      if (inTry.type == Statement.TYPE_BASICBLOCK) {
+        Exprent first = inTry.getExprents().get(0);
+
+        if (isCloseable(first)) {
+          closeable = (VarExprent) ((InvocationExprent)first).getInstance();
+        }
+      }
+    }
+
+    // Nullable resource, contains null check
+    if (inner.type == Statement.TYPE_IF) {
+      Exprent ifCase = ((IfStatement)inner).getHeadexprent().getCondition();
+
+      if (ifCase.type == Exprent.EXPRENT_FUNCTION) {
+        FunctionExprent func = unwrapNegations((FunctionExprent) ifCase);
+
+        Exprent check = func.getLstOperands().get(0);
+
+        // If it's not a var, end processing early
+        if (check.type != Exprent.EXPRENT_VAR) {
+          return new AutoCloseableInfo(closeable, false);
+        }
+
+        // Make sure it's checking against null
+        if (func.getLstOperands().get(1).getExprType().equals(VarType.VARTYPE_NULL)) {
+          inner = ((IfStatement)inner).getIfstat();
+
+          // Process try catch inside of if statement
+          if (inner.type == Statement.TYPE_TRYCATCH) {
+            Statement inTry = inner.getStats().get(0);
+
+            if (inTry.type == Statement.TYPE_BASICBLOCK) {
+              Exprent first = inTry.getExprents().get(0);
+
+              // Check for closable invocation
+              if (isCloseable(first)) {
+                closeable = (VarExprent) ((InvocationExprent)first).getInstance();
+                nullable = true;
+
+                // Double check that the variables in the null check and the closeable match
+                if (!closeable.getVarVersionPair().equals(((VarExprent)check).getVarVersionPair())) {
+                  closeable = null;
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+
+    return new AutoCloseableInfo(closeable, nullable);
+  }
+
+  private static FunctionExprent unwrapNegations(FunctionExprent func) {
+    while (func.getFuncType() == FunctionExprent.FUNCTION_BOOL_NOT) {
+      Exprent expr = func.getLstOperands().get(0);
+
+      if (expr.type == Exprent.EXPRENT_FUNCTION) {
+        func = (FunctionExprent) expr;
+      } else {
+        break;
+      }
+    }
+
+    return func;
+  }
+
+  private static boolean collapseTry(CatchStatement catchStat) {
+    Statement parent = catchStat;
+    if (parent.getFirst() != null && parent.getFirst().type == Statement.TYPE_SEQUENCE) {
+      parent = parent.getFirst();
+    }
+    if (parent != null && parent.getFirst() != null && parent.getFirst().type == Statement.TYPE_TRYCATCH) {
+      CatchStatement toRemove = (CatchStatement)parent.getFirst();
+
+      if (toRemove.getTryType() == CatchStatement.RESOURCES) {
+        catchStat.setTryType(CatchStatement.RESOURCES);
+        catchStat.getResources().addAll(toRemove.getResources());
+
+        catchStat.getVarDefinitions().addAll(toRemove.getVarDefinitions());
+        parent.replaceStatement(toRemove, toRemove.getFirst());
+
+        if (!toRemove.getVars().isEmpty()) {
+          for (int i = 0; i < toRemove.getVars().size(); ++i) {
+            catchStat.getVars().add(i, toRemove.getVars().get(i));
+            catchStat.getExctStrings().add(i, toRemove.getExctStrings().get(i));
+
+            catchStat.getStats().add(i + 1, catchStat.getStats().get(i + 1));
+          }
+        }
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // Merges try with resource statements that are nested within each other, as well as try with resources statements nested in a normal try.
+  private static boolean collapseTryJ11(CatchStatement stat) {
+    if (stat.getStats().isEmpty()) {
+      return false;
+    }
+
+    // Get the statement inside of the current try
+    Statement inner = stat.getStats().get(0);
+
+    // Check if the inner statement is a try statement
+    if (inner.type == Statement.TYPE_TRYCATCH) {
+      if (((CatchStatement)inner).getTryType() == CatchStatement.RESOURCES) {
+
+        if (inner.getStats().size() == 1) {
+          // Set the outer try to be resources, and initialize
+          stat.setTryType(CatchStatement.RESOURCES);
+          stat.getResources().addAll(((CatchStatement)inner).getResources());
+          stat.getVarDefinitions().addAll(inner.getVarDefinitions());
+
+          Statement innerBlock = inner.getStats().get(0);
+
+          // Remove extraneous edges
+          // The inner block has edges which can point to the same places, so we need to remove it to fix duplicated edges and labels
+          List<StatEdge> innerEdges = inner.getAllSuccessorEdges();
+          for (StatEdge succ : innerBlock.getAllSuccessorEdges()) {
+            boolean found = false;
+            for (StatEdge innerEdge : innerEdges) {
+              if (succ.getDestination() == innerEdge.getDestination() && succ.getType() == innerEdge.getType()) {
+                found = true;
+                break;
+              }
+            }
+
+            if (found) {
+              innerBlock.removeSuccessor(succ);
+            }
+          }
+
+          // Replace the inner try statement with the block inside
+          stat.replaceStatement(inner, innerBlock);
+
+          return true;
+        }
+      }
+    }
+
+    return false;
+  }
+
+  private static AssignmentExprent findResourceDef(VarExprent var, Statement prevStatement) {
+    for (Exprent exp : prevStatement.getExprents()) {
+      if (exp.type == Exprent.EXPRENT_ASSIGNMENT) {
+        AssignmentExprent ass = (AssignmentExprent)exp;
+        if (ass.getLeft().type == Exprent.EXPRENT_VAR) { // cannot use equals as var's varType may be unknown and not match
+          VarExprent left = (VarExprent)ass.getLeft();
+          if (left.getVarVersionPair().equals(var.getVarVersionPair())) {
+            return ass;
+          }
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private static boolean isCloseable(Exprent exp) {
+    if (exp.type == Exprent.EXPRENT_INVOCATION) {
+      InvocationExprent invocExp = (InvocationExprent)exp;
+      if (invocExp.getName().equals("close") && invocExp.getStringDescriptor().equals("()V")) {
+        if (invocExp.getInstance() != null && invocExp.getInstance().type == Exprent.EXPRENT_VAR) {
+          return DecompilerContext.getStructContext().instanceOf(invocExp.getClassname(), "java/lang/AutoCloseable");
+        }
+      }
+    }
+
+    return false;
+  }
+
+  private static void fixResourceAssignment(AssignmentExprent ass, Statement statement) {
+    if (statement.getExprents() != null) {
+      for (Exprent exp : statement.getExprents()) {
+        if (exp.type == Exprent.EXPRENT_ASSIGNMENT) {
+          AssignmentExprent toRemove = (AssignmentExprent)exp;
+          if (ass.getLeft().equals(toRemove.getLeft()) && !toRemove.getRight().getExprType().equals(VarType.VARTYPE_NULL)) {
+            ass.setRight(toRemove.getRight());
+            statement.getExprents().remove(toRemove);
+            break;
+          }
+        }
+      }
+    }
+  }
+
+  private static boolean removeRedundantThrow(BasicBlockStatement initBlock, CatchStatement catchStat) {
+    if (catchStat.getStats().size() > 1) {
+      boolean removed = false;
+      Statement temp = null;
+      int i = 1;
+      for (; i < catchStat.getStats().size(); ++i) {
+        temp = catchStat.getStats().get(i);
+
+        if (temp.type == Statement.TYPE_BASICBLOCK && temp.getExprents() != null) {
+          if (temp.getExprents().size() >= 2 && catchStat.getVars().get(i - 1).getVarType().value.equals("java/lang/Throwable")) {
+            if (temp.getExprents().get(temp.getExprents().size() - 1).type == Exprent.EXPRENT_EXIT) {
+              ExitExprent exitExprent = (ExitExprent)temp.getExprents().get(temp.getExprents().size() - 1);
+              if (exitExprent.getExitType() == ExitExprent.EXIT_THROW && exitExprent.getValue().equals(catchStat.getVars().get(i - 1))) {
+
+                catchStat.getExctStrings().remove(i - 1);
+                catchStat.getVars().remove(i - 1);
+                catchStat.getStats().remove(i);
+
+                for (StatEdge edge : temp.getAllPredecessorEdges()) {
+                  edge.getSource().removeSuccessor(edge);
+                }
+
+                for (StatEdge edge : temp.getAllSuccessorEdges()) {
+                  edge.getDestination().removePredecessor(edge);
+                }
+
+                removed = true;
+                break;
+              }
+            }
+          }
+        }
+      }
+
+      if (removed && temp.getExprents().get(temp.getExprents().size() - 2).type == Exprent.EXPRENT_ASSIGNMENT) {
+        AssignmentExprent assignmentExp = (AssignmentExprent)temp.getExprents().get(temp.getExprents().size() - 2);
+        if (assignmentExp.getLeft().getExprType().value.equals("java/lang/Throwable")) {
+          for (Exprent exprent : initBlock.getExprents()) {
+            if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {
+              AssignmentExprent toRemove = (AssignmentExprent)exprent;
+              if (toRemove.getLeft().equals(assignmentExp.getLeft())) {
+                initBlock.getExprents().remove(toRemove);
+                return true;
+              }
+            }
+          }
+        }
+      }
+    }
+    return false;
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
index 2883c91e705ea07717350f813e0bf41638fc0e09..0463df5e7ab8dd45414d555d8fcc1a823b3818b1 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
@@ -126,6 +126,13 @@ public class FlattenStatementsHelper {
           case Statement.TYPE_TRYCATCH:
             DirectNode firstnd = new DirectNode(DirectNode.NODE_TRY, stat, stat.id + "_try");
 
+            if (stat.type == Statement.TYPE_TRYCATCH) {
+              CatchStatement catchStat = (CatchStatement)stat;
+              if (catchStat.getTryType() == CatchStatement.RESOURCES) {
+                firstnd.exprents = catchStat.getResources();
+              }
+            }
+
             mapDestinationNodes.put(stat.id, new String[]{firstnd.id, null});
             graph.nodes.putWithKey(firstnd, firstnd.id);
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
index 7e41176d17729f6acdf5420c9ed98eb7ffb6f3ae..6e2b4d606a5572a619101cb5cd444bf040d53657 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
@@ -4,6 +4,8 @@ package org.jetbrains.java.decompiler.modules.decompiler.stats;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.util.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
 import org.jetbrains.java.decompiler.modules.decompiler.DecHelper;
@@ -14,12 +16,19 @@ import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 
 import java.util.ArrayList;
+import java.util.BitSet;
 import java.util.List;
 import java.util.Set;
 
 public final class CatchStatement extends Statement {
+  public static final int NORMAL = 0;
+  public static final int RESOURCES = 1;
+
   private final List<List<String>> exctstrings = new ArrayList<>();
   private final List<VarExprent> vars = new ArrayList<>();
+  private final List<Exprent> resources = new ArrayList<>();
+
+  private int tryType;
 
   // *****************************************************************************
   // constructors
@@ -27,6 +36,7 @@ public final class CatchStatement extends Statement {
 
   private CatchStatement() {
     type = TYPE_TRYCATCH;
+    tryType = NORMAL;
   }
 
   private CatchStatement(Statement head, Statement next, Set<Statement> setHandlers) {
@@ -141,8 +151,25 @@ public final class CatchStatement extends Statement {
       tracer.incrementCurrentSourceLine();
     }
 
-    buf.appendIndent(indent).append("try {").appendLineSeparator();
-    tracer.incrementCurrentSourceLine();
+    if (tryType == NORMAL) {
+      buf.appendIndent(indent).append("try {").appendLineSeparator();
+      tracer.incrementCurrentSourceLine();
+    }
+    else {
+      buf.appendIndent(indent).append("try (");
+
+      if (resources.size() > 1) {
+        buf.appendLineSeparator();
+        tracer.incrementCurrentSourceLine();
+        buf.append(ExprProcessor.listToJava(resources, indent + 1, tracer));
+        buf.appendIndent(indent);
+      }
+      else {
+        buf.append(resources.get(0).toJava(indent + 1, tracer));
+      }
+      buf.append(") {").appendLineSeparator();
+      tracer.incrementCurrentSourceLine();
+    }
 
     buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));
     buf.appendIndent(indent).append("}");
@@ -179,6 +206,15 @@ public final class CatchStatement extends Statement {
     return buf;
   }
 
+  public List<Object> getSequentialObjects() {
+
+    List<Object> lst = new ArrayList<>(resources);
+    lst.addAll(stats);
+    lst.addAll(vars);
+
+    return lst;
+  }
+
   @Override
   public Statement getSimpleCopy() {
     CatchStatement cs = new CatchStatement();
@@ -193,11 +229,35 @@ public final class CatchStatement extends Statement {
     return cs;
   }
 
+  public void getOffset(BitSet values) {
+    super.getOffset(values);
+
+    for (Exprent exp : this.getResources()) {
+      exp.getBytecodeRange(values);
+    }
+  }
+
   // *****************************************************************************
   // getter and setter methods
   // *****************************************************************************
 
+  public List<List<String>> getExctStrings() {
+    return exctstrings;
+  }
+
   public List<VarExprent> getVars() {
     return vars;
   }
+
+  public int getTryType() {
+    return tryType;
+  }
+
+  public void setTryType(int tryType) {
+    this.tryType = tryType;
+  }
+
+  public List<Exprent> getResources() {
+    return resources;
+  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 20651b7d66ad24404c15378da80bbd47e4178e0f..0f7ca6c558a05e02ea98bc17dca37a2d2e119640 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -113,7 +113,11 @@ public class VarDefinitionHelper {
         lstVars = ((CatchAllStatement)st).getVars();
       }
       else if (st.type == Statement.TYPE_TRYCATCH) {
-        lstVars = ((CatchStatement)st).getVars();
+        lstVars = new ArrayList<>(((CatchStatement)st).getVars());
+        // resource vars must also be included
+        for (Exprent exp : ((CatchStatement)st).getResources()) {
+          lstVars.add((VarExprent)((AssignmentExprent)exp).getLeft());
+        }
       }
 
       if (lstVars != null) {
diff --git a/test/org/jetbrains/java/decompiler/SingleClassesTest.java b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
index b17be32cc74e95701a299fc031e1daa93e49eb5f..9e5ff7e2a47d4853c45bc76d4a09d7cb1a8a307d 100644
--- a/test/org/jetbrains/java/decompiler/SingleClassesTest.java
+++ b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
@@ -120,4 +120,13 @@ public class SingleClassesTest extends SingleClassesTestBase {
   @Test public void testRecordVararg() { doTest("records/TestRecordVararg"); }
   @Test public void testRecordGenericVararg() { doTest("records/TestRecordGenericVararg"); }
   @Test public void testRecordAnno() { doTest("records/TestRecordAnno"); }
+  @Test public void testTryWithResources() { doTest("pkg/TestTryWithResources"); }
+
+  @Test public void testTryWithResourcesCatchFinallyJ16() { doTest("java16/TestTryWithResourcesCatchFinallyJ16"); }
+  @Test public void testTryWithResourcesCatchJ16() { doTest("java16/TestTryWithResourcesCatchJ16"); }
+  @Test public void testTryWithResourcesJ16() { doTest("java16/TestTryWithResourcesJ16"); }
+  @Test public void testTryWithResourcesMultiJ16() { doTest("java16/TestTryWithResourcesMultiJ16"); }
+  @Test public void testTryWithResourcesNestedJ16() { doTest("java16/TestTryWithResourcesNestedJ16"); }
+  @Test public void testTryWithResourcesNullJ16() { doTest("java16/TestTryWithResourcesNullJ16"); }
+  @Test public void testTryWithResourcesOuterJ16() { doTest("java16/TestTryWithResourcesOuterJ16"); }
 }
diff --git a/testData/classes/java16/TestTryWithResourcesCatchFinallyJ16.class b/testData/classes/java16/TestTryWithResourcesCatchFinallyJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..973201f4f3ae7ef45fb21902ea037640ff6bfc8a
GIT binary patch
literal 1686
zcmbu9T~iZD6o%i1Bts^{hd^SYi{Sb}0>LOMvc!*FP~5d5u$zFjm&2qNMu(Zy%tYlE
zd8=Mv)o#^#=f(b`y;*&`6Jpe@TC29G^r5@YIsKlePtRZf{Qf6^o499U0D}e+7LrH_
zj6JrW+7-|C_bQvakEIg}q;9&t8{ZZfES7c*3<;djPVLzBDs{*9eHofCV5$@u?iOo$
z-wi73t|zOd9kn}bVFaTB312>E(#c|}<E4+P$D!-*Rh8cf3*$;i((!^w8kiKA_^7F|
z9|q6tT~C^rK+eKR<OPQ9X0zUIwL%$1vMG@73ec&05!8{!DV#R&jfE+k`J~qRVHC>)
zmKd}tF54?$i@IW}llDP%2s4!Rqx8JM#J4zS;Jk$kxOgm(_4c_77%dg-`OMcZs9UQ-
zSrnM+N3{{e>p|OZ-h1xIR_q48iCN59m{&kXb-H?NJ5L&+?U29%E*Yp;xQr_Tv#lq4
zm4=MsMtJzhjrV_%QP2(@8Lio|v%l{8w&xu_xU$6ibXZO-1<rkbQJu2;@3qPcTML?W
z9<8~)+-M){%CMm>Kw!KUIJUQAhpw7;7ZdTm8wr$ZUnxf&5K}dAMV(e6&VSV*c;s~N
zVpL~+flDR(jT-_ZpEz=TSc7|Lx3o?J-wRm%=mmz9jP<tf2$;PKU@2x@b5sWk6u*M-
zC6yOvc|8MsVn70H8>Bcca#o=gw8^<Q5U=>p0IqUW+hF@&<7jmpa2-pW3EV)2BZI{f
z2I&cG{Q=|G`8P;EEFZyo#9{0OvKt+nSxGDu5=Y1`ynT(r`1BFZzQBy~EPb4htt5{p
zh2+~;%$nx=%&J$#M>0hV_TD0Y%C2%;qz+|QaaY?xt$PW>TubxMWPFAh()1r;nWK!z
z(8prj2<~vcN?W7d#F(ygj%d<2gJpcDDI~Chs)n}Jt(}$f8+D7--{vXHFy8Y3eytV^
z+%ZT?7?^lZo9HcZL9ZHrLp(4ryU7K`^M@Wob%J8JJvV=Zau?t`%yi%tHp=fX{=Yz`
zcvOxuPGg#%2?erD1PWvs_c`8RNy^^GPuli_oS?KxjZtMNBTrBTMr2uhj&XUyFEA>P
zpJ^MsD%CIwWC|C%AeT8i2D#k>x&1lF+?OCT{|RzHeQXF&b@DAXqw4VVaWlT;q`#Y|
Yw76WysV5}e6{31cJ&jrZ)^z0E5BqIMN&o-=

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesCatchJ16.class b/testData/classes/java16/TestTryWithResourcesCatchJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..74285ccebf43363135c65ff176f0057365d67a3d
GIT binary patch
literal 1889
zcmah~%~IP|7(LfEmVaa%Fwi)0_%Uf>8#{JdNK+h06B1e&;&y5enNBAQA*-OoNFG^k
zlYO6}FTkdYrVBFD&a^ugeUNPW1lg3HE7__Eon#nG_vgFcJ?DJq6My~l+aCb#U^{^j
z!U`fP#t;>_@KpO=t9CSNzxw6gQ$u$JqIXQobk_yKh2pM)n81V=)OXEJwW({CWjF~a
zNXQgP?iO~uebcUPnjNEF+?Bg272`+?L@eVulTH<iew24r({)U1zb@k@R7^@BV|vH#
z849KZGXG&}9XR$6+Fr*<AcGkdAK;=uN^7^9{chJWdOf2paB%>@OC6jb4h5G4u8e|f
z*zTs?x7rV%>qgf#Z7YE+aw@J!2<a|SxlLEopS2uK=bdwySFoTWk41s`?z8=B%jmf+
z=fz{wJ^0$_*?mVhdK;RnA8g;eMd@_M&|E`c@oi0f@}m;g<M<HQ6kJzPK=Di^nlE~;
zamWJLeM&bS$orL#k9QnWyCswrR8-tRb*LFjFcKr6c#Jw0%TU;odfXgFdRhf4aDT&Y
z6L)&Yw2VgoaL;gBQg(sK9b4BryP9Ll`Cu{P9+*9W{LcF%sWY=n$q1$AJBI-NM+*VL
zyXFF>(n#lOC6j%}4T149fm}~{RePj$J%9>66HrI%E)bJ2Hv5)NtH~jiIA`3gK<u;f
z@B(4-$Nfa08Tlugo&h9SfrWQj<Awx-1sW>EHUt}oFc9VQBhIRP3%Oc)1@V%D5I*Kp
zZi6kd%%|!HU<J206Ziy4KIP%p2s0H>`yI+RORo@rR6d6Kn2!rbm~Qy*<Z7gnjT~dT
z^5+p^GUD<}o{O_br)6j15?dg{EZ0$DM})om^N4XJ&c6iXl8lUVKgEb7&8HIfxQDHT
z2zO?28=n&S5@)NZdqiskyhO)u&l(Z0GvhL%r%cAL(42z13K<FonNz+a!4em|RpkxD
zeFfPF&)y3-|IO@@^Ga#y7_$SyCz$uiW*g-bOumzNl&NNT#bs6`?-4JP&ROCUEWjk=
zq&yQS6LFQ}8m35KCLkWgwE^+k2=SGG_{!VFXU-E(zK8gIZ1}|%Qs5|wKMAk>imRbx
zlsp9*6<P8hL!xqmMUGkd94mf;j6YFV$Fh;^80(*n&;ZE>57P~$+)qex80PQ@362<2
z%Kgmxr}?Rs!W2kc(hjkr>m=_xW0jQ$<q9F^RX$A_r!dbm3p_Q;*sF}r<1QAlNrATM
zn-+@rmf576ms!0u$I>xjMk#d61CB^65bnu9xDZc0WR{TUo!f|=GV#DD^v%#b{Ac8w
zN3IRs6MKUY-BVLiQJ&{loKM*^YrIP~Vtm*$zi=|zbTtp=j2{$0iVq-t&S+`KEPr2k
HC%66u&8}Wc

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesJ16.class b/testData/classes/java16/TestTryWithResourcesJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..ac2bbe8cd1ce5179b4998b3711baa5adf80069d7
GIT binary patch
literal 1216
zcmah|O;giQ6g`iIhPL6O1<JP~_|XC-;=+ZX8%GvSsWY|%<1(aA2-KvLq>8`Dt!!XM
zX4Dl6|B)N<yrjg6sGVtE-n-}Cd(OEp-+p}h3}6Efvgkufhi0H3X@QXg>#b$BEO*a*
zv3nrxP$0eGxK8*)AXO@F>lhHoN1#sVw9L9~xvuoH(2-Roa*UR$QQYy&O{XQ-%iAhC
zXkZA#0-7t2SahsZj!{vodgwdu-nzo&4HOiSe!JxbQpcFU=r2x<ecyX$?Y3kVqbM4f
zz@)&S)oj)~?Y1w2KsE&?y9A=rNk+tD8Z$a(4b0(&z)bsa&uqvbZ20eYoN)i847`qS
z%i#IiL&~;&X@yc?@v5Gfc(43*>U!!m2_CLGuB>(5>`K3(cnTD%o^7?ZE#Fc5?x7a$
zJAuGl^&b>e(U9x}^dNSbR$SlvHGLKs`rUULQx7fsaLZ~(U3DxA7`>wr$UZx=Wjk~{
zH_)+4LcQUd7jAkTx0zrB1{9&qj%zcu9+{;^EHL{Q8&_35+`=?(nfhtqWRd3cCU+)R
z!L@(s6ylgKeVFG{g@Fvy03!xq0gK!T+(wQlm3)R2O97=b=&zPfk=a@~fw9BK$Onwq
z;x+e3t4wJp7_WReW?qJOa9rIS5}M<hiux6!Iypww9UUYhhkJZe{pX3v;0EsCZX}`9
zWx~G1l*p(|lnL#EY5b0+bu8(;#zM#F1y?OO;z4w(e`nGPlav<~{>?<vSGG`+Doe{J
znCj{|$9$}1s<v{D!nL~6EKy|r89K9YMOU7F78qBm^K3kp=t@)5rLIb%t8!IW@lRd3
q|Lf{g-&l84k7=Tsf97&jAGztB^+d#}7=scfnJ$xFv+hTkYd-;F;NAoP

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesMultiJ16.class b/testData/classes/java16/TestTryWithResourcesMultiJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..ee74613401d34a2f095243db517b5c1b998fcd36
GIT binary patch
literal 1093
zcmah}+fLg+5IvhXIB^^<0a`+#<yJ_55a^wYs#X=KQ~@Lsf%<3?ml#|-vYkS|h-Y4c
zRHX9WKjNkItc_@RX(MH4cjlZkJ2NZ)`u*c4fHf>@h#{^*(UCxxK<|<9%_!N1b6DCr
zI5KO2K-Ze(SixI?c)qZwA}P=pf?9!Pmnt>GaZFEx3QbC+8O@i&xaF2MEZba_q>Mne
z)4A_ifn@2>B(+yZAF=|9W1ceOK)w)3g!iZfp5+{_CNUt8XqdL`O5Ot<4>3f~iIfr;
zyv^E4DeOt)u#QKvv_#EzeN)A#K>yz=s}0XRF%E1~!w8<}7{j<g#;DgTt!C3Rec!AL
z40Vd%F<6<r{IH5CfwAWCVX12RLDl=dZv~BA(|225&Gffgc3^#4dd2EKxOLvNr))Xq
zcI)eb=~ZQ7wx;aX413S;EP1|lDnY~Y1t!Y>6J8Za1xy?!;<&<wc<kc6F+?3FR`sKi
zu?rEPbB>HFUpO>@?t5(dGnK%o9d8-U@O~<u3+SCA70}jCYi2XBT*p_zdZRA$8Eo#{
zMTn||eUVQ?VEkVlTafY?$0VPq{Kdc_qKoTOo=UWWHZgkvaUO=Jxymq*#0*zG0w9k9
zPXe<@Q-ox(h&Yiz<r3=WxeKJWE}_d!_x5}nJ^RIMe;b3vHgabeT2Z2nzLLl(xkMX}
zbIKKA6K5EdaN0C6Ifaqp)j1SoF^Va^r)j1v(x$MCceL-Zj*ql)Mt})k6VQlG^DXP-
zWXRHp%@D0&7u{hQv!UV)<}goY3Y*ki2zyewEsce+AB!w;Nfw3V4TTgHlPaF6P*vFp
p6(cuHnCSG<7Y35oh;4)behE4NQB=LA@Cynnv@iL8&3z1S{s5w`<v9QV

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesNestedJ16.class b/testData/classes/java16/TestTryWithResourcesNestedJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..011b0c15774f40c3b1ad744772d6d2be04f12b44
GIT binary patch
literal 2171
zcmbtVU2GIp7(I9YW`Cybc1znGs9+1NTcBMF;?K75Vyvl_f^IDuO~`b2+zxDKmz`Om
zCOm1<s1F)>BQzn=ghzr8#Y$om6JCrynCPo-CXH_<_JJ4i+}YXb7J-`3v~#|>-?`_0
z_ulhOfBfgW?*UBUcpL!)6@*lT5fMn9(?8I&W!)-ePtBh*3XVWz!n921gg`JeJf|Qk
z(CL!uj#<v;3%X?)wKx>Sr9^_+%(R;~E7?i2Y>W@j$!wd7c611YEaMVIcV&hfEO)8A
zQ!}m7xa4)JNXbINg>uC<6zme{+Nx=Gp;o!5&zFrjy3nJd7iobuy;#iGtJRue+eT3!
z?G@lk`!iTa47;&ML7$4Juy@;D^Gmj4EOLvLI*aS}H*lJDIjqjm7g^oY=vOeHVm}Tv
ztKueGI08yl&L~^lXl6<t*N{Me^?WHiYuL_gZRw2ZEWByhm3pmU*fSh6im#15Pxi}|
zq9M>RZCb`meR1BX&B|>Gq^2tcy*#JaO!@8&hMWb{7T7<%qw=^w+~G2fr39jO<HC+|
z1C3p_UL)B}!jY|TjN9_2vC#K<rvmN%5xIBFOUOHV;rvOx>XxX0ds16%z&c*JR4}TJ
zS+Q&dFSQ)t)G0qh_iR-=X<B-@yu_J#_q^mv0t1gd$x*o``Y}jb%by@<B}DjqhHqJ-
zAcha#hPcHbfDE594MZ`_r`jOkAP(_O;4l(oadM!SVo{E*+=24Wq1%X^Yz8yUAQ$qZ
z@ZnXcXSDDtk~g5`B3`8C6fL4DtLWAu>srXmhP_CYJS`%#;q?(Wna+h8ftn*rs&s3i
zb&6BAd!~U2a->4{$oegoIK<MAvOkU?hvURPOyLb;9&h7aVhSZ##3~$IB*yR&J|%vJ
z&+#QO=pIUr{R+gHO>l-vl{PB3Q@exeZPZLsRi#!Z)e_W5Q6-LRRFDUGg2y_<RvE!4
zZ=esa^Ylj%BI^R4WfY|H6^t>GH?`s&xQvcaU*I{8evRaPzC;uZDmbP<@qZx{bls-}
zhaSu^<EEqc5O~$2{a0d(GwE`o2yd5qkid^*3!#x!?y=GrSZRp(BL8wty99&Wp~}o=
z(-Kc?mv11Av+o8va#1hVqC1#~Jle^f6Z2v%_E>9?MU%NR;$E!9A8j~N=scI6@M0}N
z8zvuW!#ocpkGJ>-TH-9t(*=|Exj;<eGL|{Mj89xl(H>Vheht_06)}dJSYv(-cU+9&
zE`H+p&-ewu5`o{b!RH44bg^OM53!eHJ)GUk71CT)V`aN(<2`hiMjQ9xH2)vuiSH55
zl3yb4GWOwPe({%yUl6bGqjHrRH!*-!+Io%n1Mw~nu!<h8J%~T3yg~en_&2{94{HP6
zZ-W)T4Sw_6VAF4d&6YO!7U?H!gDF}(@qc>3CGOY|Ev!d%g-hAi8sof&04DwgvyhUM

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesNullJ16.class b/testData/classes/java16/TestTryWithResourcesNullJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..180ac7fc08bcf1cebe8b35b5983dfdddd2e7ce81
GIT binary patch
literal 1528
zcmc(fOH<QO7>3_d(xxo|O3ST^ToqfSbYMmoTwLhLj83Ve>A*U)M+n5Elcb8j$Tb_B
zaU9vP@E@@e-;-YG3RyT~JIQx0-{t+DoaEQ<?>_--VKt2y26Si!;z$T&j;&8t*|FTi
z^4o)BSq}vgTefS5&jkhw#l19=Na;u$7=$4(8o9SZ+bNrM%XOtMpt<stVPl12<tCXK
z`nG$xslta1jHpuay5j{>$EZN=#<6zfd!MZXN2ZZM&cGPP1%|9f!)!I1z6=7{5SS|T
zrS3&+7WZ^a3d}Z74$Czegf;)mz8xODmx0&v>oTae9Oup2GfI5vHKf2u#dc-2_3=RZ
zHC0j|Tk-0avuF9Xns*kp@W>7X<|}{6yUD~M%MwdRpY4@*Y)4X<fF5)K<=W!=sj1Kp
z^b{CwZ+0WuyBS*blU=JBsnPLBz=&{lTm;guPV2H6+MXNeC<r|0->!P$j@NP<Js<ij
zkyTy_WwIk{T_B~_cUw+q)5naEDfI$#x4>Lg#W0Tvo+I_sz$c3Y?^B$WX$5V3`5VL;
z2QlP%SKEM&d%PQM2i(UrXH<_Fda2+av~k*^*j+h?zQ1ybISz)tB46b=+a3>YXr;V%
zj%?}Ti~%vG&GP6>GT{vEKvZxdN|fSmn)`$FNTI;eO28a_Vpzf~N2-TnM~WKFV}X(u
zxmt#H%`m<y6FMI1JjX&u=9;;*-Vzt0RsD)VOAJyl9`h<vN(4kaWr+lLYMq`$wWL}r
zU1E^~wl>XnE|F_bjE#6+%g5PVUc0zM`x@ICX2Tgavq%LQR$Iq5?F;PSHEkQm68*rp
zFvb;yD}@~6#u%BU|2QK?VDgbFJj?7N#SWG`px*UB)q0?6eV|MvubHTyN|zPCF@3C(
zU0lg4#NONvQ{YJt;o1#CQH>79zeT9s3E=`y092oZlp=^>9^X9w>$KanCJ%BKpN7@{
Ljc<iwV<`OrNJ9o7

literal 0
HcmV?d00001

diff --git a/testData/classes/java16/TestTryWithResourcesOuterJ16.class b/testData/classes/java16/TestTryWithResourcesOuterJ16.class
new file mode 100644
index 0000000000000000000000000000000000000000..31b449e5f5234fbf4e01fbe4634ac325d09915bc
GIT binary patch
literal 4033
zcmdT{-%}G;6#g!3viSunF_xeN0!0DA2m)$?ibdmyA!tKEr*_JcY#|a8CfQW`7x`LW
zaHh`GHy`@anf^Dvlz#W_x-1mi(2kwzn7w=Vo^$Rw-}&yjhhKjG>1P15xD!Gf+I46V
z_}~{f{>1p+NL7sLMrvvOiCMG+{Ilh1*}5*!K0LCbBOq`>2{o;9B~>UI)v8$!K}SfM
z2y=Bfr`F50RJL3(Gb1Z<wIhN~923y0=5rc7IXq%ZsjUiDy<FYMNVyXcbV)~i#Y(MV
z>NqJ7-ScUAvtD~<tXIqsqBs@7XXqB_FiNFDb9=jPHX3G0pxbdknRYdlA3Zp&<4gp-
zNC@<AZ*8QO&4#sH|6#RkZGLGsYR!7lY%Db`v%WAf!`O>;)38i|!Gl5B-g_~~=;#;d
z^2WYeFVj*8eFz0G$e=dON~I>}LlK<CIevL2MFe7ApB*?PaD6yI%;sw)${fp;t7g9W
zblt2kOANSKu2wWED@MI6=gvpX+AKE&26BHFUWS$}hR@+UCQ6`lf8qr6hMivK;E;HU
ze8Dn`TZ_iF+FHl7K*SrrK<M`KqPcCAYt@F1D+0aV<$TS`)|%ClD<cq)4rQCwqCil-
zE;cJxnR!q!)ybQEF537Kc(T)G2}yT%$zv}pjpX?=OA`W~*`%{U!FXzNMQtYEz27f+
zzE3fhf})2cwLo&2Mn6QH3o=S1(Zj<f|AoO!!_VgkXDN<?qi^&T#7n-kVU$m~3<PnW
z&xkF6F^qF2aDgV;l=5$Arz9}_8v3L2uMk`u%a83KvO4}2gX23m{sL#x8YfYE5=r~w
zTHLpTSX_Jal19Qfj?+9nNep3_W4qeCM;Q%s`wmKUQsx+?IxxjI=}<rAxT)iid`saX
z9Sicy1SV<sl3Lexsix`Z(J`e%=YI$t(OpL5^M2(wwGenm)fuX4G<KQ4t8S#faz#cu
zIeLBv@uP+rp!40_B!K}2x<AY)?ZyzmDax>d@O^^My)Y-;FejZb{eKR#`(K5bejldT
zBC-L7X}Jk~jXs&#WPXf^O#AHYb`9*{^SJLV&dOvCzd$1Gm(!EZG?Lci{<tpl?0*y2
zq@1SMkdOqBa`rSL)#83B=OZ6920qA4MhX5bZg7m@9v*W17A0)Bz>OkAA5SyiXIP&T
z)aqjq?Wb;%+6n3;sg*#3a7!RZX_+y(Kw2(ewj926VI3Ln*{+ylBCtzCeh)|b6o2|0
z{&Y$*xvX;5ye!Honspvx;t-}?BhzlUDX9Hr3T*t-zVVNig5H)=AZq}~<sfg4E*{+&
z>p>5}?j^{BtP>acevg&nA=es&`x8mST#IS=znla+4U<g6C8lATX_(<@xXd(MVH&P7
z4KqwbnrWD38Zw_s8g9C2xXaU^lWC?~kenNa<w%`{R;x>EH<HF0)2&Lhyh)}w3uBH5
zM)3e&sY+zuP<92nPTVD9Zt`B5r_3$t-lq0Ezh<d5$EtNlVQ$}8rdxqbw*o!(+*prg
z-5EM~H@&~K_E!^mn|UkFf~q*JUTj~u0M9u9uXzFfNZ57~qkjI*5r-7VFd3QUn8SS(
zINI2rC91#zpE*h_^8U|rZHbzTl)q1n9Pfh%9$eR4T-RJ&R}bRa|6kxb@8WtWagT`W
z5n3sYFdYQ<!^B-CxGQvZm0I$8eME3q3GUaV>|+vlg~a{F18_^k{f7WA9f`QNT!53L
zi|okqUgEaedlFgprZL&9atyPzksV2FTs0vFo6;Z)L53*J5*>NWZJG|KMrn;m8uV$M
zC7{Tb#Gq`6(rYBE=^_|pX|Nkp`s<Q4?~qkCs|9)VkKC+g6?XiC+0%{K4Tk=XO~qa-
t+a~|WWD6@h{%Z`NjbrdVa6fY5?fN&B-=}OL*V~}u?VeG=Vkb4Te*jNfR__1+

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestTryWithResources.class b/testData/classes/pkg/TestTryWithResources.class
new file mode 100644
index 0000000000000000000000000000000000000000..dba49d9ec1c81714d3b6d7debe6db5697fc5a9bc
GIT binary patch
literal 2427
zcmc&#-%nd*7=BJ^d&;4Ou53yN9fLWAwzLB_b?tufW8EtKfwY4V7n1^KPzG(&9^AMv
zOEi%S6TL9;lAFbGVZ0zwoW{u=i8C=#{}2BJ@%he=wwNth%o0gB?|I+v{hsfApXdEf
zpZ@*h&j8M2R>3QHUB(+O3@8{xP(cV`1w)9q5S4Mxg<%&)6pZ4$cwCV2rUDP%lJT~T
zi!x#g;<%*XGOmaR*RRUBCc$~BSSo5)B(w|+&PuRPl$TTq9jRhT&1|eMsMUO7VT}=o
zrq;A!37(u*SiGAqRP?xvF&;!LGhsx=xcNHDV<jlL@<w%0O%w%&KTnK&b#tz$t<0!3
zeWeyzEqqXL<5hG?=&IaZjy@}i<z=#Y853?y;<}848#i!MM$(OUFvYT`$MQENcm-B;
ztx#Hy=Co?Dv@F4v&vH4DOmWwk8!4pS$cVE#8@c(FYWbdM(~T^qC3NdcB~^>wnn~t1
zOIqRn_4|uzMJtv|*2ZEvn#?vuyNo>y-(j!OY(*_)^$jxKbz=rOGUG-bw=4j?$|iuO
z+OrF*>Y_$Ej$#TDbDK3yUAHhq5v9t8#%9$5qaBT&Ce{kInuNAxRkNs;&_9rBWEc#^
z2aS-?Z7MFoZJeripAur0$pX0@IFgxUrvG{M@n8=RZZ0@z9&NH(Kh`3wkxO8io2Luf
ziiG$xDt_<zO;~7RGjSY?YvmdT&r?`h%579CRkc=Amq=_gYF+)fxB$jjlq?`o7Q1OL
zsrQaBov_-m67>_!%IdotQ(*PW^d=mZXs2?lh_^3^KG=B6#h)FLxDkB%=>=#dT1W7E
zNV|NIaFS1_9&AG^x~){{B%=<lm3=l}%O31|a6E={N=gNNvf~L{^DVyC+`QeV<o3`u
z7d*gZ=m4F;J-BypF&zr;p?wGE41X{kPKEa~ObRgRgc0<`>>)p4nI?<K(EbkWQ@fD)
zDH`U7$^$RX@{$@h$x>!8i+TE!ysE+nR<Vu_(|XynXyz0Vpzmtu{tg`>NxMqC5{{vV
ztCyi1@(7!ZfXodNAFc!+ll(tquH9U)7L}Gmog$3O=mmK?UFYd9^3+PmUtff$mM1v&
z7{0WWAwQjS;R8$!kq|n^cW^CcA2JEKU_>G@yWgJi+xKG*rUn|RzL;~!?=-j*seZ>k
z$xSpAh+7Jb7-WZZ1!D5QC2)oOu7(7D+0?+zPyAJklf?*s0`jK4%{K4ooO>91AHv_l
zr}#`~`vJC1`;hT(u#0c$Z{sTnA2`4-x>mwkT1C*tmE-hJAWR$K)Q)mq^L)QeyG{F$
z_JDLh<pc}uK7{X(rI`}R=&Oq)6uhA;=!Mfz&|I#kP)A!`c4QcD(%lP}sk^B6=pF_v
z?fWh5ZQZ8!fBw(f@4%Jj<w?KP8EAju8Svr(KB9)genKTb#~1igpM@<vGVRwS@H_l~
zpXfj0bO;~#4ZrI%A*?kMF|>1~hkk(baEkNL%XtWJ9(sx2$CFOuW7;kB6RC$t{lqzg
dKk%A9AFSYI%?A}fGa+vLe;E{s^?=iM_8)B@@HPMd

literal 0
HcmV?d00001

diff --git a/testData/results/TestTryWithResources.dec b/testData/results/TestTryWithResources.dec
new file mode 100644
index 0000000000000000000000000000000000000000..419b0df6fc1731027c783900f7b8e407826a6f5e
--- /dev/null
+++ b/testData/results/TestTryWithResources.dec
@@ -0,0 +1,176 @@
+package pkg;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+
+public class TestTryWithResources {
+   public static void test1() {
+      try (FileSystem var0 = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI())) {// 13
+         var0.getPath("PATH", "TO", "FILE");// 14
+      } catch (IOException | URISyntaxException var13) {// 16
+         ;
+      }
+
+   }// 17
+
+   public static void test2() {
+      try (
+         FileSystem var0 = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI());// 20
+         InputStream var2 = Files.newInputStream(var0.getPath("PATH", "TO", "FILE"));// 21
+      ) {
+         var2.read();// 22
+      } catch (IOException | URISyntaxException var32) {// 24
+         ;
+      }
+
+   }// 25
+
+   public static void test3() {
+      try (FileSystem var0 = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI())) {// 28
+         try (InputStream var2 = Files.newInputStream(var0.getPath("PATH", "TO", "FILE"))) {// 29
+            var2.read();// 30
+         } catch (IOException var34) {// 32
+            ;
+         } catch (Exception var35) {// 33
+            ;
+         }
+      } catch (IOException | URISyntaxException var38) {// 35
+         ;
+      }
+
+   }// 36
+}
+
+class 'pkg/TestTryWithResources' {
+   method 'test1 ()V' {
+      0      11
+      1      11
+      2      11
+      3      11
+      4      11
+      5      11
+      6      11
+      7      11
+      8      11
+      9      11
+      a      11
+      b      11
+      c      11
+      d      11
+      10      12
+      11      12
+      12      12
+      19      12
+      1a      12
+      1e      12
+      1f      12
+      21      12
+      22      12
+      23      12
+      6d      13
+      6e      17
+   }
+
+   method 'test2 ()V' {
+      0      21
+      1      21
+      2      21
+      3      21
+      4      21
+      5      21
+      6      21
+      7      21
+      8      21
+      9      21
+      a      21
+      b      21
+      c      21
+      d      21
+      10      22
+      11      22
+      12      22
+      19      22
+      1a      22
+      1e      22
+      1f      22
+      21      22
+      22      22
+      23      22
+      28      22
+      29      22
+      2a      22
+      2b      22
+      2e      24
+      2f      24
+      30      24
+      31      24
+      c9      25
+      ca      29
+   }
+
+   method 'test3 ()V' {
+      0      32
+      1      32
+      2      32
+      3      32
+      4      32
+      5      32
+      6      32
+      7      32
+      8      32
+      9      32
+      a      32
+      b      32
+      c      32
+      d      32
+      10      33
+      11      33
+      12      33
+      19      33
+      1a      33
+      1e      33
+      1f      33
+      21      33
+      22      33
+      23      33
+      28      33
+      29      33
+      2a      33
+      2b      33
+      2e      34
+      2f      34
+      30      34
+      31      34
+      82      35
+      86      37
+      d1      40
+      d2      44
+   }
+}
+
+Lines mapping:
+13 <-> 12
+14 <-> 13
+16 <-> 14
+17 <-> 18
+20 <-> 22
+21 <-> 23
+22 <-> 25
+24 <-> 26
+25 <-> 30
+28 <-> 33
+29 <-> 34
+30 <-> 35
+32 <-> 36
+33 <-> 38
+35 <-> 41
+36 <-> 45
+Not mapped:
+15
+23
+31
+34
diff --git a/testData/results/TestTryWithResourcesCatchFinallyJ16.dec b/testData/results/TestTryWithResourcesCatchFinallyJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..fd170b1ef972a94d4edae3b5549027589c39184a
--- /dev/null
+++ b/testData/results/TestTryWithResourcesCatchFinallyJ16.dec
@@ -0,0 +1,98 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesCatchFinallyJ16 {
+   public void test(File file) {
+      try (Scanner scanner = new Scanner(file)) {// 9
+         scanner.next();// 10
+      } catch (FileNotFoundException var12) {// 11
+         var12.printStackTrace();// 12
+      } finally {
+         System.out.println("Hello");// 14
+      }
+
+   }// 16
+
+   public void testFunc(File file) {
+      try (Scanner scanner = this.create(file)) {// 19
+         scanner.next();// 20
+      } catch (FileNotFoundException var12) {// 21
+         var12.printStackTrace();// 22
+      } finally {
+         System.out.println("Hello");// 24
+      }
+
+   }// 26
+
+   private Scanner create(File file) throws FileNotFoundException {
+      return new Scanner(file);// 29
+   }
+}
+
+class 'pkg/TestTryWithResourcesCatchFinallyJ16' {
+   method 'test (Ljava/io/File;)V' {
+      4      8
+      8      8
+      9      9
+      a      9
+      b      9
+      c      9
+      32      10
+      34      11
+      44      13
+      45      13
+      46      13
+      47      13
+      48      13
+      49      13
+      4f      16
+   }
+
+   method 'testFunc (Ljava/io/File;)V' {
+      0      19
+      1      19
+      2      19
+      3      19
+      4      19
+      5      19
+      6      20
+      7      20
+      8      20
+      9      20
+      37      21
+      39      22
+      49      24
+      4a      24
+      4b      24
+      4c      24
+      4d      24
+      4e      24
+      54      27
+   }
+
+   method 'create (Ljava/io/File;)Ljava/util/Scanner;' {
+      4      30
+      8      30
+   }
+}
+
+Lines mapping:
+9 <-> 9
+10 <-> 10
+11 <-> 11
+12 <-> 12
+14 <-> 14
+16 <-> 17
+19 <-> 20
+20 <-> 21
+21 <-> 22
+22 <-> 23
+24 <-> 25
+26 <-> 28
+29 <-> 31
+Not mapped:
+15
+25
diff --git a/testData/results/TestTryWithResourcesCatchJ16.dec b/testData/results/TestTryWithResourcesCatchJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..e8f8faa5772bbf5d050ff6713bc1c1ba00f17a77
--- /dev/null
+++ b/testData/results/TestTryWithResourcesCatchJ16.dec
@@ -0,0 +1,161 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesCatchJ16 {
+   public void test(File file) {
+      try (Scanner scanner = new Scanner(file)) {// 9
+         scanner.next();// 10
+      } catch (FileNotFoundException var7) {// 11
+         var7.printStackTrace();// 12
+      }
+
+   }// 14
+
+   public void testFunc(File file) {
+      try (Scanner scanner = this.create(file)) {// 17
+         scanner.next();// 18
+      } catch (FileNotFoundException var7) {// 19
+         var7.printStackTrace();// 20
+      }
+
+   }// 22
+
+   public int test1(File file) {
+      int i = 0;// 25
+
+      try {
+         System.out.println((int)-1);// 28
+
+         try (Scanner scanner = this.create(file)) {// 30
+            scanner.next();// 31
+            ++i;// 32
+         }
+      } catch (Exception var8) {// 34
+         System.out.println((int)1);// 35
+      }
+
+      if (i == 0) {// 38
+         System.out.println((int)0);// 39
+      } else {
+         System.out.println((int)2);// 41
+      }
+
+      return i;// 44
+   }
+
+   private Scanner create(File file) throws FileNotFoundException {
+      return new Scanner(file);// 48
+   }
+}
+
+class 'pkg/TestTryWithResourcesCatchJ16' {
+   method 'test (Ljava/io/File;)V' {
+      4      8
+      8      8
+      9      9
+      a      9
+      b      9
+      c      9
+      2a      10
+      2c      11
+      2f      14
+   }
+
+   method 'testFunc (Ljava/io/File;)V' {
+      0      17
+      1      17
+      2      17
+      3      17
+      4      17
+      5      17
+      6      18
+      7      18
+      8      18
+      9      18
+      2f      19
+      31      20
+      34      23
+   }
+
+   method 'test1 (Ljava/io/File;)I' {
+      0      26
+      1      26
+      2      29
+      3      29
+      4      29
+      5      29
+      6      29
+      7      29
+      8      29
+      9      31
+      a      31
+      b      31
+      c      31
+      d      31
+      e      31
+      f      32
+      10      32
+      11      32
+      12      32
+      14      33
+      3e      35
+      3f      36
+      40      36
+      41      36
+      42      36
+      43      36
+      46      39
+      47      39
+      4a      40
+      4b      40
+      4c      40
+      4d      40
+      4e      40
+      4f      40
+      50      40
+      54      42
+      55      42
+      56      42
+      57      42
+      58      42
+      5b      45
+      5c      45
+   }
+
+   method 'create (Ljava/io/File;)Ljava/util/Scanner;' {
+      4      49
+      8      49
+   }
+}
+
+Lines mapping:
+9 <-> 9
+10 <-> 10
+11 <-> 11
+12 <-> 12
+14 <-> 15
+17 <-> 18
+18 <-> 19
+19 <-> 20
+20 <-> 21
+22 <-> 24
+25 <-> 27
+28 <-> 30
+30 <-> 32
+31 <-> 33
+32 <-> 34
+34 <-> 36
+35 <-> 37
+38 <-> 40
+39 <-> 41
+41 <-> 43
+44 <-> 46
+48 <-> 50
+Not mapped:
+13
+21
+33
+36
diff --git a/testData/results/TestTryWithResourcesJ16.dec b/testData/results/TestTryWithResourcesJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..20f3b8bfc673c8a93fa2f578d7d4775380417e3a
--- /dev/null
+++ b/testData/results/TestTryWithResourcesJ16.dec
@@ -0,0 +1,88 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesJ16 {
+   public void test(File file) throws FileNotFoundException {
+      try (Scanner scanner = new Scanner(file)) {
+         scanner.next();// 12
+      }
+
+   }// 11 13
+
+   public void testFunc(File file) throws FileNotFoundException {
+      try (Scanner scanner = this.create(file)) {// 17
+         scanner.next();// 18
+      }
+
+   }// 20
+
+   private Scanner create(File file) throws FileNotFoundException {
+      return new Scanner(file);// 23
+   }
+}
+
+class 'pkg/TestTryWithResourcesJ16' {
+   method 'test (Ljava/io/File;)V' {
+      4      8
+      8      8
+      9      9
+      a      9
+      b      9
+      c      9
+      12      12
+      13      12
+      14      12
+      15      12
+      16      12
+      17      12
+      18      12
+      19      12
+      1a      12
+      1b      12
+      1c      12
+      1d      12
+      1e      12
+      1f      12
+      20      12
+      21      12
+      22      12
+      23      12
+      24      12
+      25      12
+      26      12
+   }
+
+   method 'testFunc (Ljava/io/File;)V' {
+      0      15
+      1      15
+      2      15
+      3      15
+      4      15
+      5      15
+      6      16
+      7      16
+      8      16
+      9      16
+      2c      19
+   }
+
+   method 'create (Ljava/io/File;)Ljava/util/Scanner;' {
+      4      22
+      8      22
+   }
+}
+
+Lines mapping:
+11 <-> 13
+12 <-> 10
+13 <-> 13
+17 <-> 16
+18 <-> 17
+20 <-> 20
+23 <-> 23
+Not mapped:
+14
+19
diff --git a/testData/results/TestTryWithResourcesMultiJ16.dec b/testData/results/TestTryWithResourcesMultiJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..24231b4218afb5e4cb6ec56b328f6db1f6f49852
--- /dev/null
+++ b/testData/results/TestTryWithResourcesMultiJ16.dec
@@ -0,0 +1,65 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesMultiJ16 {
+   public void testMulti(File file) throws IOException {
+      try (
+         Scanner scanner = new Scanner(file);
+         FileWriter writer = new FileWriter(file);
+      ) {
+         scanner.next();// 11
+         writer.write("hello");// 12
+      }
+
+   }// 10 13
+}
+
+class 'pkg/TestTryWithResourcesMultiJ16' {
+   method 'testMulti (Ljava/io/File;)V' {
+      4      10
+      8      10
+      d      11
+      11      11
+      12      13
+      13      13
+      14      13
+      15      13
+      17      14
+      18      14
+      19      14
+      1a      14
+      3d      17
+      3e      17
+      3f      17
+      40      17
+      41      17
+      42      17
+      43      17
+      44      17
+      45      17
+      46      17
+      47      17
+      48      17
+      49      17
+      4a      17
+      4b      17
+      4c      17
+      4d      17
+      4e      17
+      4f      17
+      50      17
+      51      17
+   }
+}
+
+Lines mapping:
+10 <-> 18
+11 <-> 14
+12 <-> 15
+13 <-> 18
+Not mapped:
+14
diff --git a/testData/results/TestTryWithResourcesNestedJ16.dec b/testData/results/TestTryWithResourcesNestedJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..bdc619a943d6533cc85fe6198250e79e5094471d
--- /dev/null
+++ b/testData/results/TestTryWithResourcesNestedJ16.dec
@@ -0,0 +1,149 @@
+package pkg;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesNestedJ16 {
+   public void testNested(File file) throws IOException {
+      try (
+         Scanner scanner = new Scanner(file);
+         Scanner scanner1 = new Scanner(file);// 11
+         Scanner scanner2 = new Scanner(file);// 12
+         Scanner scanner3 = new Scanner(file);// 13
+      ) {
+         scanner.next();// 14
+      }
+
+   }// 10 18
+
+   public void testNestedFinally(File file) throws IOException {
+      try (Scanner scanner = new Scanner(file)) {// 22
+         try (Scanner scanner1 = new Scanner(file)) {// 23
+            try (Scanner scanner2 = new Scanner(file)) {// 24
+               try (Scanner scanner3 = new Scanner(file)) {// 25
+                  scanner.next();// 26
+               } finally {
+                  System.out.println((int)4);// 28
+               }
+            } finally {
+               System.out.println((int)3);// 31
+            }
+         } finally {
+            System.out.println((int)2);// 34
+         }
+      } finally {
+         System.out.println((int)1);// 37
+      }
+
+   }// 38
+}
+
+class 'pkg/TestTryWithResourcesNestedJ16' {
+   method 'testNested (Ljava/io/File;)V' {
+      4      9
+      8      9
+      d      10
+      11      10
+      16      11
+      1a      11
+      1b      11
+      20      12
+      24      12
+      25      12
+      26      14
+      27      14
+      28      14
+      29      14
+      87      17
+      88      17
+      89      17
+      8a      17
+      8b      17
+      8c      17
+      8d      17
+      8e      17
+      8f      17
+      90      17
+      91      17
+      92      17
+      93      17
+      94      17
+      95      17
+      96      17
+      97      17
+      98      17
+      99      17
+      9a      17
+      9b      17
+   }
+
+   method 'testNestedFinally (Ljava/io/File;)V' {
+      4      20
+      8      20
+      d      21
+      11      21
+      16      22
+      1a      22
+      1b      22
+      20      23
+      24      23
+      25      23
+      26      24
+      27      24
+      28      24
+      29      24
+      55      26
+      56      26
+      57      26
+      58      26
+      59      26
+      89      29
+      8a      29
+      8b      29
+      8c      29
+      8d      29
+      bb      32
+      bc      32
+      bd      32
+      be      32
+      bf      32
+      e5      38
+      ea      35
+      eb      35
+      ec      35
+      ed      35
+      ee      35
+   }
+}
+
+Lines mapping:
+10 <-> 18
+11 <-> 11
+12 <-> 12
+13 <-> 13
+14 <-> 15
+18 <-> 18
+22 <-> 21
+23 <-> 22
+24 <-> 23
+25 <-> 24
+26 <-> 25
+28 <-> 27
+31 <-> 30
+34 <-> 33
+37 <-> 36
+38 <-> 39
+Not mapped:
+15
+16
+17
+19
+27
+29
+30
+32
+33
+35
+36
+39
diff --git a/testData/results/TestTryWithResourcesNullJ16.dec b/testData/results/TestTryWithResourcesNullJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..791cedab7dc719603d8ccc740b861ddcd9cdffaf
--- /dev/null
+++ b/testData/results/TestTryWithResourcesNullJ16.dec
@@ -0,0 +1,99 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesNullJ16 {
+   public void test(File file) throws FileNotFoundException {
+      try (Scanner scanner = null) {// 9
+         scanner.next();// 10
+      }
+
+   }// 12
+
+   public void testNested(File file) {
+      try (Scanner scanner = null) {// 15
+         scanner.next();// 16
+
+         try (Scanner scanner2 = null) {// 18
+            scanner2.next();// 19
+         }
+      }
+
+   }// 22
+
+   public void testMulti(File file) {
+      try (
+         Scanner scanner = null;// 25
+         Scanner scanner2 = null;
+      ) {
+         scanner.next();// 26
+         scanner2.next();// 27
+      }
+
+   }// 29
+}
+
+class 'pkg/TestTryWithResourcesNullJ16' {
+   method 'test (Ljava/io/File;)V' {
+      0      8
+      1      8
+      2      9
+      3      9
+      4      9
+      5      9
+      28      12
+   }
+
+   method 'testNested (Ljava/io/File;)V' {
+      0      15
+      1      15
+      2      16
+      3      16
+      4      16
+      5      16
+      7      18
+      8      18
+      9      19
+      a      19
+      b      19
+      c      19
+      53      23
+   }
+
+   method 'testMulti (Ljava/io/File;)V' {
+      0      27
+      1      27
+      2      28
+      3      28
+      4      30
+      5      30
+      6      30
+      7      30
+      9      31
+      a      31
+      b      31
+      c      31
+      53      34
+   }
+}
+
+Lines mapping:
+9 <-> 9
+10 <-> 10
+12 <-> 13
+15 <-> 16
+16 <-> 17
+18 <-> 19
+19 <-> 20
+22 <-> 24
+25 <-> 28
+26 <-> 31
+27 <-> 32
+29 <-> 35
+Not mapped:
+11
+20
+21
+28
diff --git a/testData/results/TestTryWithResourcesOuterJ16.dec b/testData/results/TestTryWithResourcesOuterJ16.dec
new file mode 100644
index 0000000000000000000000000000000000000000..a548d26a369e3aab3578e75aa5e1e679012dfdf8
--- /dev/null
+++ b/testData/results/TestTryWithResourcesOuterJ16.dec
@@ -0,0 +1,775 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesOuterJ16 {
+   public void test(File file) throws FileNotFoundException {
+      Scanner scanner = new Scanner(file);// 11
+      Scanner var3 = scanner;
+
+      try {
+         scanner.next();// 14
+      } catch (Throwable var7) {// 13
+         if (scanner != null) {
+            try {
+               var3.close();
+            } catch (Throwable var6) {
+               var7.addSuppressed(var6);
+            }
+         }
+
+         throw var7;
+      }
+
+      if (scanner != null) {// 15
+         scanner.close();
+      }
+
+   }// 16
+
+   public void testFunc(File file) throws FileNotFoundException {
+      Scanner scanner = this.create(file);// 19
+      Scanner var3 = scanner;
+
+      try {
+         scanner.next();// 22
+      } catch (Throwable var7) {// 21
+         if (scanner != null) {
+            try {
+               var3.close();
+            } catch (Throwable var6) {
+               var7.addSuppressed(var6);
+            }
+         }
+
+         throw var7;
+      }
+
+      if (scanner != null) {// 23
+         scanner.close();
+      }
+
+   }// 24
+
+   public void testMulti(File file) throws IOException {
+      Scanner scanner = new Scanner(file);// 27
+      FileWriter writer = new FileWriter(file);// 28
+      Scanner var4 = scanner;
+
+      try {
+         FileWriter var5 = writer;
+
+         try {
+            scanner.next();// 31
+            writer.write("hello");// 32
+         } catch (Throwable var10) {
+            if (writer != null) {
+               try {
+                  var5.close();
+               } catch (Throwable var9) {
+                  var10.addSuppressed(var9);
+               }
+            }
+
+            throw var10;
+         }
+
+         if (writer != null) {
+            writer.close();
+         }
+      } catch (Throwable var11) {// 30
+         if (scanner != null) {
+            try {
+               var4.close();
+            } catch (Throwable var8) {
+               var11.addSuppressed(var8);
+            }
+         }
+
+         throw var11;
+      }
+
+      if (scanner != null) {// 33
+         scanner.close();
+      }
+
+   }// 34
+
+   public void testNested1(File file) throws IOException {
+      Scanner scanner = new Scanner(file);// 37
+      FileWriter writer = new FileWriter(file);// 38
+      Scanner var4 = scanner;
+
+      try {
+         scanner.next();// 41
+         FileWriter var5 = writer;
+
+         try {
+            writer.write("hello");// 44
+         } catch (Throwable var10) {// 43
+            if (writer != null) {
+               try {
+                  var5.close();
+               } catch (Throwable var9) {
+                  var10.addSuppressed(var9);
+               }
+            }
+
+            throw var10;
+         }
+
+         if (writer != null) {// 45
+            writer.close();
+         }
+      } catch (Throwable var11) {// 40
+         if (scanner != null) {
+            try {
+               var4.close();
+            } catch (Throwable var8) {
+               var11.addSuppressed(var8);
+            }
+         }
+
+         throw var11;
+      }
+
+      if (scanner != null) {// 46
+         scanner.close();
+      }
+
+   }// 47
+
+   public void testNested2(File file) throws IOException {
+      Scanner scanner = new Scanner(file);// 50
+      FileWriter writer = new FileWriter(file);// 51
+      Scanner var4 = scanner;
+
+      try {
+         FileWriter var5 = writer;
+
+         try {
+            scanner.next();// 55
+            writer.write("hello");// 56
+         } catch (Throwable var10) {// 54
+            if (writer != null) {
+               try {
+                  var5.close();
+               } catch (Throwable var9) {
+                  var10.addSuppressed(var9);
+               }
+            }
+
+            throw var10;
+         }
+
+         if (writer != null) {// 57
+            writer.close();
+         }
+      } catch (Throwable var11) {// 53
+         if (scanner != null) {
+            try {
+               var4.close();
+            } catch (Throwable var8) {
+               var11.addSuppressed(var8);
+            }
+         }
+
+         throw var11;
+      }
+
+      if (scanner != null) {// 58
+         scanner.close();
+      }
+
+   }// 59
+
+   public void testSame1(File file) throws FileNotFoundException {
+      Scanner scanner = new Scanner(file);// 62
+      Scanner var3 = scanner;
+
+      try {
+         scanner.next();// 65
+         Scanner var4 = scanner;
+
+         try {
+            scanner.next();// 68
+         } catch (Throwable var9) {// 67
+            if (scanner != null) {
+               try {
+                  var4.close();
+               } catch (Throwable var8) {
+                  var9.addSuppressed(var8);
+               }
+            }
+
+            throw var9;
+         }
+
+         if (scanner != null) {// 69
+            scanner.close();
+         }
+      } catch (Throwable var10) {// 64
+         if (scanner != null) {
+            try {
+               var3.close();
+            } catch (Throwable var7) {
+               var10.addSuppressed(var7);
+            }
+         }
+
+         throw var10;
+      }
+
+      if (scanner != null) {// 70
+         scanner.close();
+      }
+
+   }// 71
+
+   public void testSame2(File file) throws FileNotFoundException {
+      Scanner scanner = new Scanner(file);// 74
+      Scanner var3 = scanner;
+
+      try {
+         Scanner var4 = scanner;
+
+         try {
+            scanner.next();// 78
+         } catch (Throwable var9) {// 77
+            if (scanner != null) {
+               try {
+                  var4.close();
+               } catch (Throwable var8) {
+                  var9.addSuppressed(var8);
+               }
+            }
+
+            throw var9;
+         }
+
+         if (scanner != null) {// 79
+            scanner.close();
+         }
+      } catch (Throwable var10) {// 76
+         if (scanner != null) {
+            try {
+               var3.close();
+            } catch (Throwable var7) {
+               var10.addSuppressed(var7);
+            }
+         }
+
+         throw var10;
+      }
+
+      if (scanner != null) {
+         scanner.close();// 80
+      }
+
+   }// 81
+
+   public void testSame3(File file) throws FileNotFoundException {
+      Scanner scanner = new Scanner(file);// 84
+      Scanner var3 = scanner;
+
+      try {
+         Scanner var4 = scanner;
+
+         try {
+            scanner.next();// 88
+         } catch (Throwable var9) {// 87
+            if (scanner != null) {
+               try {
+                  var4.close();
+               } catch (Throwable var8) {
+                  var9.addSuppressed(var8);
+               }
+            }
+
+            throw var9;
+         }
+
+         if (scanner != null) {// 89
+            scanner.close();
+         }
+
+         scanner.next();// 91
+      } catch (Throwable var10) {// 86
+         if (scanner != null) {
+            try {
+               var3.close();
+            } catch (Throwable var7) {
+               var10.addSuppressed(var7);
+            }
+         }
+
+         throw var10;
+      }
+
+      if (scanner != null) {// 92
+         scanner.close();
+      }
+
+   }// 93
+
+   public void testSame4(File file) throws FileNotFoundException {
+      try (Scanner scanner = new Scanner(file)) {
+         Scanner var3 = scanner;
+
+         try {
+            scanner.next();// 98
+         } catch (Throwable var8) {// 97
+            if (scanner != null) {
+               try {
+                  var3.close();
+               } catch (Throwable var7) {
+                  var8.addSuppressed(var7);
+               }
+            }
+
+            throw var8;
+         }
+
+         if (scanner != null) {// 99
+            scanner.close();
+         }
+      }
+
+   }// 96 100
+
+   private Scanner create(File file) throws FileNotFoundException {
+      return new Scanner(file);// 104
+   }
+}
+
+class 'pkg/TestTryWithResourcesOuterJ16' {
+   method 'test (Ljava/io/File;)V' {
+      4      10
+      8      10
+      9      11
+      a      11
+      b      14
+      c      14
+      d      14
+      e      14
+      11      27
+      15      28
+      16      28
+      17      28
+      1b      15
+      1e      16
+      21      18
+      22      18
+      28      19
+      2e      20
+      33      24
+      34      31
+   }
+
+   method 'testFunc (Ljava/io/File;)V' {
+      0      34
+      1      34
+      2      34
+      3      34
+      4      34
+      5      34
+      6      35
+      7      35
+      8      38
+      9      38
+      a      38
+      b      38
+      e      51
+      12      52
+      13      52
+      14      52
+      18      39
+      1b      40
+      1e      42
+      1f      42
+      25      43
+      2b      44
+      30      48
+      31      55
+   }
+
+   method 'testMulti (Ljava/io/File;)V' {
+      4      58
+      8      58
+      d      59
+      11      59
+      12      60
+      13      60
+      14      60
+      15      63
+      16      63
+      17      63
+      18      66
+      19      66
+      1a      66
+      1b      66
+      1d      67
+      1e      67
+      1f      67
+      20      67
+      25      80
+      2a      81
+      2b      81
+      2c      81
+      30      68
+      34      69
+      37      71
+      38      71
+      39      71
+      3f      72
+      45      73
+      4a      77
+      4d      95
+      52      96
+      53      96
+      54      96
+      58      83
+      5c      84
+      5f      86
+      60      86
+      61      86
+      67      87
+      6d      88
+      72      92
+      73      99
+   }
+
+   method 'testNested1 (Ljava/io/File;)V' {
+      4      102
+      8      102
+      d      103
+      11      103
+      12      104
+      13      104
+      14      104
+      15      107
+      16      107
+      17      107
+      18      107
+      1a      108
+      1b      108
+      1c      108
+      1d      111
+      1e      111
+      1f      111
+      20      111
+      25      124
+      2a      125
+      2b      125
+      2c      125
+      30      112
+      34      113
+      37      115
+      38      115
+      39      115
+      3f      116
+      45      117
+      4a      121
+      4d      139
+      52      140
+      53      140
+      54      140
+      58      127
+      5c      128
+      5f      130
+      60      130
+      61      130
+      67      131
+      6d      132
+      72      136
+      73      143
+   }
+
+   method 'testNested2 (Ljava/io/File;)V' {
+      4      146
+      8      146
+      d      147
+      11      147
+      12      148
+      13      148
+      14      148
+      15      151
+      16      151
+      17      151
+      18      154
+      19      154
+      1a      154
+      1b      154
+      1d      155
+      1e      155
+      1f      155
+      20      155
+      25      168
+      2a      169
+      2b      169
+      2c      169
+      30      156
+      34      157
+      37      159
+      38      159
+      39      159
+      3f      160
+      45      161
+      4a      165
+      4d      183
+      52      184
+      53      184
+      54      184
+      58      171
+      5c      172
+      5f      174
+      60      174
+      61      174
+      67      175
+      6d      176
+      72      180
+      73      187
+   }
+
+   method 'testSame1 (Ljava/io/File;)V' {
+      4      190
+      8      190
+      9      191
+      a      191
+      b      194
+      c      194
+      d      194
+      e      194
+      10      195
+      11      195
+      12      195
+      13      198
+      14      198
+      15      198
+      16      198
+      1a      211
+      1f      212
+      20      212
+      21      212
+      25      199
+      29      200
+      2c      202
+      2d      202
+      2e      202
+      34      203
+      3a      204
+      3f      208
+      41      226
+      45      227
+      46      227
+      47      227
+      4b      214
+      4e      215
+      51      217
+      52      217
+      58      218
+      5e      219
+      63      223
+      64      230
+   }
+
+   method 'testSame2 (Ljava/io/File;)V' {
+      4      233
+      8      233
+      9      234
+      a      234
+      b      237
+      c      237
+      d      237
+      e      240
+      f      240
+      10      240
+      11      240
+      15      253
+      1a      254
+      1b      254
+      1c      254
+      20      241
+      24      242
+      27      244
+      28      244
+      29      244
+      2f      245
+      35      246
+      3a      250
+      3c      268
+      40      269
+      41      269
+      42      269
+      46      256
+      49      257
+      4c      259
+      4d      259
+      53      260
+      59      261
+      5e      265
+      5f      272
+   }
+
+   method 'testSame3 (Ljava/io/File;)V' {
+      4      275
+      8      275
+      9      276
+      a      276
+      b      279
+      c      279
+      d      279
+      e      282
+      f      282
+      10      282
+      11      282
+      15      295
+      1a      296
+      1b      296
+      1c      296
+      20      283
+      24      284
+      27      286
+      28      286
+      29      286
+      2f      287
+      35      288
+      3a      292
+      3b      299
+      3c      299
+      3d      299
+      3e      299
+      41      312
+      45      313
+      46      313
+      47      313
+      4b      300
+      4e      301
+      51      303
+      52      303
+      58      304
+      5e      305
+      63      309
+      64      316
+   }
+
+   method 'testSame4 (Ljava/io/File;)V' {
+      4      319
+      8      319
+      9      320
+      a      320
+      b      323
+      c      323
+      d      323
+      e      323
+      11      336
+      15      337
+      16      337
+      17      337
+      1b      324
+      1e      325
+      21      327
+      22      327
+      28      328
+      2e      329
+      33      333
+      38      341
+      39      341
+      3a      341
+      3b      341
+      3c      341
+      3d      341
+      3e      341
+      3f      341
+      40      341
+      41      341
+      42      341
+      43      341
+      44      341
+      45      341
+      46      341
+      47      341
+      48      341
+      49      341
+      4a      341
+      4b      341
+      4c      341
+   }
+
+   method 'create (Ljava/io/File;)Ljava/util/Scanner;' {
+      4      344
+      8      344
+   }
+}
+
+Lines mapping:
+11 <-> 11
+13 <-> 16
+14 <-> 15
+15 <-> 28
+16 <-> 32
+19 <-> 35
+21 <-> 40
+22 <-> 39
+23 <-> 52
+24 <-> 56
+27 <-> 59
+28 <-> 60
+30 <-> 84
+31 <-> 67
+32 <-> 68
+33 <-> 96
+34 <-> 100
+37 <-> 103
+38 <-> 104
+40 <-> 128
+41 <-> 108
+43 <-> 113
+44 <-> 112
+45 <-> 125
+46 <-> 140
+47 <-> 144
+50 <-> 147
+51 <-> 148
+53 <-> 172
+54 <-> 157
+55 <-> 155
+56 <-> 156
+57 <-> 169
+58 <-> 184
+59 <-> 188
+62 <-> 191
+64 <-> 215
+65 <-> 195
+67 <-> 200
+68 <-> 199
+69 <-> 212
+70 <-> 227
+71 <-> 231
+74 <-> 234
+76 <-> 257
+77 <-> 242
+78 <-> 241
+79 <-> 254
+80 <-> 270
+81 <-> 273
+84 <-> 276
+86 <-> 301
+87 <-> 284
+88 <-> 283
+89 <-> 296
+91 <-> 300
+92 <-> 313
+93 <-> 317
+96 <-> 342
+97 <-> 325
+98 <-> 324
+99 <-> 337
+100 <-> 342
+104 <-> 345
+Not mapped:
+101
diff --git a/testData/src/java16/TestTryWithResourcesCatchFinallyJ16.java b/testData/src/java16/TestTryWithResourcesCatchFinallyJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..d355eb7b120f18bbd2d13572fd61c18d72cf0c01
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesCatchFinallyJ16.java
@@ -0,0 +1,31 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesCatchFinallyJ16 {
+    public void test(File file) {
+        try (Scanner scanner = new Scanner(file)) {
+            scanner.next();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } finally {
+            System.out.println("Hello");
+        }
+    }
+
+    public void testFunc(File file) {
+        try (Scanner scanner = create(file)) {
+            scanner.next();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } finally {
+            System.out.println("Hello");
+        }
+    }
+
+    private Scanner create(File file) throws FileNotFoundException {
+        return new Scanner(file);
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesCatchJ16.java b/testData/src/java16/TestTryWithResourcesCatchJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..d24f7765d63c9fe54e442cfcd1c3cd116368dec3
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesCatchJ16.java
@@ -0,0 +1,50 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesCatchJ16 {
+    public void test(File file) {
+        try (Scanner scanner = new Scanner(file)) {
+            scanner.next();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void testFunc(File file) {
+        try (Scanner scanner = create(file)) {
+            scanner.next();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+    }
+
+  public int test1(File file) {
+    int i = 0;
+
+    try {
+      System.out.println(-1);
+
+      try (Scanner scanner = create(file)) {
+        scanner.next();
+        i++;
+      }
+    } catch (Exception e) {
+      System.out.println(1);
+    }
+
+    if (i == 0) {
+      System.out.println(0);
+    } else {
+      System.out.println(2);
+    }
+
+    return i;
+  }
+
+    private Scanner create(File file) throws FileNotFoundException {
+        return new Scanner(file);
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesJ16.java b/testData/src/java16/TestTryWithResourcesJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b4d856cbad29388d515c26260643bad8f162725
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesJ16.java
@@ -0,0 +1,25 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesJ16 {
+    public void test(File file) throws FileNotFoundException {
+        try (Scanner scanner = new Scanner(file)) {
+            scanner.next();
+        }
+    }
+
+    public void testFunc(File file) throws FileNotFoundException {
+        try (Scanner scanner = create(file)) {
+            scanner.next();
+        }
+    }
+
+    private Scanner create(File file) throws FileNotFoundException {
+        return new Scanner(file);
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesMultiJ16.java b/testData/src/java16/TestTryWithResourcesMultiJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..86989aee202d406a4084ab2e6cf7e1cb24054889
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesMultiJ16.java
@@ -0,0 +1,15 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesMultiJ16 {
+    public void testMulti(File file) throws IOException {
+        try (Scanner scanner = new Scanner(file); FileWriter writer = new FileWriter(file)) {
+            scanner.next();
+            writer.write("hello");
+        }
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesNestedJ16.java b/testData/src/java16/TestTryWithResourcesNestedJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..374a06c2964034ab09495490c369a2a9c3c05d11
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesNestedJ16.java
@@ -0,0 +1,40 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesNestedJ16 {
+    public void testNested(File file) throws IOException {
+        try (Scanner scanner = new Scanner(file)) {
+            try (Scanner scanner1 = new Scanner(file)) {
+                try (Scanner scanner2 = new Scanner(file)) {
+                    try (Scanner scanner3 = new Scanner(file)) {
+                        scanner.next();
+                    }
+                }
+            }
+        }
+    }
+
+    public void testNestedFinally(File file) throws IOException {
+        try (Scanner scanner = new Scanner(file)) {
+            try (Scanner scanner1 = new Scanner(file)) {
+                try (Scanner scanner2 = new Scanner(file)) {
+                    try (Scanner scanner3 = new Scanner(file)) {
+                        scanner.next();
+                    } finally {
+                        System.out.println(4);
+                    }
+                } finally {
+                    System.out.println(3);
+                }
+            } finally {
+                System.out.println(2);
+            }
+        } finally {
+            System.out.println(1);
+        }
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesNullJ16.java b/testData/src/java16/TestTryWithResourcesNullJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..bfb3d724ba30dee4a0c9dc820e571c1e9d397fb9
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesNullJ16.java
@@ -0,0 +1,30 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesNullJ16 {
+    public void test(File file) throws FileNotFoundException {
+        try (Scanner scanner = null) {
+            scanner.next();
+        }
+    }
+
+    public void testNested(File file) {
+        try (Scanner scanner = null) {
+            scanner.next();
+
+            try (Scanner scanner2 = null) {
+                scanner2.next();
+            }
+        }
+    }
+
+    public void testMulti(File file) {
+        try (Scanner scanner = null; Scanner scanner2 = null) {
+            scanner.next();
+            scanner2.next();
+        }
+    }
+}
diff --git a/testData/src/java16/TestTryWithResourcesOuterJ16.java b/testData/src/java16/TestTryWithResourcesOuterJ16.java
new file mode 100644
index 0000000000000000000000000000000000000000..69cde93f7485a7355cb541e221c36bea7e047608
--- /dev/null
+++ b/testData/src/java16/TestTryWithResourcesOuterJ16.java
@@ -0,0 +1,106 @@
+package pkg;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Scanner;
+
+public class TestTryWithResourcesOuterJ16 {
+    public void test(File file) throws FileNotFoundException {
+        Scanner scanner = new Scanner(file);
+
+        try (scanner) {
+            scanner.next();
+        }
+    }
+
+    public void testFunc(File file) throws FileNotFoundException {
+        Scanner scanner = create(file);
+
+        try (scanner) {
+            scanner.next();
+        }
+    }
+
+    public void testMulti(File file) throws IOException {
+        Scanner scanner = new Scanner(file);
+        FileWriter writer = new FileWriter(file);
+
+        try (scanner; writer) {
+            scanner.next();
+            writer.write("hello");
+        }
+    }
+
+    public void testNested1(File file) throws IOException {
+        Scanner scanner = new Scanner(file);
+        FileWriter writer = new FileWriter(file);
+
+        try (scanner) {
+            scanner.next();
+
+            try (writer) {
+                writer.write("hello");
+            }
+        }
+    }
+
+    public void testNested2(File file) throws IOException {
+        Scanner scanner = new Scanner(file);
+        FileWriter writer = new FileWriter(file);
+
+        try (scanner) {
+            try (writer) {
+                scanner.next();
+                writer.write("hello");
+            }
+        }
+    }
+
+    public void testSame1(File file) throws FileNotFoundException {
+        Scanner scanner = new Scanner(file);
+
+        try (scanner) {
+            scanner.next();
+
+            try (scanner) {
+                scanner.next();
+            }
+        }
+    }
+
+    public void testSame2(File file) throws FileNotFoundException {
+        Scanner scanner = new Scanner(file);
+
+        try (scanner) {
+            try (scanner) {
+                scanner.next();
+            }
+        }
+    }
+
+    public void testSame3(File file) throws FileNotFoundException {
+        Scanner scanner = new Scanner(file);
+
+        try (scanner) {
+            try (scanner) {
+                scanner.next();
+            }
+
+            scanner.next();
+        }
+    }
+
+    public void testSame4(File file) throws FileNotFoundException {
+        try (Scanner scanner = new Scanner(file)) {
+            try (scanner) {
+                scanner.next();
+            }
+        }
+    }
+
+    private Scanner create(File file) throws FileNotFoundException {
+        return new Scanner(file);
+    }
+}
diff --git a/testData/src/pkg/TestTryWithResources.java b/testData/src/pkg/TestTryWithResources.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c217fe0bc40af775d817bac86c68f26a11e7fb5
--- /dev/null
+++ b/testData/src/pkg/TestTryWithResources.java
@@ -0,0 +1,37 @@
+package pkg;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class TestTryWithResources {
+  public static void test1() {
+     try(FileSystem fileSystem = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI())) {
+       fileSystem.getPath("PATH", "TO", "FILE");
+     }
+     catch (URISyntaxException | IOException e) {}
+  }
+
+  public static void test2() {
+    try(FileSystem fileSystem = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI());
+        InputStream stream = Files.newInputStream(fileSystem.getPath("PATH", "TO", "FILE"))) {
+      stream.read();
+    }
+    catch (URISyntaxException | IOException e) {}
+  }
+
+  public static void test3() {
+    try(FileSystem fileSystem = FileSystems.getFileSystem(TestTryWithResources.class.getResource("NOT").toURI())) {
+      try (InputStream stream = Files.newInputStream(fileSystem.getPath("PATH", "TO", "FILE"))) {
+        stream.read();
+      }
+      catch (IOException e) {}
+      catch (Exception e) {}
+    }
+    catch (URISyntaxException | IOException e) {}
+  }
+}
\ No newline at end of file
