From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Wed, 16 Sep 2015 00:49:12 -0400
Subject: [PATCH] More merging. It does some things better. But still not
 anywhere near good enough :(


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
index 762fd011314ca3f5c7fdc370ffe2bccdbb01a509..ea7e6110cf1e5eeb4d3f13d98527d53e85dd60fe 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
@@ -24,6 +24,7 @@ import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.StartEndPair;
 
 public class BasicBlockStatement extends Statement {
 
@@ -94,4 +95,13 @@ public class BasicBlockStatement extends Statement {
   public BasicBlock getBlock() {
     return block;
   }
+
+  @Override
+    public StartEndPair getStartEndRange() {
+      if (block.size() > 0) {
+          return new StartEndPair(block.getStartInstruction(),block.getEndInstruction());
+    } else {
+        return null;
+    }
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 7abcec8a356fa92f2bc18bf2dc24fc3defac3a38..8c42c0c192cd73d7aef3632e22eaa74a3fff20e1 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -19,6 +19,7 @@ import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.ConstExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.VarExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchAllStatement;
@@ -47,11 +48,14 @@ public class VarDefinitionHelper {
 
   private final VarProcessor varproc;
 
+  private final Map<VarVersionPair,List<ConstExprent>> constExprents;
+
   public VarDefinitionHelper(Statement root, StructMethod mt, VarProcessor varproc) {
 
     mapVarDefStatements = new HashMap<Integer, Statement>();
     mapStatementVars = new HashMap<Integer, HashSet<Integer>>();
     implDefVars = new HashSet<Integer>();
+    constExprents = new HashMap<VarVersionPair,List<ConstExprent>>();
     this.varproc = varproc;
 
     VarNamesCollector vc = DecompilerContext.getVarNamesCollector();
@@ -472,16 +476,33 @@ public class VarDefinitionHelper {
     VarExprent left = (VarExprent)exp.getLeft();
     int index = varproc.getRemapped(left.getIndex());
 
-    for (Exprent e : exp.getRight().getAllExprents(true)) {
-      if (e.type == Exprent.EXPRENT_VAR) {
-          VarExprent right = (VarExprent)e;
-        if (varproc.getRemapped(right.getIndex()) == index) {
-          if (!left.equals(right) && left.getIndex() > right.getIndex()) {
-            remaps.put(new VarVersionPair(left), new VarVersionPair(right));
+    // constant
+    VarVersionPair source = new VarVersionPair(left);
+    if (exp.getRight().type == Exprent.EXPRENT_CONST) {
+        VarVersionPair target = new VarVersionPair(index,0);
+        if (index < left.getIndex()) {
+            remaps.put(source, target);
+        }
+        if (!constExprents.containsKey(source)) {
+            constExprents.put(source, new ArrayList<ConstExprent>());
+        }
+        List<ConstExprent> ceList = constExprents.get(source);
+        ceList.add((ConstExprent) exp.getRight());
+    } else {
+        for (Exprent e : exp.getRight().getAllExprents(true)) {
+          if (e.type == Exprent.EXPRENT_VAR) {
+              VarExprent right = (VarExprent)e;
+            if (varproc.getRemapped(right.getIndex()) == index) {
+              if (!left.equals(right) && left.getIndex() > right.getIndex()) {
+                remaps.put(source, new VarVersionPair(right));
+              }
+              return;
+            }
           }
-          return;
         }
-      }
+        if (index < left.getIndex()) {
+            remaps.put(source, new VarVersionPair(index,0));
+        }
     }
   }
 
@@ -514,6 +535,7 @@ public class VarDefinitionHelper {
     List<Exprent> lst = exprent.getAllExprents(true);
     lst.add(exprent);
     Map<VarVersionPair, VarType> mapExprentMinTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMinTypes();
+    Map<VarVersionPair, VarType> mapExprentMaxTypes = varproc.getVarVersions().getTypeProcessor().getMapExprentMaxTypes();
 
     for (Exprent expr : lst) {
       if (expr.type == Exprent.EXPRENT_VAR) {
@@ -523,10 +545,24 @@ public class VarDefinitionHelper {
         if (new_ != null) {
           VarType firstMinType = mapExprentMinTypes.get(old);
           VarType secondMinType = mapExprentMinTypes.get(new_);
+          VarType type = firstMinType == null ? secondMinType : (secondMinType == null ? firstMinType :VarType.getCommonSupertype(firstMinType, secondMinType));
+          if (type == null || firstMinType == null || secondMinType == null) {
+              // no common supertype, skip the remapping
+              continue;
+          }
+          if (type.typeFamily == CodeConstants.TYPE_FAMILY_OBJECT && mapExprentMaxTypes.get(old) != null && mapExprentMaxTypes.get(new_) != null) {
+              type = VarType.getCommonMinType(mapExprentMaxTypes.get(old), mapExprentMaxTypes.get(new_));
+          } else if (type.typeFamily == CodeConstants.TYPE_FAMILY_OBJECT) {
+              continue;
+          }
           var.setIndex(new_.var);
           var.setVersion(new_.version);
-          VarType type = VarType.getCommonSupertype(firstMinType, secondMinType);
           mapExprentMinTypes.put(new_, type);
+          if (constExprents.containsKey(old)) {
+              for (ConstExprent ce : constExprents.get(old)) {
+                  ce.setConstType(type);
+              }
+          }
         }
       }
     }
