From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Fri, 9 Oct 2015 13:29:20 -0700
Subject: [PATCH] Rework GenericType to be subclass of VarType and contain all
 data needed to be treated as such.


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 404265fb49a5f2cd599af38dafb8b1d0551105c8..4ec7fe9d7d34fe35fcd379d608a102d8f40e1734 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -342,13 +342,7 @@ public class ClassWriter {
       buffer.append("class ");
     }
 
-    GenericClassDescriptor descriptor = null;
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)cl.getAttributes().getWithKey("Signature");
-      if (attr != null) {
-        descriptor = GenericMain.parseClassSignature(attr.getSignature());
-      }
-    }
+    GenericClassDescriptor descriptor = cl.getSignature();
 
     buffer.append(node.simpleName);
 
@@ -362,12 +356,7 @@ public class ClassWriter {
       VarType supertype = new VarType(cl.superClass.getString(), true);
       if (!VarType.VARTYPE_OBJECT.equals(supertype)) {
         buffer.append("extends ");
-        if (descriptor != null) {
-          buffer.append(GenericMain.getGenericCastTypeName(descriptor.superclass));
-        }
-        else {
-          buffer.append(ExprProcessor.getCastTypeName(supertype));
-        }
+        buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? supertype : descriptor.superclass));
         buffer.append(' ');
       }
     }
@@ -380,12 +369,8 @@ public class ClassWriter {
           if (i > 0) {
             buffer.append(", ");
           }
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(i)));
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(new VarType(cl.getInterface(i), true)));
-          }
+          VarType iface = descriptor == null ? new VarType(cl.getInterface(i), true) : descriptor.superinterfaces.get(i);
+          buffer.append(ExprProcessor.getCastTypeName(iface));
         }
         buffer.append(' ');
       }
@@ -423,21 +408,10 @@ public class ClassWriter {
 
     VarType fieldType = new VarType(fd.getDescriptor(), false);
 
-    GenericFieldDescriptor descriptor = null;
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)fd.getAttributes().getWithKey("Signature");
-      if (attr != null) {
-        descriptor = GenericMain.parseFieldSignature(attr.getSignature());
-      }
-    }
+    GenericFieldDescriptor descriptor = fd.getSignature();
 
     if (!isEnum) {
-      if (descriptor != null) {
-        buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));
-      }
-      else {
-        buffer.append(ExprProcessor.getCastTypeName(fieldType));
-      }
+      buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? fieldType : descriptor.type));
       buffer.append(' ');
     }
 
@@ -662,33 +636,25 @@ public class ClassWriter {
         clinit = true;
       }
 
-      GenericMethodDescriptor descriptor = null;
-      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey("Signature");
-        if (attr != null) {
-          descriptor = GenericMain.parseMethodSignature(attr.getSignature());
-          if (descriptor != null) {
-            int actualParams = md.params.length;
-            List<VarVersionPair> sigFields = methodWrapper.signatureFields;
-            if (sigFields != null) {
-               actualParams = 0;
-              for (VarVersionPair field : methodWrapper.signatureFields) {
-                if (field == null) {
-                  actualParams++;
-                }
-              }
-            }
-            else if (isEnum && init) actualParams -= 2;
-            if (actualParams != descriptor.params.size()) {
-              String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor() + " in " + cl.qualifiedName;
-              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
-              descriptor = null;
+      GenericMethodDescriptor descriptor = mt.getSignature();
+      if (descriptor != null) {
+        int actualParams = md.params.length;
+        List<VarVersionPair> sigFields = methodWrapper.signatureFields;
+        if (sigFields != null) {
+           actualParams = 0;
+          for (VarVersionPair field : methodWrapper.signatureFields) {
+            if (field == null) {
+              actualParams++;
             }
           }
         }
-      }
-      if (descriptor != null) {
-          md.addGenericDescriptor(descriptor);
+        else if (isEnum && init) actualParams -= 2;
+        if (actualParams != descriptor.params.size()) {
+          String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor() + " in " + cl.qualifiedName;
+          DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+          descriptor = null;
+        }
+        md.addGenericDescriptor(descriptor);
       }
       boolean throwsExceptions = false;
       int paramCount = 0;
@@ -702,12 +668,7 @@ public class ClassWriter {
         }
 
         if (!init) {
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(md.ret));
-          }
+          buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? md.ret : descriptor.ret));
           buffer.append(' ');
         }
 
@@ -747,45 +708,23 @@ public class ClassWriter {
               buffer.append("final ");
             }
 
-            if (descriptor != null) {
-              GenericType parameterType = descriptor.params.get(i);
-
-              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
-              if (isVarArg) {
-                parameterType = parameterType.decreaseArrayDim();
-              }
-
-              String typeName = GenericMain.getGenericCastTypeName(parameterType);
-              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
-                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
-                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
-              }
-
-              buffer.append(typeName);
+            VarType parameterType = descriptor == null ? md.params[i] : descriptor.params.get(i);
 
-              if (isVarArg) {
-                buffer.append("...");
-              }
+            boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
+            if (isVarArg) {
+              parameterType = parameterType.decreaseArrayDim();
             }
-            else {
-              VarType parameterType = md.params[i];
 
-              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
-              if (isVarArg) {
-                parameterType = parameterType.decreaseArrayDim();
-              }
-
-              String typeName = ExprProcessor.getCastTypeName(parameterType);
-              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
-                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
-                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
-              }
+            String typeName = ExprProcessor.getCastTypeName(parameterType);
+            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
+                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
+              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
+            }
 
-              buffer.append(typeName);
+            buffer.append(typeName);
 
-              if (isVarArg) {
-                buffer.append("...");
-              }
+            if (isVarArg) {
+              buffer.append("...");
             }
 
             buffer.append(' ');
@@ -810,14 +749,11 @@ public class ClassWriter {
             if (i > 0) {
               buffer.append(", ");
             }
+            VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);
             if (descriptor != null && !descriptor.exceptions.isEmpty()) {
-              GenericType type = descriptor.exceptions.get(i);
-              buffer.append(GenericMain.getGenericCastTypeName(type));
-            }
-            else {
-              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);
-              buffer.append(ExprProcessor.getCastTypeName(type));
+              type = descriptor.exceptions.get(i);
             }
+            buffer.append(ExprProcessor.getCastTypeName(type));
           }
         }
       }
@@ -1080,7 +1016,7 @@ public class ClassWriter {
     }
   }
 
-  private static void appendTypeParameters(TextBuffer buffer, List<String> parameters, List<List<GenericType>> bounds) {
+  private static void appendTypeParameters(TextBuffer buffer, List<String> parameters, List<List<VarType>> bounds) {
     buffer.append('<');
 
     for (int i = 0; i < parameters.size(); i++) {
@@ -1090,13 +1026,13 @@ public class ClassWriter {
 
       buffer.append(parameters.get(i));
 
-      List<GenericType> parameterBounds = bounds.get(i);
+      List<VarType> parameterBounds = bounds.get(i);
       if (parameterBounds.size() > 1 || !"java/lang/Object".equals(parameterBounds.get(0).value)) {
         buffer.append(" extends ");
-        buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(0)));
+        buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(0)));
         for (int j = 1; j < parameterBounds.size(); j++) {
           buffer.append(" & ");
-          buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(j)));
+          buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(j)));
         }
       }
     }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 1abd0934cada3c90b1ee0d24ffbf0fa5e0d1fad9..162d9cb6953a6501771750e82f7de0a6b855c75c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -730,9 +730,12 @@ public class ExprProcessor implements CodeConstants {
     else if (tp == CodeConstants.TYPE_VOID) {
       return "void";
     }
+    else if (tp == CodeConstants.TYPE_GENVAR && type.isGeneric()) {
+        return type.value;
+    }
     else if (tp == CodeConstants.TYPE_OBJECT) {
-      if (type.genericType != null) {
-        return GenericMain.getGenericCastTypeName(type.genericType);
+      if (type.isGeneric()) {
+        return ((GenericType)type).getCastName();
       }
 
       String ret = buildJavaClassName(type.value);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
index bbf14584e481d48a7feb9b5bb324efb47684c9f5..3b5f0babb1c13152d2935024c07e924676935fae 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
@@ -26,11 +26,8 @@ import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.struct.attr.StructExceptionsAttribute;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
-import org.jetbrains.java.decompiler.struct.match.IMatchable.MatchProperties;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 import java.util.ArrayList;
@@ -93,8 +90,7 @@ public class ExitExprent extends Exprent {
         VarType ret = retType;
         boolean force = false;
         if (md.genericInfo != null && md.genericInfo.ret != null) {
-            ret = new VarType(md.genericInfo.ret);
-            force = true;
+            ret = md.genericInfo.ret;
         }
         buffer.append(" ");
         ExprProcessor.getCastedExprent(value, ret, buffer, indent, false, force, tracer);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
index 1e87201c8322b8c9d6db16a89ecab56fdb0df85d..56e67715de8e9fa7c7bf7e341e50d37b0b6b1382 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
@@ -238,19 +238,17 @@ public class NewExprent extends Exprent {
           }
         }
 
-        if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-          StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)child.getWrapper().getClassStruct().getAttributes().getWithKey("Signature");
-          if (attr != null) {
-              GenericClassDescriptor descriptor = GenericMain.parseClassSignature(attr.getSignature());
-              // Anon classes can only be a child to one type. So either the first interface or the super class
-              if (descriptor.superinterfaces.size() > 0) {
-                  typename = GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(0));
-              }
-              else {
-                  typename = GenericMain.getGenericCastTypeName(descriptor.superclass);
-              }
+        GenericClassDescriptor descriptor = child.getWrapper().getClassStruct().getSignature();
+        if (descriptor != null) {
+          // Anon classes can only be a child to one type. So either the first interface or the super class
+          if (descriptor.superinterfaces.size() > 0) {
+            typename = ExprProcessor.getCastTypeName(descriptor.superinterfaces.get(0));
+          }
+          else {
+            typename = ExprProcessor.getCastTypeName(descriptor.superclass);
           }
         }
+
         buf.prepend("new " + typename);
 
         if (enclosing != null) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index c85d889d96073327a5ea08a9d986621dd8792e26..4784e030332e1ea0ce87a4bfa69432cfa0906b73 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -111,7 +111,7 @@ public class VarExprent extends Exprent {
           buffer.append("final ");
         }
         if (lvt != null && lvt.getSig() != null) {
-          buffer.append(GenericMain.getGenericCastTypeName(new GenericType(lvt.getSig()))).append(" ");
+          buffer.append(ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSig()))).append(" ");
         }
         else if (lvt != null) {
           buffer.append(ExprProcessor.getCastTypeName(lvt.getVarType())).append(" ");
diff --git a/src/org/jetbrains/java/decompiler/struct/StructClass.java b/src/org/jetbrains/java/decompiler/struct/StructClass.java
index cb24ff65db631feeb2206ddf0fe18244eabdc788..c0683fc0c33773d1f96a2eda2dbf6ca7c4e935c2 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructClass.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructClass.java
@@ -16,8 +16,14 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -58,6 +64,7 @@ public class StructClass extends StructMember {
   private final String[] interfaceNames;
   private final VBStyleCollection<StructField, String> fields;
   private final VBStyleCollection<StructMethod, String> methods;
+  private GenericClassDescriptor signature = null;
 
   private ConstantPool pool;
 
@@ -192,4 +199,18 @@ public class StructClass extends StructMember {
 
     return CodeConstants.BYTECODE_JAVA_LE_4;
   }
+
+  @Override
+  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseClassSignature(signature.getSignature());
+    }
+    return attribute;
+  }
+
+  public GenericClassDescriptor getSignature() {
+    return signature;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructField.java b/src/org/jetbrains/java/decompiler/struct/StructField.java
index 796d77f1c9a3f78740e1a536eac4eddd2f7ed527..cde19f1efeb7bd771f2c3d8c54b88114ae187f31 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructField.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructField.java
@@ -15,7 +15,13 @@
  */
 package org.jetbrains.java.decompiler.struct;
 
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
@@ -33,6 +39,7 @@ public class StructField extends StructMember {
 
   private final String name;
   private final String descriptor;
+  private GenericFieldDescriptor signature;
 
 
   public StructField(DataInputFullStream in, StructClass clStruct) throws IOException {
@@ -55,4 +62,18 @@ public class StructField extends StructMember {
   public String getDescriptor() {
     return descriptor;
   }
+
+  public GenericFieldDescriptor getSignature() {
+    return signature;
+  }
+
+  @Override
+  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseFieldSignature(signature.getSignature());
+    }
+    return attribute;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index 2b5249f59d5a5e4bf43c2f8515adcaa31df88813..8f0da2b8eeed9428133834dbf4bd8be3f6e38ee5 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -16,8 +16,13 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
@@ -46,6 +51,7 @@ public class StructMethod extends StructMember {
   private final StructClass classStruct;
   private final String name;
   private final String descriptor;
+  private GenericMethodDescriptor signature;
 
   private boolean containsCode = false;
   private int localVariables = 0;
@@ -99,7 +105,13 @@ public class StructMethod extends StructMember {
       return null;
     }
 
-    return super.readAttribute(in, pool, name);
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseMethodSignature(signature.getSignature());
+    }
+
+    return attribute;
   }
 
   public void expandData() throws IOException {
@@ -389,4 +401,8 @@ public class StructMethod extends StructMember {
   public InstructionSequence getInstructionSequence() {
     return seq;
   }
+
+  public GenericMethodDescriptor getSignature() {
+    return signature;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
index 45fd2896cf946747b4a04e47ec54d99eae900d82..1b0df9d2e710cb6d1bee94eb1dddfe2c06135941 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
@@ -47,7 +47,6 @@ public class VarType {  // TODO: optimize switch
   public final int typeFamily;
   public final int stackSize;
   public final boolean falseBoolean;
-  public GenericType genericType;
   public VarType(int type) {
     this(type, 0);
   }
@@ -56,15 +55,11 @@ public class VarType {  // TODO: optimize switch
     this(type, arrayDim, getChar(type));
   }
 
-  public VarType(GenericType type) {
-      this(VARTYPE_OBJECT.type);
-      this.genericType = type;
-  }
   public VarType(int type, int arrayDim, String value) {
     this(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
   }
 
-  private VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
+  protected VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
     this.type = type;
     this.arrayDim = arrayDim;
     this.value = value;
@@ -156,7 +151,7 @@ public class VarType {  // TODO: optimize switch
     }
   }
 
-  private static int getStackSize(int type, int arrayDim) {
+  protected static int getStackSize(int type, int arrayDim) {
     if (arrayDim > 0) {
       return 1;
     }
@@ -173,7 +168,7 @@ public class VarType {  // TODO: optimize switch
     }
   }
 
-  private static int getFamily(int type, int arrayDim) {
+  protected static int getFamily(int type, int arrayDim) {
     if (arrayDim > 0) {
       return CodeConstants.TYPE_FAMILY_OBJECT;
     }
@@ -303,6 +298,10 @@ public class VarType {  // TODO: optimize switch
     return res.toString();
   }
 
+  public boolean isGeneric() {
+    return false;
+  }
+
   // type1 and type2 must not be null
   public static VarType getCommonMinType(VarType type1, VarType type2) {
     if (type1.type == CodeConstants.TYPE_BOOLEAN && type2.type == CodeConstants.TYPE_BOOLEAN) { // special case booleans
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
index 2ff295461e5234ad5877ed87f77046cc84ae5dcc..9418bb890763d0da30a2af93770f2d4e3be813b1 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
@@ -18,13 +18,15 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericClassDescriptor {
 
-  public GenericType superclass;
+  public VarType superclass;
 
-  public final List<GenericType> superinterfaces = new ArrayList<GenericType>();
+  public final List<VarType> superinterfaces = new ArrayList<VarType>();
 
   public final List<String> fparameters = new ArrayList<String>();
 
-  public final List<List<GenericType>> fbounds = new ArrayList<List<GenericType>>();
+  public final List<List<VarType>> fbounds = new ArrayList<List<VarType>>();
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
index 598d17bef2d00d938146dc75fa296c54848e31bf..9857f608088d254188a58b92857e486e8b1026bc 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
@@ -15,7 +15,9 @@
  */
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericFieldDescriptor {
 
-  public GenericType type;
+  public VarType type;
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
index 0a3f9d33c9e6649af3520c4b99bbd2fcb278642b..cffd0089a659148d803bf18364de4e22c487f268 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
@@ -18,6 +18,8 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -43,12 +45,12 @@ public class GenericMain {
       signature = parseFormalParameters(signature, descriptor.fparameters, descriptor.fbounds);
 
       String superCl = GenericType.getNextType(signature);
-      descriptor.superclass = new GenericType(superCl);
+      descriptor.superclass = GenericType.parse(superCl);
 
       signature = signature.substring(superCl.length());
       while (signature.length() > 0) {
         String superIf = GenericType.getNextType(signature);
-        descriptor.superinterfaces.add(new GenericType(superIf));
+        descriptor.superinterfaces.add(GenericType.parse(superIf));
         signature = signature.substring(superIf.length());
       }
 
@@ -63,7 +65,7 @@ public class GenericMain {
   public static GenericFieldDescriptor parseFieldSignature(String signature) {
     try {
       GenericFieldDescriptor descriptor = new GenericFieldDescriptor();
-      descriptor.type = new GenericType(signature);
+      descriptor.type = GenericType.parse(signature);
       return descriptor;
     }
     catch (RuntimeException e) {
@@ -85,19 +87,19 @@ public class GenericMain {
 
       while (pars.length() > 0) {
         String par = GenericType.getNextType(pars);
-        descriptor.params.add(new GenericType(par));
+        descriptor.params.add(GenericType.parse(par));
         pars = pars.substring(par.length());
       }
 
       String par = GenericType.getNextType(signature);
-      descriptor.ret = new GenericType(par);
+      descriptor.ret = GenericType.parse(par);
       signature = signature.substring(par.length());
 
       if (signature.length() > 0) {
         String[] exceptions = signature.split("\\^");
 
         for (int i = 1; i < exceptions.length; i++) {
-          descriptor.exceptions.add(new GenericType(exceptions[i]));
+          descriptor.exceptions.add(GenericType.parse(exceptions[i]));
         }
       }
 
@@ -109,7 +111,7 @@ public class GenericMain {
     }
   }
 
-  private static String parseFormalParameters(String signature, List<String> parameters, List<List<GenericType>> bounds) {
+  private static String parseFormalParameters(String signature, List<String> parameters, List<List<VarType>> bounds) {
     if (signature.charAt(0) != '<') {
       return signature;
     }
@@ -142,7 +144,7 @@ public class GenericMain {
       String param = value.substring(0, to);
       value = value.substring(to + 1);
 
-      List<GenericType> lstBounds = new ArrayList<GenericType>();
+      List<VarType> lstBounds = new ArrayList<VarType>();
 
       while (true) {
         if (value.charAt(0) == ':') {
@@ -151,7 +153,7 @@ public class GenericMain {
         }
 
         String bound = GenericType.getNextType(value);
-        lstBounds.add(new GenericType(bound));
+        lstBounds.add(GenericType.parse(bound));
         value = value.substring(bound.length());
 
 
@@ -191,69 +193,9 @@ public class GenericMain {
       return type.value;
     }
     else if (tp == CodeConstants.TYPE_OBJECT) {
-      StringBuilder buffer = new StringBuilder();
-      appendClassName(type, buffer);
-      return buffer.toString();
+      return type.getCastName();
     }
 
     throw new RuntimeException("Invalid type: " + type);
   }
-
-  private static void appendClassName(GenericType type, StringBuilder buffer) {
-    List<GenericType> enclosingClasses = type.getEnclosingClasses();
-
-    if (enclosingClasses.isEmpty()) {
-      String name = type.value.replace('/', '.');
-      buffer.append(DecompilerContext.getImportCollector().getShortName(name));
-    }
-    else {
-      for (GenericType tp : enclosingClasses) {
-        if (buffer.length() == 0) {
-          buffer.append(DecompilerContext.getImportCollector().getShortName(tp.value));
-        }
-        else {
-          buffer.append(tp.value);
-        }
-
-        appendTypeArguments(tp, buffer);
-        buffer.append('.');
-      }
-
-      buffer.append(type.value);
-    }
-
-    appendTypeArguments(type, buffer);
-  }
-
-  private static void appendTypeArguments(GenericType type, StringBuilder buffer) {
-    if (!type.getArguments().isEmpty()) {
-      buffer.append('<');
-
-      for (int i = 0; i < type.getArguments().size(); i++) {
-        if (i > 0) {
-          buffer.append(", ");
-        }
-
-        int wildcard = type.getWildcards().get(i);
-        switch (wildcard) {
-          case GenericType.WILDCARD_UNBOUND:
-            buffer.append('?');
-            break;
-          case GenericType.WILDCARD_EXTENDS:
-            buffer.append("? extends ");
-            break;
-          case GenericType.WILDCARD_SUPER:
-            buffer.append("? super ");
-            break;
-        }
-
-        GenericType genPar = type.getArguments().get(i);
-        if (genPar != null) {
-          buffer.append(getGenericCastTypeName(genPar));
-        }
-      }
-
-      buffer.append(">");
-    }
-  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
index 7ef93995cb08d8bc8f88603c16907740a6b09b57..5c2ff051baebf27af879a6e01a4bd855989e9bda 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
@@ -18,15 +18,17 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericMethodDescriptor {
 
   public final List<String> fparameters = new ArrayList<String>();
 
-  public final List<List<GenericType>> fbounds = new ArrayList<List<GenericType>>();
+  public final List<List<VarType>> fbounds = new ArrayList<List<VarType>>();
 
-  public final List<GenericType> params = new ArrayList<GenericType>();
+  public final List<VarType> params = new ArrayList<VarType>();
 
-  public GenericType ret;
+  public VarType ret;
 
-  public final List<GenericType> exceptions = new ArrayList<GenericType>();
+  public final List<VarType> exceptions = new ArrayList<VarType>();
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index 9305bf93cf68b9f87b6d765b25494bcb2813c2aa..c45d47f7e7efbd28e5bbddb02441299306518733 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -16,38 +16,43 @@
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
-public class GenericType {
+public class GenericType extends VarType {
 
   public static final int WILDCARD_EXTENDS = 1;
   public static final int WILDCARD_SUPER = 2;
   public static final int WILDCARD_UNBOUND = 3;
   public static final int WILDCARD_NO = 4;
 
-  public final int type;
-  public final int arrayDim;
-  public final String value;
-  public final int stackSize;
+  private final VarType parent;
+  private final List<VarType> arguments;
+  private final int wildcard;
 
-  private final List<GenericType> enclosingClasses = new ArrayList<GenericType>();
-  private final List<GenericType> arguments = new ArrayList<GenericType>();
-  private final List<Integer> wildcards = new ArrayList<Integer>();
+  private GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
+    super(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
+    this.parent = parent;
+    this.arguments = arguments == null ? Collections.<VarType>emptyList() : arguments;
+    this.wildcard = wildcard;
+  }
 
-  public GenericType(int type, int arrayDim, String value) {
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
-    this.stackSize = getStackSize(type, arrayDim);
+  public static VarType parse(String signature) {
+    return parse(signature, WILDCARD_NO);
   }
 
-  public GenericType(String signature) {
+  public static VarType parse(String signature, int wildcard) {
     int type = 0;
     int arrayDim = 0;
     String value = null;
+    List<VarType> params = null;
+    VarType parent = null;
+
 
     int index = 0;
     loop:
@@ -65,32 +70,53 @@ public class GenericType {
         case 'L':
           type = CodeConstants.TYPE_OBJECT;
           signature = signature.substring(index + 1, signature.length() - 1);
+          String cl = getNextClassSignature(signature);
 
-          while (true) {
-            String cl = getNextClassSignature(signature);
-
-            String name = cl;
-            String args = null;
-
-            int argStart = cl.indexOf("<");
+          if (cl.length() == signature.length()) {
+            int argStart = cl.indexOf('<');
             if (argStart >= 0) {
-              name = cl.substring(0, argStart);
-              args = cl.substring(argStart + 1, cl.length() - 1);
-            }
-
-            if (cl.length() < signature.length()) {
-              signature = signature.substring(cl.length() + 1); // skip '.'
-              GenericType type11 = new GenericType(CodeConstants.TYPE_OBJECT, 0, name);
-              parseArgumentsList(args, type11);
-              enclosingClasses.add(type11);
+              value = cl.substring(0, argStart);
+              params = parseArgumentsList(cl.substring(argStart + 1, cl.length() - 1));
             }
             else {
-              value = name;
-              parseArgumentsList(args, this);
-              break;
+              value = cl;
+            }
+          }
+          else {
+            StringBuilder name_buff = new StringBuilder();
+            while (signature.length() > 0) {
+              String name = cl;
+              String args = null;
+
+              int argStart = cl.indexOf('<');
+              if (argStart >= 0) {
+                name = cl.substring(0, argStart);
+                args = cl.substring(argStart + 1, cl.length() - 1);
+              }
+
+              if (name_buff.length() > 0) {
+                name_buff.append('.');
+              }
+              name_buff.append(name);
+
+              value = name_buff.toString();
+              params = args == null ? null : parseArgumentsList(args);
+
+              if (cl.length() == signature.length()) {
+                break;
+              }
+              else {
+                if (parent == null && params == null) {
+                  parent = GenericType.parse("L" + value + ";");
+                }
+                else {
+                  parent = new GenericType(CodeConstants.TYPE_OBJECT, 0, value, parent, params, wildcard);
+                }
+
+                signature = signature.substring(cl.length() + 1);
+              }
             }
           }
-
           break loop;
 
         default:
@@ -101,10 +127,20 @@ public class GenericType {
       index++;
     }
 
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
-    this.stackSize = getStackSize(type, arrayDim);
+    if (type == CodeConstants.TYPE_GENVAR) {
+      return new GenericType(type, arrayDim, value, null, null, wildcard);
+    }
+    else if (type == CodeConstants.TYPE_OBJECT) {
+      if (parent == null && params == null && wildcard == WILDCARD_NO) {
+        return new VarType(type, arrayDim, value);
+      }
+      else {
+        return new GenericType(type, arrayDim, value, parent, params, wildcard);
+      }
+    }
+    else {
+      return new VarType(type, arrayDim, value);
+    }
   }
 
   private static String getNextClassSignature(String value) {
@@ -132,11 +168,13 @@ public class GenericType {
     return value.substring(0, index);
   }
 
-  private static void parseArgumentsList(String value, GenericType type) {
+  private static List<VarType> parseArgumentsList(String value) {
     if (value == null) {
-      return;
+      return null;
     }
 
+    List<VarType> args = new ArrayList<VarType>();
+
     while (value.length() > 0) {
       String typeStr = getNextType(value);
       int len = typeStr.length();
@@ -154,16 +192,16 @@ public class GenericType {
           break;
       }
 
-      type.getWildcards().add(wildcard);
-
       if (wildcard != WILDCARD_NO) {
         typeStr = typeStr.substring(1);
       }
 
-      type.getArguments().add(typeStr.length() == 0 ? null : new GenericType(typeStr));
+      args.add(typeStr.length() == 0 ? null : GenericType.parse(typeStr, wildcard));
 
       value = value.substring(len);
     }
+
+    return args;
   }
 
   public static String getNextType(String value) {
@@ -212,37 +250,71 @@ public class GenericType {
     return value.substring(0, index + 1);
   }
 
-  private static int getStackSize(int type, int arrayDim) {
-      if (arrayDim > 0) {
-        return 1;
-      }
-
-      switch (type) {
-        case CodeConstants.TYPE_DOUBLE:
-        case CodeConstants.TYPE_LONG:
-          return 2;
-        case CodeConstants.TYPE_VOID:
-        case CodeConstants.TYPE_GROUP2EMPTY:
-          return 0;
-        default:
-          return 1;
-      }
-    }
-
   public GenericType decreaseArrayDim() {
     assert arrayDim > 0 : this;
-    return new GenericType(type, arrayDim - 1, value);
+    return new GenericType(type, arrayDim - 1, value, parent, arguments, wildcard);
   }
 
-  public List<GenericType> getArguments() {
+  public List<VarType> getArguments() {
     return arguments;
   }
 
-  public List<GenericType> getEnclosingClasses() {
-    return enclosingClasses;
+  @Override
+  public boolean isGeneric() {
+    return true;
+  }
+
+  public int getWildcard() {
+    return wildcard;
+  }
+
+  public String getCastName() {
+    String clsName = null;
+    if (parent == null) {
+      clsName = DecompilerContext.getImportCollector().getShortName(value.replace('/', '.'));
+    }
+    else if (parent.isGeneric()) {
+      clsName = ((GenericType)parent).getCastName() + "." + value.substring(value.lastIndexOf('.') + 1);
+    }
+    else {
+      clsName = DecompilerContext.getImportCollector().getShortName(parent.value.replace('/', '.')) + "." + value.substring(value.lastIndexOf('.') + 1);
+    }
+    return clsName + getTypeArguments();
   }
 
-  public List<Integer> getWildcards() {
-    return wildcards;
+  private String getTypeArguments() {
+    StringBuilder buffer = new StringBuilder();
+    if (!arguments.isEmpty()) {
+      buffer.append('<');
+
+      for (int i = 0; i < arguments.size(); i++) {
+        if (i > 0) {
+          buffer.append(", ");
+        }
+
+        VarType par = arguments.get(i);
+        if (par == null) { // Wildcard unbound
+          buffer.append('?');
+        }
+        else if (par.isGeneric()) {
+          GenericType gen = (GenericType)par;
+          switch (gen.getWildcard()) {
+            case GenericType.WILDCARD_EXTENDS:
+              buffer.append("? extends ");
+              break;
+            case GenericType.WILDCARD_SUPER:
+              buffer.append("? super ");
+              break;
+          }
+          buffer.append(GenericMain.getGenericCastTypeName(gen));
+        }
+        else {
+          buffer.append(ExprProcessor.getCastTypeName(par));
+        }
+      }
+
+      buffer.append(">");
+    }
+    return buffer.toString();
   }
 }
