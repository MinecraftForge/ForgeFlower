From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RainWarrior <rainwarrior@fry.su>
Date: Wed, 14 Oct 2015 09:26:05 +0300
Subject: [PATCH] passing information from InvocationExprent's inferred type
 arguments to the parameters


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index ca5e0778987e633aaf5c4f54a63fefe28cb356e0..884a2d7ed927eb6f402b05a169ca772764bf9c61 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -429,7 +429,7 @@ public class InvocationExprent extends Exprent {
         boolean ambiguous = setAmbiguousParameters.get(i);
         VarType type = descriptor.params[i];
 		VarType newType = null;
-        /*if(desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+        if(desc != null && desc.getSignature() != null && genericArgs.size() != 0 && desc.getSignature().params.size() == lstParameters.size()) {
           newType = desc.getSignature().params.get(i);
           boolean free = false;
           for(String param : desc.getSignature().fparameters) {
@@ -441,10 +441,44 @@ public class InvocationExprent extends Exprent {
           if(!free) {
             type = newType;
           }
-        }*/
+        }
         if(genArgs.containsKey(type)) {
           type = genArgs.get(type);
         }
+		else if(desc != null && desc.getSignature() != null && genericArgs.size() != 0) {
+			Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
+			for(int j = 0; j < genericArgs.size(); j++) {
+				VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
+				VarType to = genericArgs.get(j);
+				genMap.put(from, to);
+				//System.out.println("map: (" + from + " -> " + to + ")");
+			}
+			if(genMap.containsKey(type)) {
+				type = genMap.get(type);
+			}
+			// this only checks 1 level deep right now
+			else if(type.isGeneric()) {
+				GenericType genType = (GenericType)type;
+				List<VarType> toArgs = new ArrayList<VarType>();
+				boolean changed = false;
+				VarType parent = genType.getParent();
+				if(genMap.containsKey(parent)) {
+					parent = genMap.get(parent);
+					changed = true;
+				}
+				for(VarType arg : genType.getArguments()) {
+					if(genMap.containsKey(arg)) {
+						toArgs.add(genMap.get(arg));
+						changed = true;
+					} else {
+						toArgs.add(arg);
+					}
+				}
+				if(changed) {
+					type = new GenericType(type.type, type.arrayDim, type.value, parent, toArgs, genType.getWildcard());
+				}
+			}
+		}
         /*if(desc != null && desc.getSignature() != null) {
           for(String ps: desc.getSignature().fparameters) {
             VarType param = GenericType.parse("T" + ps + ";");
@@ -509,8 +543,7 @@ public class InvocationExprent extends Exprent {
         boolean exact = true;
         for (int i = 0; i < md.params.length; i++) {
           if (!md.params[i].equals(lstParameters.get(i).getExprType())) {
-            // FIXME
-            //exact = false;
+            exact = false;
             break;
           }
         }
@@ -523,6 +556,7 @@ public class InvocationExprent extends Exprent {
     for (int i = 0; i < descriptor.params.length; i++) {
       VarType paramType = descriptor.params[i];
       for (StructMethod mtt : matches) {
+        if(mtt.getSignature() != null && mtt.getSignature().params.get(i).isGeneric()) break;
         MethodDescriptor md = MethodDescriptor.parseDescriptor(mtt.getDescriptor());
         if (!paramType.equals(md.params[i])) {
           ambiguous.set(i);
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index da04e009a8b3ef883536cf117faee2f6dfe3b417..9319bf76366d189afd5bdb98b018c8e0425a58b0 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -35,7 +35,7 @@ public class GenericType extends VarType {
   private final List<VarType> arguments;
   private final int wildcard;
 
-  private GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
+  public GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
     super(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
     this.parent = parent;
     this.arguments = arguments == null ? Collections.<VarType>emptyList() : arguments;
@@ -256,6 +256,10 @@ public class GenericType extends VarType {
     return new GenericType(type, arrayDim - 1, value, parent, arguments, wildcard);
   }
 
+  public VarType getParent() {
+    return parent;
+  }
+
   public List<VarType> getArguments() {
     return arguments;
   }
