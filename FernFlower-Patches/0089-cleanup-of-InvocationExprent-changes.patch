From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RainWarrior <rainwarrior@fry.su>
Date: Fri, 16 Oct 2015 02:06:25 +0300
Subject: [PATCH] cleanup of InvocationExprent changes


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index b2c3574dec9dcc67e8af5c94c4f2e6c2cb078214..e6152070d2b155d98fc0b8155db12c12ca3864e0 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -170,30 +170,11 @@ public class InvocationExprent extends Exprent {
     List<StructMethod> matches = getMatchedDescriptors();
     StructMethod desc = null;
     if(matches.size() == 1) desc = matches.get(0);
-    //System.out.println("infer: " + instance + " " + classname + "." + name + " " + getExprType() + " " + upperBound + " " + desc);
 
     VarType type = getExprType();
 
     genericArgs.clear();
 
-    //System.out.println("0: " + isStatic + " " + desc + " " + upperBound + " " + descriptor.ret + " " + upperBound.isGeneric());
-    /*if(desc == null) {
-      // more harn than gain
-      // Object -> String
-      if(descriptor.ret.value.equals("java/lang/Object") && !descriptor.ret.equals(upperBound)) {
-        genericArgs.add(upperBound);
-        System.out.println("1: " + upperBound + " " + descriptor.ret);
-      }
-      // List -> List<String>
-      if(upperBound.isGeneric()) {
-        List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
-        //System.out.println("22: " + upperBound + " " + leftArgs.get(0));
-        if(leftArgs.size() == 1 && descriptor.ret.equals(upperBound) && leftArgs.get(0).type == CodeConstants.TYPE_OBJECT) {
-          genericArgs.add(leftArgs.get(0));
-          System.out.println("2: " + upperBound.type + " " + upperBound + " " + leftArgs.get(0).type + " " + leftArgs.get(0));
-        }
-      }
-    }*/
     if(desc != null && desc.getSignature() != null) {
       VarType ret = desc.getSignature().ret;
       Map<VarType, VarType> map = new HashMap<VarType, VarType>();
@@ -201,7 +182,6 @@ public class InvocationExprent extends Exprent {
       // T -> String
       /*if(upperBound != null && desc.getSignature().fparameters.size() == 1 && desc.getSignature().fparameters.get(0).equals(ret.value)) {
         genericArgs.add(upperBound);
-        System.out.println("3: " + upperBound + " " + ret + " " + desc.getSignature().fparameters.get(0));
       }*/
       // List<T> -> List<String>
       if(upperBound != null && upperBound.isGeneric() && ret.isGeneric()) {
@@ -212,10 +192,9 @@ public class InvocationExprent extends Exprent {
           for(int i = 0; i < leftArgs.size(); i++) {
             VarType l = leftArgs.get(i);
             VarType r = rightArgs.get(i);
-            if(l != null /*&& l.type == CodeConstants.TYPE_OBJECT && !l.equals(r)*/ && r.value.equals(fparams.get(i))) {
+            if(l != null && r.value.equals(fparams.get(i))) {
               genericArgs.add(l);
               map.put(r, l);
-              System.out.println("4: " + i + " " + l + " " + r + " " + fparams.get(i));
             }
             else {
               genericArgs.clear();
@@ -226,8 +205,6 @@ public class InvocationExprent extends Exprent {
         }
       }
 
-      //System.out.println("infer map: "+ ret + " -> " + ret.remap(map));
-
       if(!map.isEmpty()) {
         // remap and return generic type
         VarType newType = ret.remap(map);
@@ -237,6 +214,7 @@ public class InvocationExprent extends Exprent {
     }
     return type;
   }
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -413,18 +391,14 @@ public class InvocationExprent extends Exprent {
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
     Map<VarType, VarType> genArgs = new HashMap<VarType, VarType>();
 
+    // building generic info from the instance
     if(cl != null && cl.getSignature() != null && instance != null && instance.getInferredExprType(null).isGeneric()) {
       GenericType genType = (GenericType)instance.getInferredExprType(null);
       if(genType.getArguments().size() == cl.getSignature().fparameters.size()) {
-        /*System.out.println("remap: " + classname + "." + name + " " + genType);
-        if(instance instanceof FieldExprent) {
-            System.out.println(((FieldExprent)instance).getClassname() + "." + ((FieldExprent)instance).getName());
-        }*/
         for(int i = 0; i < cl.getSignature().fparameters.size(); i++) {
           VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
           VarType to = genType.getArguments().get(i);
-          if(from != null && to != null /*&& to.type == CodeConstants.TYPE_OBJECT*/) {
-            //System.out.println("(" + from.type + " " + from + " -> " + to.type + " " + to + ")");
+          if(from != null && to != null) {
             genArgs.put(from, to);
           }
         }
@@ -441,79 +415,30 @@ public class InvocationExprent extends Exprent {
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
         VarType type = descriptor.params[i];
-        VarType newType = null;
-        if(desc != null && desc.getSignature() != null && /*genericArgs.size() != 0 && */desc.getSignature().params.size() == lstParameters.size()) {
-          newType = desc.getSignature().params.get(i);
-          /*boolean free = false;
-          for(String param : desc.getSignature().fparameters) {
-            if(param.equals(newType.value)) {
-              free = true;
-              break;
-            }
-          }
-
-          if(!free) {*/
-            type = newType;
-          //}
+        // using info from the generic signature
+        if(desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+          type = desc.getSignature().params.get(i);
         }
-        //System.out.println("check: " + type + " " + type.remap(genArgs) + " " + type.isGeneric() + " " + type.remap(genArgs).isGeneric());
-        /*if(genArgs.containsKey(type)) {
-          type = genArgs.get(type);
-        }*/
+        // applying generic info from the signature
         VarType remappedType = type.remap(genArgs);
         if(type != remappedType) {
           type = remappedType;
         }
+        // and from the inferred generic arguments
         else if(desc != null && desc.getSignature() != null && genericArgs.size() != 0) {
           Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
           for(int j = 0; j < genericArgs.size(); j++) {
             VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
             VarType to = genericArgs.get(j);
             genMap.put(from, to);
-            //System.out.println("map: (" + from + " -> " + to + ")");
           }
           type = type.remap(genMap);
-          /*if(genMap.containsKey(type)) {
-            type = genMap.get(type);
-          }
-          // this only checks 1 level deep right now
-          else if(type.isGeneric()) {
-            GenericType genType = (GenericType)type;
-            List<VarType> toArgs = new ArrayList<VarType>();
-            boolean changed = false;
-            VarType parent = genType.getParent();
-            if(genMap.containsKey(parent)) {
-              parent = genMap.get(parent);
-              changed = true;
-            }
-            for(VarType arg : genType.getArguments()) {
-              if(genMap.containsKey(arg)) {
-                toArgs.add(genMap.get(arg));
-                changed = true;
-              } else {
-                toArgs.add(arg);
-              }
-            }
-            System.out.println("gen: " + changed + " " + parent + " ");
-            if(changed) {
-              type = new GenericType(type.type, type.arrayDim, type.value, parent, toArgs, genType.getWildcard());
-            }
-          }*/
         }
-        /*if(desc != null && desc.getSignature() != null) {
-          for(String ps: desc.getSignature().fparameters) {
-            VarType param = GenericType.parse("T" + ps + ";");
-            if(param.equals(type)) { // found free argument, need to infer it from the argument
-              type = lstParameters.get(i).getExprType();
-              break;
-            }
-          }
-        }*/
+        // not passing it along if what we get back is more specific
         VarType exprType = lstParameters.get(i).getInferredExprType(type);
-        if(exprType != null /*&& exprType.type != CodeConstants.TYPE_NULL*/ && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+        if(exprType != null && type != null && type.type == CodeConstants.TYPE_GENVAR) {
           type = exprType;
         }
-        //System.out.println("param: " + i + " " + exprType + " " + type + " " + lstParameters.get(i));
         ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, type.type != CodeConstants.TYPE_NULL, ambiguous, tracer);
         buf.append(buff);
 
@@ -530,7 +455,6 @@ public class InvocationExprent extends Exprent {
     List<StructMethod> matches = new ArrayList<StructMethod>();
 
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
-    //System.out.println("m: " + classname + "." + name + " " + cl);
     if (cl == null) return matches;
 
     nextMethod:
