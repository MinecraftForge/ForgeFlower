From 7f9bb7d21c105347ab987df050eb7458ac8ab1f5 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Thu, 6 Aug 2015 17:01:25 -0700
Subject: Aded debug printer to MethodProcessorRunnable for the method outline.


diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index 1c90fb6fc41b20e8b295201cfdb69abb63463bd0..dc6f2f0e61563f8132d99b70d3d81278f224da04 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -17,6 +17,7 @@ package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.code.InstructionSequence;
+import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.code.cfg.ControlFlowGraph;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
@@ -25,12 +26,16 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.code.DeadCodeHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.*;
 import org.jetbrains.java.decompiler.modules.decompiler.deobfuscator.ExceptionDeobfuscator;
+import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.DummyExitStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 
 import java.io.IOException;
+import java.util.BitSet;
 
 public class MethodProcessorRunnable implements Runnable {
 
@@ -138,7 +143,7 @@ public class MethodProcessorRunnable implements Runnable {
     proc.processStatement(root, cl);
 
     SequenceHelper.condenseSequences(root);
-    
+
     while (true) {
       StackVarsProcessor stackProc = new StackVarsProcessor();
       stackProc.simplifyStackVars(root, mt, cl);
@@ -199,6 +204,8 @@ public class MethodProcessorRunnable implements Runnable {
 
     varProc.setVarDefinitions(root);
 
+    printMethod(root);
+
     // must be the last invocation, because it makes the statement structure inconsistent
     // FIXME: new edge type needed
     LabelHelper.replaceContinueWithBreak(root);
@@ -217,4 +224,118 @@ public class MethodProcessorRunnable implements Runnable {
   public boolean isFinished() {
     return finished;
   }
+
+  private static void printMethod(RootStatement root) {
+    System.out.println("{");
+
+    for (Object obj : root.getSequentialObjects()) {
+      if (obj instanceof Statement) {
+        printStatement((Statement)obj, "  ");
+      } else {
+        System.out.println("  " + obj.getClass().getSimpleName());
+      }
+    }
+    printStatement(root.getDummyExit(), "  ");
+    System.out.println("}");
+  }
+
+  private static void getOffset(Statement st, BitSet values) {
+    if (st instanceof DummyExitStatement && ((DummyExitStatement)st).bytecode != null)
+      values.or(((DummyExitStatement)st).bytecode);
+    if (st.getExprents() != null) {
+      for (Exprent e : st.getExprents()) {
+        e.getBytecodeRange(values);
+      }
+    } else {
+      for (Object obj : st.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          getOffset((Statement)obj, values);
+        } else if (obj instanceof Exprent) {
+          ((Exprent)obj).getBytecodeRange(values);
+        } else {
+          System.out.println("WTF?" + obj.getClass());
+        }
+      }
+    }
+  }
+
+  private static void printStatement(Statement statement, String indent) {
+    BitSet values = new BitSet();
+    getOffset(statement, values);
+    int start = values.nextSetBit(0);
+    int end = values.length()-1;
+
+    System.out.println(indent + statement.type + ": (" + start + ", " + end + ") " + statement.getClass().getSimpleName());
+
+    if (statement.getExprents() != null) {
+      for(Exprent exp : statement.getExprents()) {
+        System.out.println(indent + "  " + exp.getClass().getSimpleName());
+      }
+    }
+    /*
+      for (Object obj : stat.getSequentialObjects()) {
+        if (obj instanceof Statement) {
+          Statement st = (Statement)obj;
+          childVars.addAll(initStatement(st));
+
+          if (st.type == DoStatement.TYPE_DO) {
+            DoStatement dost = (DoStatement)st;
+            if (dost.getLooptype() != DoStatement.LOOP_FOR &&
+                dost.getLooptype() != DoStatement.LOOP_DO) {
+              currVars.add(dost.getConditionExprent());
+            }
+          }
+          else if (st.type == DoStatement.TYPE_CATCHALL) {
+            CatchAllStatement fin = (CatchAllStatement)st;
+            if (fin.isFinally() && fin.getMonitor() != null) {
+              currVars.add(fin.getMonitor());
+            }
+          }
+        }
+        else if (obj instanceof Exprent) {
+          currVars.add((Exprent)obj);
+        }
+      }
+
+      // children statements
+      for (Integer index : childVars) {
+        Integer count = mapCount.get(index);
+        if (count == null) {
+          count = new Integer(0);
+        }
+        mapCount.put(index, new Integer(count.intValue() + 1));
+      }
+
+      condlst = getAllVars(currVars);
+    }
+    else {
+      condlst = getAllVars(stat.getExprents());
+    }
+
+    // this statement
+    for (VarExprent var : condlst) {
+      mapCount.put(new Integer(var.getIndex()), new Integer(2));
+    }
+
+
+    HashSet<Integer> set = new HashSet<Integer>(mapCount.keySet());
+
+    // put all variables defined in this statement into the set
+    for (Entry<Integer, Integer> en : mapCount.entrySet()) {
+      if (en.getValue().intValue() > 1) {
+        mapVarDefStatements.put(en.getKey(), stat);
+      }
+    }
+
+    mapStatementVars.put(stat.id, set);
+*/
+    indent += "  ";
+    for (Object obj : statement.getSequentialObjects()) {
+      if (obj instanceof Statement) {
+        printStatement((Statement)obj, indent);
+      } else {
+        System.out.println(indent + obj.getClass().getSimpleName());
+      }
+    }
+  }
 }
-- 
2.28.0.windows.1

