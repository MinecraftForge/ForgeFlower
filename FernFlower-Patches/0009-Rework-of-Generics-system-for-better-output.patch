From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Fri, 14 Apr 2017 17:09:41 -0700
Subject: [PATCH] Rework of Generics system for better output


diff --git a/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java b/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
index 4c4916e4cc5ccdd06dd4138dae54c31fb7f3bd34..decfe747ba2ab3643209987294ef7bcbbfa15e1b 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
@@ -34,7 +34,7 @@ public final class ClassReference14Processor {
     invFor.setDescriptor(MethodDescriptor.parseDescriptor("(Ljava/lang/String;)Ljava/lang/Class;"));
     invFor.setStatic(true);
     invFor.setParameters(Collections.singletonList(new VarExprent(0, VarType.VARTYPE_STRING, null)));
-    BODY_EXPR = new ExitExprent(ExitExprent.EXIT_RETURN, invFor, VarType.VARTYPE_CLASS, null);
+    BODY_EXPR = new ExitExprent(ExitExprent.EXIT_RETURN, invFor, VarType.VARTYPE_CLASS, null, null);
 
     InvocationExprent ctor = new InvocationExprent();
     ctor.setName(CodeConstants.INIT_NAME);
@@ -52,7 +52,7 @@ public final class ClassReference14Processor {
     invCause.setInstance(newExpr);
     invCause.setParameters(
       Collections.singletonList(new VarExprent(2, new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/ClassNotFoundException"), null)));
-    HANDLER_EXPR = new ExitExprent(ExitExprent.EXIT_THROW, invCause, null, null);
+    HANDLER_EXPR = new ExitExprent(ExitExprent.EXIT_THROW, invCause, null, null, null);
   }
 
   public static void processClassReferences(ClassNode node) {
@@ -235,4 +235,4 @@ public final class ClassReference14Processor {
 
     return null;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 1989a01b158570651f332cf80dca0e0baeb4153c..31236841f1b4bf4f452f30d6b95f21fcc99ec5b9 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -371,9 +371,14 @@ public class ClassWriter {
 
     List<TypeAnnotation> typeAnnotations = TypeAnnotation.listFrom(cl);
 
-    GenericClassDescriptor descriptor = getGenericClassDescriptor(cl);
+    GenericClassDescriptor descriptor = cl.getSignature();
     if (descriptor != null && !descriptor.fparameters.isEmpty()) {
-      appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds, typeAnnotations);
+      DecompilerContext.setProperty(DecompilerContext.IN_CLASS_TYPE_PARAMS, "1");
+      try {
+        appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds, typeAnnotations);
+      } finally {
+        DecompilerContext.setProperty(DecompilerContext.IN_CLASS_TYPE_PARAMS, "0");
+      }
     }
 
     if (components != null) {
@@ -396,15 +401,7 @@ public class ClassWriter {
       List<TypeAnnotation> extendsTypeAnnotations = TargetInfo.SupertypeTarget.extractExtends(typeAnnotations);
       if (!VarType.VARTYPE_OBJECT.equals(supertype)) {
         buffer.append("extends ");
-        if (descriptor != null) {
-          buffer.append(GenericMain.getGenericCastTypeName(
-            descriptor.superclass,
-            TypeAnnotationWriteHelper.create(extendsTypeAnnotations))
-          );
-        }
-        else {
-          buffer.append(ExprProcessor.getCastTypeName(supertype, TypeAnnotationWriteHelper.create(extendsTypeAnnotations)));
-        }
+        buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? supertype : descriptor.superclass, TypeAnnotationWriteHelper.create(extendsTypeAnnotations)));
         buffer.append(' ');
       }
     }
@@ -418,18 +415,7 @@ public class ClassWriter {
             buffer.append(", ");
           }
           List<TypeAnnotation> superTypeAnnotations = TargetInfo.SupertypeTarget.extract(typeAnnotations, i);
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(
-              descriptor.superinterfaces.get(i),
-              TypeAnnotationWriteHelper.create(superTypeAnnotations))
-            );
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(
-              new VarType(cl.getInterface(i), true),
-              TypeAnnotationWriteHelper.create(superTypeAnnotations))
-            );
-          }
+          buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? new VarType(cl.getInterface(i), true) : descriptor.superinterfaces.get(i), TypeAnnotationWriteHelper.create(superTypeAnnotations)));
         }
         buffer.append(' ');
       }
@@ -491,12 +477,7 @@ public class ClassWriter {
     final List<TypeAnnotation> typeAnnotations = TypeAnnotation.listFrom(fd);
 
     if (!isEnum) {
-      if (descriptor != null) {
-        buffer.append(GenericMain.getGenericCastTypeName(descriptor.type, TypeAnnotationWriteHelper.create(typeAnnotations)));
-      }
-      else {
-        buffer.append(ExprProcessor.getCastTypeName(fieldType, TypeAnnotationWriteHelper.create(typeAnnotations)));
-      }
+      buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? fieldType : descriptor.type, TypeAnnotationWriteHelper.create(typeAnnotations)));
       buffer.append(' ');
     }
 
@@ -524,8 +505,8 @@ public class ClassWriter {
           ((ConstExprent) initializer).adjustConstType(fieldType);
         }
 
-        // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode instruction
-        buffer.append(initializer.toJava(indent, tracer));
+        // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode instruction.
+        ExprProcessor.getCastedExprent(initializer, descriptor == null ? fieldType : descriptor.type, buffer, indent, false, tracer);
       }
     }
     else if (fd.hasModifier(CodeConstants.ACC_FINAL) && fd.hasModifier(CodeConstants.ACC_STATIC)) {
@@ -638,7 +619,7 @@ public class ClassWriter {
       boolean isDeprecated = mt.hasAttribute(StructGeneralAttribute.ATTRIBUTE_DEPRECATED);
       boolean clInit = false, dInit = false;
 
-      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
+      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt, node);
 
       int flags = mt.getAccessFlags();
       if ((flags & CodeConstants.ACC_NATIVE) != 0) {
@@ -666,25 +647,7 @@ public class ClassWriter {
         appendComment(buffer, "bridge method", indent);
       }
 
-      GenericMethodDescriptor descriptor = null;
-      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-        StructGenericSignatureAttribute attr = mt.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);
-        if (attr != null) {
-          descriptor = GenericMain.parseMethodSignature(attr.getSignature());
-          if (descriptor != null) {
-            long actualParams = md.params.length;
-            List<VarVersionPair> mask = methodWrapper.synthParameters;
-            if (mask != null) {
-              actualParams = mask.stream().filter(Objects::isNull).count();
-            }
-            if (actualParams != descriptor.parameterTypes.size()) {
-              String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor() + " in " + cl.qualifiedName;
-              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
-              descriptor = null;
-            }
-          }
-        }
-      }
+      GenericMethodDescriptor descriptor = mt.getSignature();
       appendAnnotations(buffer, indent, mt);
 
       buffer.appendIndent(indent);
@@ -726,12 +689,7 @@ public class ClassWriter {
         if (init) {
           emptyTypeAnnotations.forEach(typeAnnotation -> typeAnnotation.writeTo(buffer));
         } else {
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(descriptor.returnType, TypeAnnotationWriteHelper.create(emptyTypeAnnotations)));
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(md.ret, TypeAnnotationWriteHelper.create(emptyTypeAnnotations)));
-          }
+          buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? md.ret : descriptor.returnType, TypeAnnotationWriteHelper.create(emptyTypeAnnotations)));
           buffer.append(' ');
         }
 
@@ -748,7 +706,12 @@ public class ClassWriter {
         }
 
         int index = methodWrapper.varproc.getFirstParameterVarIndex();
+        boolean hasDescriptor = descriptor != null;
+        //mask should now have the Outer.this in it... so this *shouldn't* be nessasary.
+        //if (init && !isEnum && ((node.access & CodeConstants.ACC_STATIC) == 0) && node.type == ClassNode.CLASS_MEMBER)
+        //    index++;
         for (int i = methodWrapper.varproc.getFirstParameterPosition(); i < md.params.length; i++) {
+          VarType parameterType = hasDescriptor && !descriptor.parameterTypes.isEmpty() ? descriptor.parameterTypes.get(paramCount) : md.params[i];
           if (mask == null || mask.get(i) == null) {
             if (paramCount > 0) {
               buffer.append(", ");
@@ -765,24 +728,12 @@ public class ClassWriter {
             }
 
             String typeName;
-            boolean isVarArg = i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS);
             List<TypeAnnotation> typeParamAnnotations = TargetInfo.FormalParameterTarget.extract(typeAnnotations, i);
-            if (paramType instanceof GenericType) {
-              GenericType genParamType = (GenericType) paramType;
-              isVarArg &= genParamType.getArrayDim() > 0;
-              if (isVarArg) {
-                genParamType = genParamType.decreaseArrayDim();
-              }
-              typeName = GenericMain.getGenericCastTypeName(genParamType, TypeAnnotationWriteHelper.create(typeParamAnnotations));
-            }
-            else {
-              VarType varParamType = (VarType) paramType;
-              isVarArg &= varParamType.getArrayDim() > 0;
-              if (isVarArg) {
-                varParamType = varParamType.decreaseArrayDim();
-              }
-              typeName = ExprProcessor.getCastTypeName(varParamType, TypeAnnotationWriteHelper.create(typeParamAnnotations));
+            boolean isVarArg = i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.getArrayDim() > 0;
+            if (isVarArg) {
+                parameterType = parameterType.decreaseArrayDim();
             }
+            typeName = ExprProcessor.getCastTypeName(parameterType, TypeAnnotationWriteHelper.create(typeParamAnnotations));
 
             if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
                 DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
@@ -801,7 +752,7 @@ public class ClassWriter {
             paramCount++;
           }
 
-          index += md.params[i].getStackSize();
+          index += parameterType.getStackSize();
         }
 
         buffer.append(')');
@@ -811,19 +762,14 @@ public class ClassWriter {
           throwsExceptions = true;
           buffer.append(" throws ");
 
+          boolean useDescriptor = hasDescriptor && !descriptor.exceptionTypes.isEmpty();
           for (int i = 0; i < attr.getThrowsExceptions().size(); i++) {
             if (i > 0) {
               buffer.append(", ");
             }
             TargetInfo.ThrowsTarget.extract(typeAnnotations, i).forEach(typeAnnotation -> typeAnnotation.writeTo(buffer));
-            if (descriptor != null && !descriptor.exceptionTypes.isEmpty()) {
-              GenericType type = descriptor.exceptionTypes.get(i);
-              buffer.append(GenericMain.getGenericCastTypeName(type, Collections.emptyList()));
-            }
-            else {
-              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);
-              buffer.append(ExprProcessor.getCastTypeName(type, Collections.emptyList()));
-            }
+            VarType type = useDescriptor ? descriptor.exceptionTypes.get(i) : new VarType(attr.getExcClassname(i, cl.getPool()), true);
+            buffer.append(ExprProcessor.getCastTypeName(type, Collections.emptyList()));
           }
         }
       }
@@ -1051,7 +997,7 @@ public class ClassWriter {
 
     final List<TypeAnnotation> typeAnnotations = TypeAnnotation.listFrom(cd);
     if (descriptor != null) {
-      buffer.append(GenericMain.getGenericCastTypeName(
+      buffer.append(ExprProcessor.getCastTypeName(
         varArgComponent ? descriptor.type.decreaseArrayDim() : descriptor.type,
         TypeAnnotationWriteHelper.create(typeAnnotations)
       ));
@@ -1105,14 +1051,7 @@ public class ClassWriter {
   private static Map.Entry<VarType, GenericFieldDescriptor> getFieldTypeData(StructField fd) {
     VarType fieldType = new VarType(fd.getDescriptor(), false);
 
-    GenericFieldDescriptor descriptor = null;
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = fd.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);
-      if (attr != null) {
-        descriptor = GenericMain.parseFieldSignature(attr.getSignature());
-      }
-    }
-
+    GenericFieldDescriptor descriptor = fd.getSignature();
     return new AbstractMap.SimpleImmutableEntry<>(fieldType, descriptor);
   }
 
@@ -1249,22 +1188,11 @@ public class ClassWriter {
     }
   }
 
-  public static GenericClassDescriptor getGenericClassDescriptor(StructClass cl) {
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);
-      if (attr != null) {
-        return GenericMain.parseClassSignature(attr.getSignature());
-      }
-    }
-    return null;
-  }
-
   public static void appendTypeParameters(
-    TextBuffer buffer,
-    List<String> parameters,
-    List<? extends List<GenericType>> bounds,
-    final List<TypeAnnotation> typeAnnotations
-  ) {
+      TextBuffer buffer,
+      List<String> parameters,
+      List<List<VarType>> bounds,
+      final List<TypeAnnotation> typeAnnotations) {
     buffer.append('<');
     for (int i = 0; i < parameters.size(); i++) {
       if (i > 0) {
@@ -1272,15 +1200,15 @@ public class ClassWriter {
       }
       TargetInfo.TypeParameterTarget.extract(typeAnnotations, i).forEach(typeAnnotation -> typeAnnotation.writeTo(buffer));
       buffer.append(parameters.get(i));
-      List<GenericType> parameterBounds = bounds.get(i);
+      List<VarType> parameterBounds = bounds.get(i);
       if (parameterBounds.size() > 1 || !"java/lang/Object".equals(parameterBounds.get(0).getValue())) {
         buffer.append(" extends ");
         TargetInfo.TypeParameterBoundTarget.extract(typeAnnotations, i, 0).forEach(typeAnnotation -> typeAnnotation.writeTo(buffer));
-        buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(0), Collections.emptyList()));
+        buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(0), Collections.emptyList()));
         for (int j = 1; j < parameterBounds.size(); j++) {
           buffer.append(" & ");
           TargetInfo.TypeParameterBoundTarget.extract(typeAnnotations, i, j).forEach(typeAnnotation -> typeAnnotation.writeTo(buffer));
-          buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(j), Collections.emptyList()));
+          buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(j), Collections.emptyList()));
         }
       }
     }
@@ -1297,4 +1225,4 @@ public class ClassWriter {
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
index e2936358fa03746e00e23d30f47351c28124e09f..654d0ddf34821ce4ea800cd5421f6268e2ca3236 100644
--- a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
+++ b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
@@ -18,6 +18,8 @@ public class DecompilerContext {
   public static final String CURRENT_CLASS_WRAPPER = "CURRENT_CLASS_WRAPPER";
   public static final String CURRENT_CLASS_NODE = "CURRENT_CLASS_NODE";
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
+  public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
+  public static final String IN_CLASS_TYPE_PARAMS = "IN_CLASS_TYPE_PARAMS";
 
   private final Map<String, Object> properties;
   private final IFernflowerLogger logger;
@@ -126,4 +128,4 @@ public class DecompilerContext {
   public static BytecodeSourceMapper getBytecodeSourceMapper() {
     return getCurrentContext().bytecodeSourceMapper;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index 692c1b622ef7e065c9c970cf0a5289f9ca8869f5..f8c413c7b7302b201a739310677d0103e2878d3e 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -11,6 +11,7 @@ import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructContext;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.TextBuffer;
+import org.jetbrains.java.decompiler.util.ClasspathScanner;
 
 import java.io.File;
 import java.util.HashMap;
@@ -53,6 +54,15 @@ public class Fernflower implements IDecompiledData {
 
     DecompilerContext context = new DecompilerContext(properties, logger, structContext, classProcessor, interceptor);
     DecompilerContext.setCurrentContext(context);
+
+    String vendor = System.getProperty("java.vendor", "missing vendor");
+    String javaVersion = System.getProperty("java.version", "missing java version");
+    String jvmVersion = System.getProperty("java.vm.version", "missing jvm version");
+    logger.writeMessage(String.format("JVM info: %s - %s - %s", vendor, javaVersion, jvmVersion), IFernflowerLogger.Severity.INFO);
+
+    if (DecompilerContext.getOption(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH)) {
+      ClasspathScanner.addAllClasspath(structContext);
+    }
   }
 
   private static IIdentifierRenamer loadHelper(String className, IFernflowerLogger logger) {
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index b509376a6dbc3780f7c14c631bf51b7fc24aa50d..79108dd8772dc9444d66e6ba0cdd7f56ca382fbd 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -36,6 +36,7 @@ public interface IFernflowerPreferences {
   String VERIFY_ANONYMOUS_CLASSES = "vac";
 
   String STANDARDIZE_FLOATING_POINT_NUMBERS = "sfn";
+  String INCLUDE_ENTIRE_CLASSPATH = "iec";
 
   String LOG_LEVEL = "log";
   String MAX_PROCESSING_METHOD = "mpm";
@@ -84,6 +85,7 @@ public interface IFernflowerPreferences {
     defaults.put(VERIFY_ANONYMOUS_CLASSES, "0");
 
     defaults.put(STANDARDIZE_FLOATING_POINT_NUMBERS, "1");
+    defaults.put(INCLUDE_ENTIRE_CLASSPATH, "0");
 
     defaults.put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());
     defaults.put(MAX_PROCESSING_METHOD, "0");
diff --git a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
index 33906d3a433e4421bbf41c6aed5ff566a69a904a..c1126a2b7559e2f8a69a54ee0b7db2ceda3d9776 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
@@ -47,7 +47,7 @@ public class ClassWrapper {
     for (StructMethod mt : classStruct.getMethods()) {
       DecompilerContext.getLogger().startMethod(mt.getName() + " " + mt.getDescriptor());
 
-      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
+      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt, null);
       VarProcessor varProc = new VarProcessor(classStruct, mt, md);
       DecompilerContext.startMethod(varProc);
 
@@ -218,4 +218,4 @@ public class ClassWrapper {
   public String toString() {
     return classStruct.qualifiedName;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index a242aa9e74698b14e20e27d655a3c8ae141ee2f5..e005b2941b4e76b736b8d00905726ac8500c3dc2 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -29,6 +29,7 @@ import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 
 import java.util.*;
@@ -473,7 +474,7 @@ public class ExprProcessor implements CodeConstants {
           exprList.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,
                                        instr.opcode == opc_return ? null : stack.pop(),
                                        instr.opcode == opc_athrow ? null : methodDescriptor.ret,
-                                       offsets));
+              offsets, methodDescriptor));
           break;
         case opc_monitorenter:
         case opc_monitorexit:
@@ -685,7 +686,15 @@ public class ExprProcessor implements CodeConstants {
       sb.append("void");
       return sb.toString();
     }
+    else if (tp == CodeConstants.TYPE_GENVAR && type.isGeneric()) {
+      sb.append(type.getValue());
+      return sb.toString();
+    }
     else if (tp == CodeConstants.TYPE_OBJECT) {
+      if (type.isGeneric()) {
+        ((GenericType)type).appendCastName(sb, typeAnnWriteHelpers);
+        return sb.toString();
+      }
       String ret;
       if (getShort) {
         ret = DecompilerContext.getImportCollector().getNestedName(type.getValue());
@@ -736,7 +745,9 @@ public class ExprProcessor implements CodeConstants {
       boolean shouldWrite = true;
       if (!enclosingClasses.isEmpty() && i != nestedTypes.size() - 1) {
         String enclosingType = enclosingClasses.remove(0).simpleName;
-        shouldWrite = !nestedType.equals(enclosingType);
+        shouldWrite = !nestedType.equals(enclosingType)
+          // Also write out the enclosing class if we are the outermost, and we're in the type params
+          || enclosingClasses.isEmpty() && DecompilerContext.getOption(DecompilerContext.IN_CLASS_TYPE_PARAMS);
       }
       if (i == 0) { // first annotation can be written already
         if (!sb.toString().isEmpty()) shouldWrite = true; // write if annotation exists
@@ -952,6 +963,8 @@ public class ExprProcessor implements CodeConstants {
         tracer.incrementCurrentSourceLine();
       }
 
+      expr.getInferredExprType(null);
+
       TextBuffer content = expr.toJava(indent, tracer);
 
       if (content.length() > 0) {
@@ -1024,7 +1037,7 @@ public class ExprProcessor implements CodeConstants {
       }
     }
 
-    VarType rightType = exprent.getExprType();
+    VarType rightType = exprent.getInferredExprType(leftType);
 
     boolean cast =
       castAlways ||
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
index eb96762fa2174047a3f9dcecfb8c57bf4721c11f..dc3d20eed5ddcac36204fc9ed75d73c53a8c9805 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
@@ -722,7 +722,7 @@ public class SimplifyExprentsHelper {
                                                                                Arrays.asList(
                                                                                  statement.getHeadexprent().getCondition(),
                                                                                  ifExit.getValue(),
-                                                                                 elseExit.getValue()), ifHeadExprBytecode), ifExit.getRetType(), ifHeadExprBytecode));
+                                                                                 elseExit.getValue()), ifHeadExprBytecode), ifExit.getRetType(), ifHeadExprBytecode, ifExit.getMethodDescriptor()));
               statement.setExprents(data);
 
               StatEdge retEdge = ifStatement.getAllSuccessorEdges().get(0);
@@ -768,4 +768,4 @@ public class SimplifyExprentsHelper {
 
     return ret;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
index 6cc60fd5314369cef21bd56c12e2af8e4c56292d..c713a4055dfc5aa05143a6cd856c5bd98e05c8c1 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
@@ -5,7 +5,6 @@ import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
-import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
@@ -49,6 +48,11 @@ public class AssignmentExprent extends Exprent {
     return left.getExprType();
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBounds) {
+    return left.getInferredExprType(upperBounds);
+  }
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -89,8 +93,8 @@ public class AssignmentExprent extends Exprent {
 
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
-    VarType leftType = left.getExprType();
-    VarType rightType = right.getExprType();
+    VarType leftType = left.getInferredExprType(null);
+    VarType rightType = right.getInferredExprType(leftType);
 
     boolean fieldInClassInit = false, hiddenField = false;
     if (left.type == Exprent.EXPRENT_FIELD) { // first assignment to a final field. Field name without "this" in front of it
@@ -128,14 +132,8 @@ public class AssignmentExprent extends Exprent {
 
     TextBuffer res = right.toJava(indent, tracer);
 
-    if (condType == CONDITION_NONE &&
-        !leftType.isSuperset(rightType) &&
-        (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.getType() != CodeConstants.TYPE_OBJECT)) {
-      if (right.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
-        res.enclose("(", ")");
-      }
-
-      res.prepend("(" + ExprProcessor.getCastTypeName(leftType, Collections.emptyList()) + ")");
+    if (condType == CONDITION_NONE) {
+      this.wrapInCast(leftType, rightType, res, right.getPrecedence());
     }
 
     buffer.append(condType == CONDITION_NONE ? " = " : OPERATORS[condType]).append(res);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
index b0c626320205e7e6fac1f8ceafdffbe89a5daf41..db2a53744ffeb8b0bdc7b045a822be2df1695b4e 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
@@ -10,6 +10,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.struct.attr.StructExceptionsAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
@@ -28,19 +29,21 @@ public class ExitExprent extends Exprent {
   private final int exitType;
   private Exprent value;
   private final VarType retType;
+  private final MethodDescriptor methodDescriptor;
 
-  public ExitExprent(int exitType, Exprent value, VarType retType, BitSet bytecodeOffsets) {
+  public ExitExprent(int exitType, Exprent value, VarType retType, BitSet bytecodeOffsets, MethodDescriptor methodDescriptor) {
     super(EXPRENT_EXIT);
     this.exitType = exitType;
     this.value = value;
     this.retType = retType;
+    this.methodDescriptor = methodDescriptor;
 
     addBytecodeOffsets(bytecodeOffsets);
   }
 
   @Override
   public Exprent copy() {
-    return new ExitExprent(exitType, value == null ? null : value.copy(), retType, bytecode);
+    return new ExitExprent(exitType, value == null ? null : value.copy(), retType, bytecode, methodDescriptor);
   }
 
   @Override
@@ -72,8 +75,12 @@ public class ExitExprent extends Exprent {
       TextBuffer buffer = new TextBuffer("return");
 
       if (retType.getType() != CodeConstants.TYPE_VOID) {
+        VarType ret = retType;
+        if (methodDescriptor != null && methodDescriptor.genericInfo != null && methodDescriptor.genericInfo.returnType != null) {
+          ret = methodDescriptor.genericInfo.returnType;
+        }
         buffer.append(' ');
-        ExprProcessor.getCastedExprent(value, retType, buffer, indent, false, tracer);
+        ExprProcessor.getCastedExprent(value, ret, buffer, indent, false, false, false, false, tracer);
       }
 
       return buffer;
@@ -141,6 +148,10 @@ public class ExitExprent extends Exprent {
     return retType;
   }
 
+  public MethodDescriptor getMethodDescriptor() {
+    return this.methodDescriptor;
+  }
+
   @Override
   public void getBytecodeRange(BitSet values) {
     measureBytecode(values, value);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
index 67fc1f2beab815f0ca07ecf8a34b98fa23344749..33150f76d649f124bc818036b0f7c6331d5e74be 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
@@ -3,13 +3,20 @@
  */
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
+import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
+import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.IMatchable;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
@@ -19,8 +26,10 @@ import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 
@@ -61,6 +70,11 @@ public abstract class Exprent implements IMatchable {
     return VarType.VARTYPE_VOID;
   }
 
+  // TODO: This captures the state of upperBound, find a way to do it without modifying state?
+  public VarType getInferredExprType(VarType upperBound) {
+    return getExprType();
+  }
+
   public int getExprentUse() {
     return 0;
   }
@@ -184,6 +198,119 @@ public abstract class Exprent implements IMatchable {
       return ret;
     }
 
+  protected VarType gatherGenerics(VarType upperBound, VarType ret, List<String> fparams, List<VarType> genericArgs) {
+    Map<VarType, VarType> map = new HashMap<>();
+
+    // List<T> -> List<String>
+    if (upperBound != null && upperBound.isGeneric() && ret.isGeneric()) {
+      List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
+      List<VarType> rightArgs = ((GenericType)ret).getArguments();
+      if (leftArgs.size() == rightArgs.size() && rightArgs.size() == fparams.size()) {
+        for (int i = 0; i < leftArgs.size(); i++) {
+          VarType left = leftArgs.get(i);
+          VarType right = rightArgs.get(i);
+          if (left != null && right.getValue().equals(fparams.get(i))) {
+            genericArgs.add(left);
+            map.put(right, left);
+          } else {
+            genericArgs.clear();
+            map.clear();
+            break;
+          }
+        }
+      }
+    }
+
+    return map.isEmpty() ? ret : ret.remap(map);
+  }
+
+  protected void appendParameters(TextBuffer buf, List<VarType> genericArgs) {
+    if (genericArgs.isEmpty()) {
+      return;
+    }
+    buf.append("<");
+    //TODO: Check target output level and use <> operator?
+    for (int i = 0; i < genericArgs.size(); i++) {
+      buf.append(ExprProcessor.getCastTypeName(genericArgs.get(i), Collections.emptyList()));
+      if(i + 1 < genericArgs.size()) {
+        buf.append(", ");
+      }
+    }
+    buf.append(">");
+  }
+
+  protected Map<VarType, List<VarType>> getNamedGenerics() {
+    Map<VarType, List<VarType>> ret = new HashMap<>();
+    ClassNode class_ = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);
+    MethodWrapper method = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
+
+    //TODO: Loop enclosing classes?
+    GenericClassDescriptor cls = class_ == null ? null : class_.classStruct.getSignature();
+    if (cls != null) {
+      for (int x = 0; x < cls.fparameters.size(); x++) {
+        ret.put(GenericType.parse("T" + cls.fparameters.get(x) + ";"), cls.fbounds.get(x));
+      }
+    }
+
+    //TODO: Loop enclosing method?
+    GenericMethodDescriptor mtd = method == null ? null : method.methodStruct.getSignature();
+    if (mtd != null) {
+      for (int x = 0; x < mtd.typeParameters.size(); x++) {
+        ret.put(GenericType.parse("T" + mtd.typeParameters.get(x) + ";"), mtd.typeParameterBounds.get(x));
+      }
+    }
+
+    return ret;
+  }
+
+  protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int precedence) {
+    boolean needsCast = !left.isSuperset(right) && (right.equals(VarType.VARTYPE_OBJECT) || left.getType() != CodeConstants.TYPE_OBJECT);
+
+    if (left != null && left.isGeneric()) {
+      Map<VarType, List<VarType>> names = this.getNamedGenerics();
+      int arrayDim = 0;
+
+      if (left.getArrayDim() == right.getArrayDim()) {
+        arrayDim = left.getArrayDim();
+        left = left.resizeArrayDim(0);
+        right = right.resizeArrayDim(0);
+      }
+
+      List<? extends VarType> types = names.get(right);
+      if (types == null) {
+        types = names.get(left);
+      }
+
+      if (types != null) {
+        boolean anyMatch = false; //TODO: allMatch instead of anyMatch?
+        for (VarType type : types) {
+          if (type.equals(VarType.VARTYPE_OBJECT) && right.equals(VarType.VARTYPE_OBJECT)) {
+            continue;
+          }
+          anyMatch |= right.getValue() == null /*null const doesn't need cast*/ || DecompilerContext.getStructContext().instanceOf(right.getValue(), type.getValue());
+        }
+
+        if (anyMatch) {
+          needsCast = false;
+        }
+      }
+
+      if (arrayDim != 0) {
+        left = left.resizeArrayDim(arrayDim);
+      }
+    }
+
+    if (!needsCast) {
+      return;
+    }
+
+    if (precedence >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
+      buf.enclose("(", ")");
+    }
+
+    buf.prepend("(" + ExprProcessor.getCastTypeName(left, Collections.emptyList()) + ")");
+  }
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
index 11669fe44ea78ab7322b82c844c8b220ca1a9975..b76d5dd1f39f3ef9a2847414bcf1cc3738b0fdae 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
@@ -8,6 +8,8 @@ import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructClass;
+import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.LinkConstant;
 import org.jetbrains.java.decompiler.struct.gen.FieldDescriptor;
@@ -20,7 +22,9 @@ import org.jetbrains.java.decompiler.util.TextUtil;
 
 import java.util.ArrayList;
 import java.util.BitSet;
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 
 public class FieldExprent extends Exprent {
@@ -50,6 +54,26 @@ public class FieldExprent extends Exprent {
     return descriptor.type;
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    Map<String, Map<VarType, VarType>> types = cl == null ? Collections.emptyMap() : cl.getAllGenerics();
+
+    StructField ft = null;
+    while(cl != null) {
+      ft = cl.getField(name, descriptor.descriptorString);
+      if (ft != null)
+        break;
+      cl = cl.superClass == null ? null : DecompilerContext.getStructContext().getClass((String)cl.superClass.value);
+    }
+
+    if (ft != null && ft.getSignature() != null) {
+      return ft.getSignature().type.remap(types.getOrDefault(cl.qualifiedName, Collections.emptyMap()));
+    }
+
+    return getExprType();
+  }
+
   @Override
   public int getExprentUse() {
     return 0; // multiple references to a field considered dangerous in a multithreaded environment, thus no Exprent.MULTIPLE_USES set here
@@ -211,4 +235,4 @@ public class FieldExprent extends Exprent {
 
     return true;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
index ac2b3a50e65c46ff998173335d505cdfc8a27b21..0a6281872ae535dbc0569cb08b301d58b6c5c9a3 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
@@ -2,6 +2,8 @@
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.util.TextBuffer;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
@@ -9,7 +11,6 @@ import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.util.ListStack;
-import org.jetbrains.java.decompiler.util.TextBuffer;
 
 import java.util.*;
 
@@ -182,6 +183,7 @@ public class FunctionExprent extends Exprent {
   private int funcType;
   private VarType implicitType;
   private final List<Exprent> lstOperands;
+  private boolean needsCast = true;
 
   public FunctionExprent(int funcType, ListStack<Exprent> stack, BitSet bytecodeOffsets) {
     this(funcType, new ArrayList<>(), bytecodeOffsets);
@@ -269,6 +271,46 @@ public class FunctionExprent extends Exprent {
     return exprType;
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    if (funcType == FUNCTION_CAST) {
+      this.needsCast = true;
+      VarType right = lstOperands.get(0).getInferredExprType(upperBound);
+      VarType cast = lstOperands.get(1).getExprType();
+
+      if (upperBound != null && upperBound.isGeneric()) {
+        Map<VarType, List<VarType>> names = this.getNamedGenerics();
+        int arrayDim = 0;
+
+        if (upperBound.getArrayDim() == right.getArrayDim()) {
+          arrayDim = upperBound.getArrayDim();
+          upperBound = upperBound.resizeArrayDim(0);
+          right = right.resizeArrayDim(0);
+        }
+
+        List<VarType> types = names.get(right);
+        if (types == null) {
+          types = names.get(upperBound);
+        }
+
+        if (types != null) {
+          boolean anyMatch = false; //TODO: allMatch instead of anyMatch?
+          for (VarType type : types) {
+            anyMatch |= DecompilerContext.getStructContext().instanceOf(type.getValue(), cast.getValue());
+          }
+          if (anyMatch) {
+            this.needsCast = false;
+          }
+        }
+      }
+      else { //TODO: Capture generics to make cast better?
+        this.needsCast = right.getType() == CodeConstants.TYPE_NULL || !DecompilerContext.getStructContext().instanceOf(right.getValue(), cast.getValue());
+      }
+    }
+    return getExprType();
+  }
+
+
   @Override
   public int getExprentUse() {
     if (funcType >= FUNCTION_IMM && funcType <= FUNCTION_PPI) {
@@ -439,8 +481,12 @@ public class FunctionExprent extends Exprent {
       case FUNCTION_BIT_NOT -> wrapOperandString(lstOperands.get(0), true, indent, tracer).prepend("~");
       case FUNCTION_BOOL_NOT -> wrapOperandString(lstOperands.get(0), true, indent, tracer).prepend("!");
       case FUNCTION_NEG -> wrapOperandString(lstOperands.get(0), true, indent, tracer).prepend("-");
-      case FUNCTION_CAST -> lstOperands.get(1).toJava(indent, tracer).enclose("(", ")")
-        .append(wrapOperandString(lstOperands.get(0), true, indent, tracer));
+      case FUNCTION_CAST -> {
+        if (!needsCast) {
+          yield lstOperands.get(0).toJava(indent, tracer);
+        }
+        yield lstOperands.get(1).toJava(indent, tracer).enclose("(", ")").append(wrapOperandString(lstOperands.get(0), true, indent, tracer));
+      }
       case FUNCTION_ARRAY_LENGTH -> {
         Exprent arr = lstOperands.get(0);
         TextBuffer res = wrapOperandString(arr, false, indent, tracer);
@@ -571,7 +617,7 @@ public class FunctionExprent extends Exprent {
     measureBytecode(values, lstOperands);
     measureBytecode(values);
   }
-  
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index 8d2ce0f8f4d4368f87ed596e4e76442ff97fed19..6eab93e5ed261b0903ae3fe4677118bfa2d1d60e 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -19,6 +19,8 @@ import org.jetbrains.java.decompiler.struct.consts.LinkConstant;
 import org.jetbrains.java.decompiler.struct.consts.PooledConstant;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -56,6 +58,7 @@ public class InvocationExprent extends Exprent {
   private int invocationType = INVOKE_VIRTUAL;
   private List<Exprent> parameters = new ArrayList<>();
   private List<PooledConstant> bootstrapArguments;
+  private List<VarType> genericArgs = new ArrayList<>();
 
   public InvocationExprent() {
     super(EXPRENT_INVOCATION);
@@ -158,6 +161,55 @@ public class InvocationExprent extends Exprent {
     return descriptor.ret;
   }
 
+
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    List<StructMethod> matches = getMatchedDescriptors();
+    StructMethod desc = null;
+    if(matches.size() == 1) {
+      desc = matches.get(0);
+    }
+
+    genericArgs.clear();
+
+    if (desc != null && desc.getSignature() != null) {
+      VarType ret = desc.getSignature().returnType;
+
+      if (instance != null) {
+        VarType instType = instance.getInferredExprType(upperBound);
+
+        if (instType.isGeneric()) {
+          StructClass cls = DecompilerContext.getStructContext().getClass(instType.getValue());
+
+          if (cls != null && cls.getSignature() != null) {
+            Map<VarType, VarType> map = new HashMap<>();
+            GenericType ginstance = (GenericType)instType;
+
+            if (cls.getSignature().fparameters.size() == ginstance.getArguments().size()) {
+              for (int x = 0; x < ginstance.getArguments().size(); x++) {
+                if (ginstance.getArguments().get(x) != null) { //TODO: Wildcards are null arguments.. look into fixing things?
+                  map.put(GenericType.parse("T" + cls.getSignature().fparameters.get(x) + ";"), ginstance.getArguments().get(x));
+                }
+              }
+            }
+
+            if (!map.isEmpty()) {
+              ret = ret.remap(map);
+            }
+          }
+        }
+      }
+
+      VarType _new = this.gatherGenerics(upperBound, ret, desc.getSignature().typeParameters, genericArgs);
+      if (desc.getSignature().returnType != _new) {
+        return _new;
+      }
+    }
+
+    return getExprType();
+  }
+
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -290,6 +342,7 @@ public class InvocationExprent extends Exprent {
 
         if (buf.length() > 0) {
           buf.append(".");
+          this.appendParameters(buf, genericArgs);
         }
 
         buf.append(name);
@@ -324,8 +377,30 @@ public class InvocationExprent extends Exprent {
         isEnum = newNode.classStruct.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
       }
     }
+    List<StructMethod> matches = getMatchedDescriptors();
+    BitSet setAmbiguousParameters = getAmbiguousParameters(matches);
+    StructMethod desc = null;
+    if(matches.size() == 1) {
+      desc = matches.get(0);
+    }
 
-    BitSet setAmbiguousParameters = getAmbiguousParameters();
+    StructClass cl = DecompilerContext.getStructContext().getClass(className);
+    Map<VarType, VarType> genArgs = new HashMap<>();
+
+    // building generic info from the instance
+    VarType inferred = instance == null ? null : instance.getInferredExprType(null);
+    if (cl != null && cl.getSignature() != null && instance != null && inferred.isGeneric()) {
+      GenericType genType = (GenericType)inferred;
+      if (genType.getArguments().size() == cl.getSignature().fparameters.size()) {
+        for (int i = 0; i < cl.getSignature().fparameters.size(); i++) {
+          VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
+          VarType to = genType.getArguments().get(i);
+          if (from != null && to != null) {
+            genArgs.put(from, to);
+          }
+        }
+      }
+    }
 
     // omit 'new Type[] {}' for the last parameter of a vararg method call
     if (parameters.size() == descriptor.params.length && isVarArgCall()) {
@@ -341,6 +416,34 @@ public class InvocationExprent extends Exprent {
       if (mask == null || mask.get(i) == null) {
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
+        /*
+        VarType type = descriptor.params[i];
+
+        // using info from the generic signature
+        if (desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+          type = desc.getSignature().params.get(i);
+        }
+
+        // applying generic info from the signature
+        VarType remappedType = type.remap(genArgs);
+        if(type != remappedType) {
+          type = remappedType;
+        }
+        else if (desc != null && desc.getSignature() != null && genericArgs.size() != 0) { // and from the inferred generic arguments
+          Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
+          for (int j = 0; j < genericArgs.size(); j++) {
+            VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
+            VarType to = genericArgs.get(j);
+            genMap.put(from, to);
+          }
+        }
+
+        // not passing it along if what we get back is more specific
+        VarType exprType = lstParameters.get(i).getInferredExprType(type);
+        if (exprType != null && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+          //type = exprType;
+        }
+        */
 
         // 'byte' and 'short' literals need an explicit narrowing type cast when used as a parameter
         ExprProcessor.getCastedExprent(parameters.get(i), descriptor.params[i], buff, indent, true, ambiguous, true, true, tracer);
@@ -447,12 +550,11 @@ public class InvocationExprent extends Exprent {
     return !isStatic && parameters.size() == 0 && className.equals(UNBOXING_METHODS.get(name));
   }
 
-  private BitSet getAmbiguousParameters() {
+  private List<StructMethod> getMatchedDescriptors() {
+    List<StructMethod> matches = new ArrayList<>();
     StructClass cl = DecompilerContext.getStructContext().getClass(className);
-    if (cl == null) return EMPTY_BIT_SET;
+    if (cl == null) return matches;
 
-    // check number of matches
-    List<MethodDescriptor> matches = new ArrayList<>();
     nextMethod:
     for (StructMethod mt : cl.getMethods()) {
       if (name.equals(mt.getName())) {
@@ -463,11 +565,19 @@ public class InvocationExprent extends Exprent {
               continue nextMethod;
             }
           }
-          matches.add(md);
+          matches.add(mt);
         }
       }
     }
-    if (matches.size() == 1) return EMPTY_BIT_SET;
+
+    return matches;
+  }
+
+  private BitSet getAmbiguousParameters(List<StructMethod> matches) {
+    StructClass cl = DecompilerContext.getStructContext().getClass(className);
+    if (cl == null || matches.size() == 1) {
+      return EMPTY_BIT_SET;
+    }
 
     // check if a call is unambiguous
     StructMethod mt = cl.getMethod(InterpreterUtil.makeUniqueKey(name, stringDescriptor));
@@ -489,7 +599,14 @@ public class InvocationExprent extends Exprent {
     BitSet ambiguous = new BitSet(descriptor.params.length);
     for (int i = 0; i < descriptor.params.length; i++) {
       VarType paramType = descriptor.params[i];
-      for (MethodDescriptor md : matches) {
+      for (StructMethod mtt : matches) {
+
+        GenericMethodDescriptor gen = mtt.getSignature(); //TODO: Find synthetic flags for params, as Enum generic signatures do no contain the String,int params
+        if (gen != null && gen.parameterTypes.size() > i && gen.parameterTypes.get(i).isGeneric()) {
+          break;
+        }
+
+        MethodDescriptor md = MethodDescriptor.parseDescriptor(mtt.getDescriptor());
         if (!paramType.equals(md.params[i])) {
           ambiguous.set(i);
           break;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
index 6df45768b067fd2e01ffd61bb157158cb369ad7e..2501863f7396c721a42eaab481b2c89d88209d23 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
@@ -14,7 +14,6 @@ import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.ListStack;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 
@@ -30,6 +29,7 @@ public class NewExprent extends Exprent {
   private boolean anonymous;
   private boolean lambda;
   private boolean enumConst;
+  private List<VarType> genericArgs = new ArrayList<>();
 
   public NewExprent(VarType newType, ListStack<Exprent> stack, int arrayDim, BitSet bytecodeOffsets) {
     this(newType, getDimensions(arrayDim, stack), bytecodeOffsets);
@@ -68,6 +68,24 @@ public class NewExprent extends Exprent {
     return anonymous ? DecompilerContext.getClassProcessor().getMapRootClasses().get(newType.getValue()).anonymousClassType : newType;
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    genericArgs.clear();
+    if (newType.getType() == CodeConstants.TYPE_OBJECT && newType.getArrayDim() == 0) {
+      StructClass node = DecompilerContext.getStructContext().getClass(newType.getValue());
+
+      if (node != null && node.getSignature() != null) {
+        GenericClassDescriptor sig = node.getSignature();
+        VarType _new = this.gatherGenerics(upperBound, sig.genericType, sig.fparameters, genericArgs);
+        if (sig.genericType != _new) {
+          return _new;
+        }
+      }
+    }
+
+    return getExprType();
+  }
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -169,17 +187,17 @@ public class NewExprent extends Exprent {
             }
           }
 
-          GenericClassDescriptor descriptor = ClassWriter.getGenericClassDescriptor(child.classStruct);
+          GenericClassDescriptor descriptor = child.getWrapper().getClassStruct().getSignature();
           if (descriptor != null) {
             if (descriptor.superinterfaces.isEmpty()) {
-              buf.append(GenericMain.getGenericCastTypeName(descriptor.superclass, Collections.emptyList()));
+              buf.append(ExprProcessor.getCastTypeName(descriptor.superclass, Collections.emptyList()));
             }
             else {
               if (descriptor.superinterfaces.size() > 1 && !lambda) {
                 DecompilerContext.getLogger().writeMessage("Inconsistent anonymous class signature: " + child.classStruct.qualifiedName,
                                                            IFernflowerLogger.Severity.WARN);
               }
-              buf.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(0), Collections.emptyList()));
+              buf.append(ExprProcessor.getCastTypeName(descriptor.superinterfaces.get(0), Collections.emptyList()));
             }
           }
           else {
@@ -188,6 +206,7 @@ public class NewExprent extends Exprent {
         }
       }
 
+      appendParameters(buf, genericArgs);
       buf.append('(');
 
       if (!lambda && constructor != null) {
@@ -279,6 +298,7 @@ public class NewExprent extends Exprent {
 
         int start = enumConst ? 2 : 0;
         if (!enumConst || start < parameters.size()) {
+          appendParameters(buf, genericArgs);
           buf.append('(');
 
           boolean firstParam = true;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index 2fda2ba5fc05992faf891d2af14910023228c6b6..9ba49d3d3ee30e6e8db7cacd836f7f627ecb4b67 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -20,6 +20,7 @@ import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTypeTableAtt
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -62,6 +63,22 @@ public class VarExprent extends Exprent {
     return getVarType();
   }
 
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    if (lvt != null && lvt.getSignature() != null) {
+      // TODO; figure out why it's crashing, ugly fix for now
+      try {
+        return GenericType.parse(lvt.getSignature());
+      } catch (StringIndexOutOfBoundsException ex) {
+        ex.printStackTrace();
+      }
+    }
+    else if (lvt != null) {
+      return lvt.getVarType();
+    }
+    return getVarType();
+  }
+
   @Override
   public int getExprentUse() {
     return Exprent.MULTIPLE_USES | Exprent.SIDE_EFFECTS_FREE;
@@ -139,7 +156,7 @@ public class VarExprent extends Exprent {
           if (lvt.getSignature() != null) {
             GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(lvt.getSignature());
             if (descriptor != null) {
-              buffer.append(GenericMain.getGenericCastTypeName(descriptor.type, Collections.emptyList()));
+              buffer.append(ExprProcessor.getCastTypeName(descriptor.type, Collections.emptyList()));
               return;
             }
           }
@@ -165,7 +182,7 @@ public class VarExprent extends Exprent {
               if (signature != null) {
                 GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(signature);
                 if (descriptor != null) {
-                  buffer.append(GenericMain.getGenericCastTypeName(descriptor.type, Collections.emptyList()));
+                  buffer.append(ExprProcessor.getCastTypeName(descriptor.type, Collections.emptyList()));
                   return;
                 }
               }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
index 018d3fbdf53036db90b6c64e872098542133b630..d58218e0baa786456f15a14ef23a8d82d466ba18 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
@@ -107,6 +107,7 @@ public final class DoStatement extends Statement {
       }
       case FOREACH -> {
         buf.appendIndent(indent).append("for(").append(initExprent.get(0).toJava(indent, tracer));
+        incExprent.get(0).getInferredExprType(null); //TODO: Find a better then null? For now just calls it to clear casts if needed
         buf.append(" : ").append(incExprent.get(0).toJava(indent, tracer)).append(") {").appendLineSeparator();
         tracer.incrementCurrentSourceLine();
         buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 6f8a2619c728d168431673b14f53b94ba783cf2f..abe421340550d258edce046fc901479fa027a23e 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -24,7 +24,6 @@ import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute.LocalVariable;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 
 import java.util.*;
@@ -987,7 +986,7 @@ public class VarDefinitionHelper {
 
     private VarInfo(LocalVariable lvt, VarType type) {
       if (lvt != null && lvt.getSignature() != null)
-        this.cast = GenericMain.getGenericCastTypeName(new GenericType(lvt.getSignature()), Collections.emptyList());
+        this.cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSignature()), true, Collections.emptyList());
       else if (lvt != null)
         this.cast = ExprProcessor.getCastTypeName(lvt.getVarType(), false, Collections.emptyList());
       else if (type != null)
diff --git a/src/org/jetbrains/java/decompiler/struct/StructClass.java b/src/org/jetbrains/java/decompiler/struct/StructClass.java
index 0b4275f57e3092623c4e462b032b418cf2bdd84b..bead2d172e27075e63f6977562988041a96a4371 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructClass.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructClass.java
@@ -2,20 +2,32 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructPermittedSubclassesAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructRecordAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
 import org.jetbrains.java.decompiler.struct.gen.Type;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
 import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
 
 /*
   class_file {
@@ -76,8 +88,16 @@ public class StructClass extends StructMember {
 
     Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);
 
+    GenericClassDescriptor signature = null;
+    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signatureAttr = (StructGenericSignatureAttribute)attributes.get(StructGeneralAttribute.ATTRIBUTE_SIGNATURE.name);
+      if (signatureAttr != null) {
+        signature = GenericMain.parseClassSignature(qualifiedName, signatureAttr.getSignature());
+      }
+    }
+
     StructClass cl = new StructClass(
-      accessFlags, attributes, qualifiedName, superClass, own, loader, minorVersion, majorVersion, interfaces, interfaceNames, fields, methods);
+      accessFlags, attributes, qualifiedName, superClass, own, loader, minorVersion, majorVersion, interfaces, interfaceNames, fields, methods, signature);
     if (loader == null) cl.pool = pool;
     return cl;
   }
@@ -92,6 +112,7 @@ public class StructClass extends StructMember {
   private final String[] interfaceNames;
   private final VBStyleCollection<StructField, String> fields;
   private final VBStyleCollection<StructMethod, String> methods;
+  private final GenericClassDescriptor signature;
 
   private ConstantPool pool;
 
@@ -106,7 +127,8 @@ public class StructClass extends StructMember {
                       int[] interfaces,
                       String[] interfaceNames,
                       VBStyleCollection<StructField, String> fields,
-                      VBStyleCollection<StructMethod, String> methods) {
+                      VBStyleCollection<StructMethod, String> methods,
+                      GenericClassDescriptor signature) {
     super(accessFlags, attributes);
     this.qualifiedName = qualifiedName;
     this.superClass = superClass;
@@ -118,6 +140,7 @@ public class StructClass extends StructMember {
     this.interfaceNames = interfaceNames;
     this.fields = fields;
     this.methods = methods;
+    this.signature = signature;
   }
 
   public boolean hasField(String name, String descriptor) {
@@ -242,4 +265,106 @@ public class StructClass extends StructMember {
   protected Type getType() {
     return null;
   }
+
+  public GenericClassDescriptor getSignature() {
+    return signature;
+  }
+
+  private Map<VarType, VarType> getGenericMap(VarType type) {
+    if (this.signature == null || type == null || !type.isGeneric()) {
+      return Collections.emptyMap();
+    }
+    GenericType gtype = (GenericType)type;
+    if (gtype.getArguments().size() != this.signature.fparameters.size()) { //Invalid instance type?
+      return Collections.emptyMap();
+    }
+
+    Map<VarType, VarType> ret = new HashMap<>();
+    for (int x = 0; x < this.signature.fparameters.size(); x++) {
+      VarType var = gtype.getArguments().get(x);
+      if (var != null) {
+        ret.put(GenericType.parse("T" + this.signature.fparameters.get(x) + ";"), var);
+      }
+    }
+    return ret;
+  }
+
+  private Map<String, Map<VarType, VarType>> genericHiarachy;
+  public Map<String, Map<VarType, VarType>> getAllGenerics() {
+    if (genericHiarachy != null) {
+      return genericHiarachy;
+    }
+
+    Map<String, Map<VarType, VarType>> ret = new HashMap<>();
+    if (this.signature != null && !this.signature.fparameters.isEmpty()) {
+      Map<VarType, VarType> mine = new HashMap<>();
+      for (String par : this.signature.fparameters) {
+        VarType type = GenericType.parse("T" + par + ";");
+        mine.put(type, type);
+      }
+      ret.put(this.qualifiedName, mine);
+    }
+
+    Set<String> visited = new HashSet<>(); //Is there a better way? Is the signature forced to contain all interfaces?
+    if (this.signature != null) {
+      for (VarType intf : this.signature.superinterfaces) {
+        visited.add(intf.getValue());
+
+        StructClass cls = DecompilerContext.getStructContext().getClass(intf.getValue());
+        if (cls != null) {
+          Map<VarType, VarType> sig = cls.getGenericMap(intf);
+
+          for (Entry<String, Map<VarType, VarType>> e : cls.getAllGenerics().entrySet()) {
+            if (e.getValue().isEmpty()) {
+              ret.put(e.getKey(), e.getValue());
+            }
+            else {
+              Map<VarType, VarType> sub = new HashMap<>();
+              for (Entry<VarType, VarType> e2 : e.getValue().entrySet()) {
+                sub.put(e2.getKey(), sig.getOrDefault(e2.getValue(), e2.getValue()));
+              }
+              ret.put(e.getKey(), sub);
+            }
+          }
+        }
+      }
+    }
+
+    for (String intf : this.interfaceNames) {
+      if (visited.contains(intf)) {
+        continue;
+      }
+      StructClass cls = DecompilerContext.getStructContext().getClass(intf);
+      if (cls != null) {
+        ret.putAll(cls.getAllGenerics());
+      }
+    }
+
+    if (this.superClass != null) {
+      StructClass cls = DecompilerContext.getStructContext().getClass((String)this.superClass.value);
+      if (cls != null) {
+        Map<VarType, VarType> sig = this.signature == null ? Collections.emptyMap() : cls.getGenericMap(this.signature.superclass);
+        if (sig.isEmpty()) {
+          ret.putAll(cls.getAllGenerics());
+        }
+        else {
+          for (Entry<String, Map<VarType, VarType>> e : cls.getAllGenerics().entrySet()) {
+            if (e.getValue().isEmpty()) {
+              ret.put(e.getKey(), e.getValue());
+            }
+            else {
+              Map<VarType, VarType> sub = new HashMap<>();
+              for (Entry<VarType, VarType> e2 : e.getValue().entrySet()) {
+                sub.put(e2.getKey(), sig.getOrDefault(e2.getValue(), e2.getValue()));
+              }
+              ret.put(e.getKey(), sub);
+            }
+          }
+        }
+      }
+    }
+
+    this.genericHiarachy = ret.isEmpty() ? Collections.emptyMap() : ret;
+    return this.genericHiarachy;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructContext.java b/src/org/jetbrains/java/decompiler/struct/StructContext.java
index 2f55882afdd1dd1b9960aa0c2a007069204797e9..85fc95d87bd7e672613f6c1beb75b2d56d1d759f 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructContext.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructContext.java
@@ -161,6 +161,19 @@ public class StructContext {
     }
   }
 
+  public void addData(String path, String cls, byte[] data, boolean isOwn) throws IOException {
+        ContextUnit unit = units.get(path);
+        if (unit == null) {
+          unit = new ContextUnit(ContextUnit.TYPE_FOLDER, path, cls, isOwn, saver, decompiledData);
+          units.put(path, unit);
+        }
+
+        StructClass cl = StructClass.create(new DataInputFullStream(data), isOwn, loader);
+        classes.put(cl.qualifiedName, cl);
+        unit.addClass(cl, cls);
+        loader.addClassLink(cl.qualifiedName, new LazyLoader.Link(path, cls, data));
+  }
+
   public Map<String, StructClass> getClasses() {
     return classes;
   }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructField.java b/src/org/jetbrains/java/decompiler/struct/StructField.java
index 0d6df7e05b9b385e743c85261b77215314167989..da073261717d3583fc91b6c9c30351ce439da80c 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructField.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructField.java
@@ -1,10 +1,15 @@
 // Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
@@ -28,17 +33,30 @@ public class StructField extends StructMember {
     String[] values = pool.getClassElement(ConstantPool.FIELD, clQualifiedName, nameIndex, descriptorIndex);
 
     Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);
+    GenericFieldDescriptor signature = null;
+    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signatureAttr = (StructGenericSignatureAttribute)attributes.get(StructGeneralAttribute.ATTRIBUTE_SIGNATURE.name);
+      if (signatureAttr != null) {
+        signature = GenericMain.parseFieldSignature(signatureAttr.getSignature());
+      }
+    }
 
-    return new StructField(accessFlags, attributes, values[0], values[1]);
+    return new StructField(accessFlags, attributes, values[0], values[1], signature);
   }
 
   private final String name;
   private final String descriptor;
+  private final GenericFieldDescriptor signature;
 
   protected StructField(int accessFlags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor) {
+    this(accessFlags, attributes, name, descriptor, null);
+  }
+
+  protected StructField(int accessFlags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor, GenericFieldDescriptor signature) {
     super(accessFlags, attributes);
     this.name = name;
     this.descriptor = descriptor;
+    this.signature = signature;
   }
 
   public final String getName() {
@@ -58,4 +76,8 @@ public class StructField extends StructMember {
   protected Type getType() {
     return new VarType(descriptor);
   }
+
+  public GenericFieldDescriptor getSignature() {
+    return signature;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index 0a7e5ba44d82f1923dadd9f79627d91f82b1014c..d48e950e7511d2a00ac9885d5dc7d4ff524bbb37 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -2,12 +2,17 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructCodeAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.Type;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
@@ -41,7 +46,15 @@ public class StructMethod extends StructMember {
       attributes.putAll(code.codeAttributes);
     }
 
-    return new StructMethod(accessFlags, attributes, values[0], values[1], bytecodeVersion, own ? code : null, clQualifiedName);
+    GenericMethodDescriptor signature = null;
+    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signatureAttr = (StructGenericSignatureAttribute)attributes.get(StructGeneralAttribute.ATTRIBUTE_SIGNATURE.name);
+      if (signatureAttr != null) {
+        signature = GenericMain.parseMethodSignature(signatureAttr.getSignature());
+      }
+    }
+
+    return new StructMethod(accessFlags, attributes, values[0], values[1], bytecodeVersion, own ? code : null, clQualifiedName, signature);
   }
 
   private static final int[] opr_iconst = {-1, 0, 1, 2, 3, 4, 5};
@@ -58,6 +71,7 @@ public class StructMethod extends StructMember {
   private InstructionSequence seq = null;
   private boolean expanded = false;
   private final String classQualifiedName;
+  private final GenericMethodDescriptor signature;
 
   private StructMethod(int accessFlags,
                        Map<String, StructGeneralAttribute> attributes,
@@ -65,7 +79,8 @@ public class StructMethod extends StructMember {
                        String descriptor,
                        int bytecodeVersion,
                        StructCodeAttribute code,
-                       String classQualifiedName) {
+                       String classQualifiedName,
+                       GenericMethodDescriptor signature) {
     super(accessFlags, attributes);
     this.name = name;
     this.descriptor = descriptor;
@@ -79,6 +94,7 @@ public class StructMethod extends StructMember {
       this.localVariables = this.codeLength = this.codeFullLength = -1;
     }
     this.classQualifiedName = classQualifiedName;
+    this.signature = signature;
   }
 
   public void expandData(StructClass classStruct) throws IOException {
@@ -339,4 +355,8 @@ public class StructMethod extends StructMember {
   public String getClassQualifiedName() {
     return classQualifiedName;
   }
+
+  public GenericMethodDescriptor getSignature() {
+    return signature;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java b/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java
index e50983daf2a1bf6c93ec92c99221587d7c4f7c6a..11fa1a3e621221a09c0e611a7f912932f5890fc6 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java
@@ -1,9 +1,14 @@
 // Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct;
 
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
@@ -26,11 +31,18 @@ public class StructRecordComponent extends StructField {
     String descriptor = ((PrimitiveConstant)pool.getConstant(descriptorIndex)).getString();
 
     Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);
+    GenericFieldDescriptor signature = null;
+    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signatureAttr = (StructGenericSignatureAttribute)attributes.get(StructGeneralAttribute.ATTRIBUTE_SIGNATURE.name);
+      if (signatureAttr != null) {
+        signature = GenericMain.parseFieldSignature(signatureAttr.getSignature());
+      }
+    }
 
-    return new StructRecordComponent(0, attributes, name, descriptor);
+    return new StructRecordComponent(0, attributes, name, descriptor, signature);
   }
 
-  private StructRecordComponent(int flags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor) {
-    super(flags, attributes, name, descriptor);
+  private StructRecordComponent(int flags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor, GenericFieldDescriptor signature) {
+    super(flags, attributes, name, descriptor, signature);
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
index 7007b680a005a28a5d919e5e9e4298ed6c0ec566..49494925b2d67b95920bb2b8c8371e886341492f 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
@@ -2,14 +2,24 @@
 package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 
 public final class MethodDescriptor {
   public final VarType[] params;
   public final VarType ret;
+  public GenericMethodDescriptor genericInfo;
 
   private MethodDescriptor(VarType[] params, VarType ret) {
     this.params = params;
@@ -64,6 +74,35 @@ public final class MethodDescriptor {
     return new MethodDescriptor(params, ret);
   }
 
+  public static MethodDescriptor parseDescriptor(StructMethod struct, ClassNode node) {
+    MethodDescriptor md = MethodDescriptor.parseDescriptor(struct.getDescriptor());
+
+    GenericMethodDescriptor sig = struct.getSignature();
+    if (sig != null) {
+      if (node != null) {
+        MethodWrapper methodWrapper = node.getWrapper().getMethodWrapper(struct.getName(), struct.getDescriptor());
+        boolean init = CodeConstants.INIT_NAME.equals(struct.getName()) && node.type != ClassNode.CLASS_ANONYMOUS;
+        long actualParams = md.params.length;
+        List<VarVersionPair> sigFields = methodWrapper == null ? null : methodWrapper.synthParameters;
+        if (sigFields != null) {
+          actualParams = sigFields.stream().filter(Objects::isNull).count();
+        }
+        if (actualParams != sig.parameterTypes.size()) {
+          String message = "Inconsistent generic signature in method " + struct.getName() + " " + struct.getDescriptor() + " in " + struct.getClassQualifiedName();
+          DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+          sig = null;
+        }
+      }
+      md.addGenericDescriptor(sig);
+    }
+
+    return md;
+  }
+
+  public void addGenericDescriptor(GenericMethodDescriptor desc) {
+    this.genericInfo = desc;
+  }
+
   public String buildNewDescriptor(NewClassNameBuilder builder) {
     boolean updated = false;
 
@@ -126,4 +165,4 @@ public final class MethodDescriptor {
     result = 31 * result + params.length;
     return result;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
index 30b31f5604f0c1566c536737aa7d9c61363e08c5..44d120256a8020b833567fe0f24c7b2c67caafde 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
@@ -3,6 +3,7 @@ package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
 
+import java.util.Map;
 import java.util.Objects;
 
 public class VarType implements Type {  // TODO: optimize switch
@@ -50,7 +51,7 @@ public class VarType implements Type {  // TODO: optimize switch
     this(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
   }
 
-  private VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
+  protected VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
     this.type = type;
     this.arrayDim = arrayDim;
     this.value = value;
@@ -147,7 +148,7 @@ public class VarType implements Type {  // TODO: optimize switch
     };
   }
 
-  private static int getStackSize(int type, int arrayDim) {
+  protected static int getStackSize(int type, int arrayDim) {
     if (arrayDim > 0) {
       return 1;
     }
@@ -159,7 +160,7 @@ public class VarType implements Type {  // TODO: optimize switch
     };
   }
 
-  private static int getFamily(int type, int arrayDim) {
+  protected static int getFamily(int type, int arrayDim) {
     if (arrayDim > 0) {
       return CodeConstants.TYPE_FAMILY_OBJECT;
     }
@@ -248,6 +249,15 @@ public class VarType implements Type {  // TODO: optimize switch
     return res;
   }
 
+  @Override
+  public int hashCode() {
+    int result = 1;
+    result = 37 * result + type;
+    result = 37 * result + arrayDim;
+    result = 37 * result + (value == null ? 0 : value.hashCode());
+    return result;
+  }
+
   @Override
   public boolean equals(Object o) {
     if (o == this) {
@@ -374,4 +384,15 @@ public class VarType implements Type {  // TODO: optimize switch
       default -> throw new IllegalArgumentException("Invalid type: " + c);
     };
   }
+
+  public boolean isGeneric() {
+    return false;
+  }
+
+  public VarType remap(Map<VarType, VarType> map) {
+    if (map.containsKey(this)) {
+      return map.get(this);
+    }
+    return this;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
index ad623a2ab64debaf17974ae0a0757986f4cfbadf..ae2a3dd9085efea75979bbac66b1af29c52aa138 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
@@ -4,13 +4,17 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericClassDescriptor {
 
-  public GenericType superclass;
+  public VarType superclass;
+
+  public GenericType genericType;
 
-  public final List<GenericType> superinterfaces = new ArrayList<>();
+  public final List<VarType> superinterfaces = new ArrayList<>();
 
   public final List<String> fparameters = new ArrayList<>();
 
-  public final List<List<GenericType>> fbounds = new ArrayList<>();
+  public final List<List<VarType>> fbounds = new ArrayList<>();
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
index a65181762765bfdc9d2ee5695f3ffa68b7768b74..2b0fdf1dad01ec62f3e21f372297c124d859e8ff 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
@@ -1,10 +1,12 @@
 // Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericFieldDescriptor {
-  public final GenericType type;
+  public final VarType type;
 
-  public GenericFieldDescriptor(GenericType type) {
+  public GenericFieldDescriptor(VarType type) {
     this.type = type;
   }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
index 315786d5a56e2871a1d0829760b672398a17d972..16aa2ee5a55fa9ba832909cdd9f5043f5d3e7ba7 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
@@ -7,9 +7,9 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypeAnnotationWriteHelper;
 import org.jetbrains.java.decompiler.struct.StructTypePathEntry;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -26,7 +26,7 @@ public final class GenericMain {
     "boolean",
   };
 
-  public static GenericClassDescriptor parseClassSignature(String signature) {
+  public static GenericClassDescriptor parseClassSignature(String qualifiedName, String signature) {
     String original = signature;
     try {
       GenericClassDescriptor descriptor = new GenericClassDescriptor();
@@ -34,15 +34,23 @@ public final class GenericMain {
       signature = parseFormalParameters(signature, descriptor.fparameters, descriptor.fbounds);
 
       String superCl = GenericType.getNextType(signature);
-      descriptor.superclass = new GenericType(superCl);
+      descriptor.superclass = GenericType.parse(superCl);
 
       signature = signature.substring(superCl.length());
       while (signature.length() > 0) {
         String superIf = GenericType.getNextType(signature);
-        descriptor.superinterfaces.add(new GenericType(superIf));
+        descriptor.superinterfaces.add(GenericType.parse(superIf));
         signature = signature.substring(superIf.length());
       }
 
+      StringBuilder buf = new StringBuilder();
+      buf.append('L').append(qualifiedName).append('<');
+      for (String t : descriptor.fparameters) {
+        buf.append('T').append(t).append(';');
+      }
+      buf.append(">;");
+      descriptor.genericType = (GenericType)GenericType.parse(buf.toString());
+
       return descriptor;
     }
     catch (RuntimeException e) {
@@ -53,7 +61,7 @@ public final class GenericMain {
 
   public static GenericFieldDescriptor parseFieldSignature(String signature) {
     try {
-      return new GenericFieldDescriptor(new GenericType(signature));
+      return new GenericFieldDescriptor(GenericType.parse(signature));
     }
     catch (RuntimeException e) {
       DecompilerContext.getLogger().writeMessage("Invalid signature: " + signature, IFernflowerLogger.Severity.WARN);
@@ -65,29 +73,29 @@ public final class GenericMain {
     String original = signature;
     try {
       List<String> typeParameters = new ArrayList<>();
-      List<List<GenericType>> typeParameterBounds = new ArrayList<>();
+      List<List<VarType>> typeParameterBounds = new ArrayList<>();
       signature = parseFormalParameters(signature, typeParameters, typeParameterBounds);
 
       int to = signature.indexOf(")");
       String parameters = signature.substring(1, to);
       signature = signature.substring(to + 1);
 
-      List<GenericType> parameterTypes = new ArrayList<>();
+      List<VarType> parameterTypes = new ArrayList<>();
       while (parameters.length() > 0) {
         String par = GenericType.getNextType(parameters);
-        parameterTypes.add(new GenericType(par));
+        parameterTypes.add(GenericType.parse(par));
         parameters = parameters.substring(par.length());
       }
 
       String ret = GenericType.getNextType(signature);
-      GenericType returnType = new GenericType(ret);
+      VarType returnType = GenericType.parse(ret);
       signature = signature.substring(ret.length());
 
-      List<GenericType> exceptionTypes = new ArrayList<>();
+      List<VarType> exceptionTypes = new ArrayList<>();
       if (signature.length() > 0) {
         String[] exceptions = signature.split("\\^");
         for (int i = 1; i < exceptions.length; i++) {
-          exceptionTypes.add(new GenericType(exceptions[i]));
+          exceptionTypes.add(GenericType.parse(exceptions[i]));
         }
       }
 
@@ -99,7 +107,7 @@ public final class GenericMain {
     }
   }
 
-  private static String parseFormalParameters(String signature, List<? super String> parameters, List<? super List<GenericType>> bounds) {
+  private static String parseFormalParameters(String signature, List<String> parameters, List<List<VarType>> bounds) {
     if (signature.charAt(0) != '<') {
       return signature;
     }
@@ -131,7 +139,7 @@ public final class GenericMain {
       String param = value.substring(0, to);
       value = value.substring(to + 1);
 
-      List<GenericType> lstBounds = new ArrayList<>();
+      List<VarType> lstBounds = new ArrayList<>();
 
       while (true) {
         if (value.charAt(0) == ':') {
@@ -140,7 +148,7 @@ public final class GenericMain {
         }
 
         String bound = GenericType.getNextType(value);
-        lstBounds.add(new GenericType(bound));
+        lstBounds.add(GenericType.parse(bound));
         value = value.substring(bound.length());
 
 
@@ -183,77 +191,14 @@ public final class GenericMain {
     }
     else if (tp == CodeConstants.TYPE_OBJECT) {
       StringBuilder sb = new StringBuilder();
-      appendClassName(type, sb, typeAnnWriteHelpers);
+      type.appendCastName(sb, typeAnnWriteHelpers);
       return sb.toString();
     }
 
     throw new RuntimeException("Invalid type: " + type);
   }
 
-  private static void appendClassName(GenericType type, StringBuilder sb, List<TypeAnnotationWriteHelper> typeAnnWriteHelpers) {
-    List<GenericType> enclosingTypes = type.getEnclosingClasses();
-    typeAnnWriteHelpers = ExprProcessor.writeTypeAnnotationBeforeType(type, sb, typeAnnWriteHelpers);
-    if (enclosingTypes.isEmpty()) {
-      List<String> nestedTypes = Arrays.asList(
-        DecompilerContext.getImportCollector().getNestedName(type.getValue().replace('/', '.')).split("\\.")
-      );
-      ExprProcessor.writeNestedClass(sb, type, nestedTypes, typeAnnWriteHelpers);
-      ExprProcessor.popNestedTypeAnnotation(typeAnnWriteHelpers);
-    }
-    else {
-      for (GenericType tp : enclosingTypes) {
-        List<String> nestedTypes = Arrays.asList(
-          DecompilerContext.getImportCollector().getNestedName(tp.getValue().replace('/', '.')).split("\\.")
-        );
-        typeAnnWriteHelpers = ExprProcessor.writeNestedClass(sb, type, nestedTypes, typeAnnWriteHelpers);
-        typeAnnWriteHelpers = appendTypeArguments(tp, sb, typeAnnWriteHelpers);
-        ExprProcessor.popNestedTypeAnnotation(typeAnnWriteHelpers);
-        sb.append('.');
-      }
-      typeAnnWriteHelpers = ExprProcessor.writeNestedTypeAnnotations(sb, typeAnnWriteHelpers);
-      ExprProcessor.popNestedTypeAnnotation(typeAnnWriteHelpers);
-      sb.append(type.getValue());
-    }
-    appendTypeArguments(type, sb, typeAnnWriteHelpers);
-  }
-
-  private static List<TypeAnnotationWriteHelper> appendTypeArguments(
-    GenericType type,
-    StringBuilder sb,
-    List<TypeAnnotationWriteHelper> typeAnnWriteHelpers
-  ) {
-    if (!type.getArguments().isEmpty()) {
-      sb.append('<');
-
-      for (int i = 0; i < type.getArguments().size(); i++) {
-        if (i > 0) {
-          sb.append(", ");
-        }
-
-        GenericType genPar = type.getArguments().get(i);
-        int wildcard = type.getWildcards().get(i);
-
-        // only take type paths that are in the generic
-        List<TypeAnnotationWriteHelper> locTypeAnnWriteHelpers = getGenericTypeAnnotations(i, typeAnnWriteHelpers);
-        typeAnnWriteHelpers.removeAll(locTypeAnnWriteHelpers);
-        locTypeAnnWriteHelpers = writeTypeAnnotationBeforeWildCard(sb, genPar, wildcard, locTypeAnnWriteHelpers);
-        switch (wildcard) {
-          case GenericType.WILDCARD_UNBOUND -> sb.append('?');
-          case GenericType.WILDCARD_EXTENDS -> sb.append("? extends ");
-          case GenericType.WILDCARD_SUPER -> sb.append("? super ");
-        }
-        locTypeAnnWriteHelpers = writeTypeAnnotationAfterWildCard(sb, genPar, locTypeAnnWriteHelpers);
-        if (genPar != null) {
-          sb.append(getGenericCastTypeName(genPar, locTypeAnnWriteHelpers));
-        }
-      }
-
-      sb.append(">");
-    }
-    return typeAnnWriteHelpers;
-  }
-
-  private static List<TypeAnnotationWriteHelper> getGenericTypeAnnotations(
+  public static List<TypeAnnotationWriteHelper> getGenericTypeAnnotations(
     int argIndex,
     List<TypeAnnotationWriteHelper> typeAnnWriteHelpers
   ) {
@@ -266,9 +211,9 @@ public final class GenericMain {
     }).collect(Collectors.toList());
   }
 
-  private static List<TypeAnnotationWriteHelper> writeTypeAnnotationBeforeWildCard(
+  public static List<TypeAnnotationWriteHelper> writeTypeAnnotationBeforeWildCard(
     StringBuilder sb,
-    GenericType type,
+    VarType type,
     int wildcard,
     List<TypeAnnotationWriteHelper> typeAnnWriteHelpers
   ) {
@@ -278,7 +223,7 @@ public final class GenericMain {
         typeAnnWriteHelper.writeTo(sb);
         return false;
       }
-      if (type.getArrayDim() == typeAnnWriteHelper.getPaths().size() && type.getArrayDim() == typeAnnWriteHelper.arrayPathCount()) {
+      if (type != null && type.getArrayDim() == typeAnnWriteHelper.getPaths().size() && type.getArrayDim() == typeAnnWriteHelper.arrayPathCount()) {
         typeAnnWriteHelper.writeTo(sb);
         return false;
       }
@@ -286,9 +231,9 @@ public final class GenericMain {
     }).collect(Collectors.toList());
   }
 
-  private static List<TypeAnnotationWriteHelper> writeTypeAnnotationAfterWildCard(
+  public static List<TypeAnnotationWriteHelper> writeTypeAnnotationAfterWildCard(
     StringBuilder sb,
-    GenericType type,
+    VarType type,
     List<TypeAnnotationWriteHelper> typeAnnWriteHelpers
   ) {
     typeAnnWriteHelpers.forEach(typeAnnWriteHelper -> { // remove all wild card path entries
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
index eb8049193e952f7476a99188838b6c8907f49f8d..a93d250e2400a9680d7561d73cc1a69f7c0f8d79 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
@@ -4,18 +4,20 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.Collections;
 import java.util.List;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericMethodDescriptor {
   public final List<String> typeParameters;
-  public final List<List<GenericType>> typeParameterBounds;
-  public final List<GenericType> parameterTypes;
-  public final GenericType returnType;
-  public final List<GenericType> exceptionTypes;
+  public final List<List<VarType>> typeParameterBounds;
+  public final List<VarType> parameterTypes;
+  public final VarType returnType;
+  public final List<VarType> exceptionTypes;
 
   public GenericMethodDescriptor(List<String> typeParameters,
-                                 List<List<GenericType>> typeParameterBounds,
-                                 List<GenericType> parameterTypes,
-                                 GenericType returnType,
-                                 List<GenericType> exceptionTypes) {
+                                 List<List<VarType>> typeParameterBounds,
+                                 List<VarType> parameterTypes,
+                                 VarType returnType,
+                                 List<VarType> exceptionTypes) {
     this.typeParameters = substitute(typeParameters);
     this.typeParameterBounds = substitute(typeParameterBounds);
     this.parameterTypes = substitute(parameterTypes);
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index a042dd3a747f224a63a0987ff465f6259d783de4..e430a99b30757bb0ba5b8dda66e0790383ab8d75 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -2,44 +2,49 @@
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypeAnnotationWriteHelper;
 import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
 
-public class GenericType implements Type {
+public class GenericType extends VarType implements Type {
 
   public static final int WILDCARD_EXTENDS = 1;
   public static final int WILDCARD_SUPER = 2;
   public static final int WILDCARD_UNBOUND = 3;
   public static final int WILDCARD_NO = 4;
 
-  private final int type;
-  private final int arrayDim;
-  private final String value;
+  private static final Pattern DOT_SPLIT = Pattern.compile("\\.");
 
-  private final List<GenericType> enclosingClasses = new ArrayList<>();
-  private final List<GenericType> arguments = new ArrayList<>();
-  private final List<Integer> wildcards = new ArrayList<>();
+  private final VarType parent;
+  private final List<VarType> arguments;
+  private final int wildcard;
 
-  public GenericType(int type, int arrayDim, String value) {
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
+  public GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
+    super(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
+    this.parent = parent;
+    this.arguments = arguments == null ? Collections.<VarType>emptyList() : arguments;
+    this.wildcard = wildcard;
   }
 
-  private GenericType(GenericType other, int arrayDim) {
-    this(other.getType(), arrayDim, other.getValue());
-    enclosingClasses.addAll(other.enclosingClasses);
-    arguments.addAll(other.arguments);
-    wildcards.addAll(other.wildcards);
+  public static VarType parse(String signature) {
+    return parse(signature, WILDCARD_NO);
   }
 
-  public GenericType(String signature) {
+  public static VarType parse(String signature, int wildcard) {
     int type = 0;
     int arrayDim = 0;
     String value = null;
+    List<VarType> params = null;
+    VarType parent = null;
 
     int index = 0;
     loop:
@@ -57,32 +62,54 @@ public class GenericType implements Type {
         case 'L':
           type = CodeConstants.TYPE_OBJECT;
           signature = signature.substring(index + 1, signature.length() - 1);
+          String cl = getNextClassSignature(signature);
 
-          while (true) {
-            String cl = getNextClassSignature(signature);
-
-            String name = cl;
-            String args = null;
-
-            int argStart = cl.indexOf("<");
+          if (cl.length() == signature.length()) {
+            int argStart = cl.indexOf('<');
             if (argStart >= 0) {
-              name = cl.substring(0, argStart);
-              args = cl.substring(argStart + 1, cl.length() - 1);
-            }
-
-            if (cl.length() < signature.length()) {
-              signature = signature.substring(cl.length() + 1); // skip '.'
-              GenericType type11 = new GenericType(CodeConstants.TYPE_OBJECT, 0, name);
-              parseArgumentsList(args, type11);
-              enclosingClasses.add(type11);
+              value = cl.substring(0, argStart);
+              params = parseArgumentsList(cl.substring(argStart + 1, cl.length() - 1));
             }
             else {
-              value = name;
-              parseArgumentsList(args, this);
-              break;
+              value = cl;
+            }
+          }
+          else {
+            StringBuilder name_buff = new StringBuilder();
+            while (signature.length() > 0) {
+              String name = cl;
+              String args = null;
+
+              int argStart = cl.indexOf('<');
+              if (argStart >= 0) {
+                name = cl.substring(0, argStart);
+                args = cl.substring(argStart + 1, cl.length() - 1);
+              }
+
+              if (name_buff.length() > 0) {
+                name_buff.append('$');
+              }
+              name_buff.append(name);
+
+              value = name_buff.toString();
+              params = args == null ? null : parseArgumentsList(args);
+
+              if (cl.length() == signature.length()) {
+                break;
+              }
+              else {
+                if (parent == null && params == null) {
+                  parent = GenericType.parse("L" + value + ";");
+                }
+                else {
+                  parent = new GenericType(CodeConstants.TYPE_OBJECT, 0, value, parent, params, wildcard);
+                }
+
+                signature = signature.substring(cl.length() + 1);
+              }
+              cl = getNextClassSignature(signature);
             }
           }
-
           break loop;
 
         default:
@@ -93,24 +120,20 @@ public class GenericType implements Type {
       index++;
     }
 
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
-  }
-
-  @Override
-  public int getType() {
-    return type;
-  }
-
-  @Override
-  public int getArrayDim() {
-    return arrayDim;
-  }
-
-  @Override
-  public String getValue() {
-    return value;
+    if (type == CodeConstants.TYPE_GENVAR) {
+      return new GenericType(type, arrayDim, value, null, null, wildcard);
+    }
+    else if (type == CodeConstants.TYPE_OBJECT) {
+      if (parent == null && params == null && wildcard == WILDCARD_NO) {
+        return new VarType(type, arrayDim, value);
+      }
+      else {
+        return new GenericType(type, arrayDim, value, parent, params, wildcard);
+      }
+    }
+    else {
+      return new VarType(type, arrayDim, value);
+    }
   }
 
   private static String getNextClassSignature(String value) {
@@ -135,11 +158,13 @@ public class GenericType implements Type {
     return value.substring(0, index);
   }
 
-  private static void parseArgumentsList(String value, GenericType type) {
+  private static List<VarType> parseArgumentsList(String value) {
     if (value == null) {
-      return;
+      return null;
     }
 
+    List<VarType> args = new ArrayList<>();
+
     while (value.length() > 0) {
       String typeStr = getNextType(value);
       int len = typeStr.length();
@@ -150,16 +175,16 @@ public class GenericType implements Type {
         default -> WILDCARD_NO;
       };
 
-      type.getWildcards().add(wildcard);
-
       if (wildcard != WILDCARD_NO) {
         typeStr = typeStr.substring(1);
       }
 
-      type.getArguments().add(typeStr.length() == 0 ? null : new GenericType(typeStr));
+      args.add(typeStr.length() == 0 ? null : GenericType.parse(typeStr, wildcard));
 
       value = value.substring(len);
     }
+
+    return args;
   }
 
   public static String getNextType(String value) {
@@ -208,20 +233,134 @@ public class GenericType implements Type {
     return value.substring(0, index + 1);
   }
 
+  @Override
   public GenericType decreaseArrayDim() {
     assert getArrayDim() > 0 : this;
-    return new GenericType(this, getArrayDim() - 1);
+    return new GenericType(getType(), getArrayDim() - 1, getValue(), parent, arguments, wildcard);
+  }
+
+  @Override
+  public VarType resizeArrayDim(int newArrayDim) {
+    return new GenericType(getType(), newArrayDim, getValue(), parent, arguments, wildcard);
+  }
+
+  public VarType getParent() {
+    return parent;
   }
 
-  public List<GenericType> getArguments() {
+  public List<VarType> getArguments() {
     return arguments;
   }
 
-  public List<GenericType> getEnclosingClasses() {
-    return enclosingClasses;
+  @Override
+  public boolean isGeneric() {
+    return true;
+  }
+
+  public int getWildcard() {
+    return wildcard;
+  }
+
+  public List<TypeAnnotationWriteHelper> appendCastName(final StringBuilder clsName, List<TypeAnnotationWriteHelper> typeAnnWriteHelpers) {
+    if (parent != null && parent.isGeneric()) {
+      typeAnnWriteHelpers = ((GenericType) parent).appendCastName(clsName, typeAnnWriteHelpers);
+      typeAnnWriteHelpers = ExprProcessor.writeNestedTypeAnnotations(clsName, typeAnnWriteHelpers);
+      clsName.append(".").append(getValue().substring(parent.getValue().length() + 1));
+    }
+    else {
+      List<String> nestedTypes = Arrays.asList(DOT_SPLIT.split(DecompilerContext.getImportCollector().getNestedName(getValue().replace('/', '.'))));
+      ExprProcessor.writeNestedClass(clsName, this, nestedTypes, typeAnnWriteHelpers);
+      ExprProcessor.popNestedTypeAnnotation(typeAnnWriteHelpers);
+    }
+    typeAnnWriteHelpers = appendTypeArguments(clsName, typeAnnWriteHelpers);
+    return typeAnnWriteHelpers;
+  }
+
+  private List<TypeAnnotationWriteHelper> appendTypeArguments(final StringBuilder buffer, List<TypeAnnotationWriteHelper> typeAnnWriteHelpers) {
+    if (!arguments.isEmpty()) {
+      buffer.append('<');
+
+      for (int i = 0; i < arguments.size(); i++) {
+        if (i > 0) {
+          buffer.append(", ");
+        }
+
+        VarType par = arguments.get(i);
+        // only take type paths that are in the generic
+        List<TypeAnnotationWriteHelper> locTypeAnnWriteHelpers = GenericMain.getGenericTypeAnnotations(i, typeAnnWriteHelpers);
+        typeAnnWriteHelpers.removeAll(locTypeAnnWriteHelpers);
+        locTypeAnnWriteHelpers = GenericMain.writeTypeAnnotationBeforeWildCard(buffer, par, wildcard, locTypeAnnWriteHelpers);
+        if (par == null) { // Wildcard unbound
+          buffer.append('?');
+        }
+        else if (par.isGeneric()) {
+          GenericType gen = (GenericType)par;
+          switch (gen.getWildcard()) {
+            case GenericType.WILDCARD_EXTENDS:
+              buffer.append("? extends ");
+              break;
+            case GenericType.WILDCARD_SUPER:
+              buffer.append("? super ");
+              break;
+          }
+          locTypeAnnWriteHelpers = GenericMain.writeTypeAnnotationAfterWildCard(buffer, par, locTypeAnnWriteHelpers);
+          buffer.append(GenericMain.getGenericCastTypeName(gen, locTypeAnnWriteHelpers));
+        }
+        else {
+          buffer.append(ExprProcessor.getCastTypeName(par, locTypeAnnWriteHelpers));
+        }
+      }
+
+      buffer.append(">");
+    }
+    return typeAnnWriteHelpers;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder();
+    switch(getWildcard()) {
+      case GenericType.WILDCARD_EXTENDS:
+        buf.append("? extends ");
+        break;
+      case GenericType.WILDCARD_SUPER:
+        buf.append("? super ");
+      break;
+    }
+    buf.append(super.toString());
+    appendTypeArguments(buf, Collections.emptyList());
+    return buf.toString();
   }
 
-  public List<Integer> getWildcards() {
-    return wildcards;
+
+  @Override
+  public VarType remap(Map<VarType, VarType> map) {
+    VarType main = super.remap(map);
+    if (main != this) {
+      return main;
+    }
+    boolean changed = false;
+    VarType parent = getParent();
+    if (map.containsKey(parent)) {
+      parent = map.get(parent);
+      changed = true;
+    }
+    List<VarType> newArgs = new ArrayList<>();
+    for (VarType arg : getArguments()) {
+      VarType newArg = null;
+      if (arg != null) {
+        newArg = arg.remap(map);
+      }
+      if (newArg != arg) {
+        newArgs.add(newArg);
+        changed = true;
+      } else {
+        newArgs.add(arg);
+      }
+    }
+    if (changed) {
+      return new GenericType(main.getType(), main.getArrayDim(), main.getValue(), parent, newArgs, getWildcard());
+    }
+    return this;
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java b/src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
index 8b6105dbbfea358241702acbc691976d51f0d726..4261dce0b37505d22c6e9ee7c3e0bdb7e5331cfb 100644
--- a/src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
+++ b/src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
@@ -119,7 +119,7 @@ public class LazyLoader {
 
   public DataInputFullStream getClassStream(String qualifiedClassName) throws IOException {
     Link link = mapClassLinks.get(qualifiedClassName);
-    return link == null ? null : getClassStream(link.externalPath, link.internalPath);
+    return link == null ? null : link.data != null ? new DataInputFullStream(link.data) : getClassStream(link.externalPath, link.internalPath);
   }
 
   public static void skipAttributes(DataInputFullStream in) throws IOException {
@@ -133,10 +133,16 @@ public class LazyLoader {
   public static class Link {
     public final String externalPath;
     public final String internalPath;
+    public final byte[] data;
 
     public Link(String externalPath, String internalPath) {
+        this(externalPath, internalPath, null);
+    }
+
+    public Link(String externalPath, String internalPath, byte[] data) {
       this.externalPath = externalPath;
       this.internalPath = internalPath;
+      this.data = data;
     }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java b/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc91edd842805b55a757c5794b4fb7dcc1da3f57
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
@@ -0,0 +1,77 @@
+// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+package org.jetbrains.java.decompiler.util;
+
+import java.lang.module.*;
+import java.nio.ByteBuffer;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
+import org.jetbrains.java.decompiler.struct.StructContext;
+
+public class ClasspathScanner {
+
+    public static void addAllClasspath(StructContext ctx) {
+      Set<String> found = new HashSet<>();
+      String[] props = { System.getProperty("java.class.path"), System.getProperty("sun.boot.class.path") };
+      for (String prop : props) {
+        if (prop == null)
+          continue;
+
+        for (final String path : prop.split(File.pathSeparator)) {
+          File file = new File(path);
+          if (found.contains(file.getAbsolutePath()))
+            continue;
+
+          if (file.exists() && (file.getName().endsWith(".class") || file.getName().endsWith(".jar"))) {
+            DecompilerContext.getLogger().writeMessage("Adding File to context from classpath: " + file, Severity.INFO);
+            ctx.addSpace(file, false);
+            found.add(file.getAbsolutePath());
+          }
+        }
+      }
+
+      addAllModulePath(ctx);
+    }
+
+    private static void addAllModulePath(StructContext ctx) {
+      for (ModuleReference module : ModuleFinder.ofSystem().findAll()) {
+        String name = module.descriptor().name();
+        try {
+          ModuleReader reader = module.open();
+          DecompilerContext.getLogger().writeMessage("Reading Module: " + name, Severity.INFO);
+          reader.list().forEach(cls -> {
+            if (!cls.endsWith(".class") || cls.contains("module-info.class"))
+              return;
+
+            DecompilerContext.getLogger().writeMessage("  " + cls, Severity.INFO);
+            try {
+              Optional<ByteBuffer> bb = reader.read(cls);
+              if (!bb.isPresent()) {
+                DecompilerContext.getLogger().writeMessage("    Error Reading Class: " + cls, Severity.ERROR);
+                return;
+              }
+
+              byte[] data;
+              if (bb.get().hasArray()) {
+                data = bb.get().array();
+              } else {
+                data = new byte[bb.get().remaining()];
+                bb.get().get(data);
+              }
+              ctx.addData(name, cls, data, false);
+            } catch (IOException e) {
+              DecompilerContext.getLogger().writeMessage("    Error Reading Class: " + cls, e);
+            }
+          });
+          reader.close();
+        } catch (IOException e) {
+          DecompilerContext.getLogger().writeMessage("Error loading module " + name, e);
+        }
+      }
+    }
+}
diff --git a/test/org/jetbrains/java/decompiler/SingleClassesTest.java b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
index dd0e178cc1df1c6edc9e77e3149c2b0e9bffe884..645d99f07322c311a20b5fd76a5235de6cdae74d 100644
--- a/test/org/jetbrains/java/decompiler/SingleClassesTest.java
+++ b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
@@ -23,9 +23,12 @@ public class SingleClassesTest extends SingleClassesTestBase {
     return Map.of(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING, "1",
                          IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1",
                          IFernflowerPreferences.IGNORE_INVALID_BYTECODE, "1",
-                         IFernflowerPreferences.VERIFY_ANONYMOUS_CLASSES, "1");
+                         IFernflowerPreferences.VERIFY_ANONYMOUS_CLASSES, "1",
+                         IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH, "1"
+);
   }
 
+  @Test public void testGenerics() { doTest("pkg/TestGenerics"); }
   @Test public void testEnhancedForLoops() { doTest("pkg/TestEnhancedForLoops"); }
   @Test public void testPrimitiveNarrowing() { doTest("pkg/TestPrimitiveNarrowing"); }
   @Test public void testClassFields() { doTest("pkg/TestClassFields"); }
diff --git a/testData/classes/pkg/TestGenerics$Maps.class b/testData/classes/pkg/TestGenerics$Maps.class
new file mode 100644
index 0000000000000000000000000000000000000000..a4c3dcc2e336bb973e3eac43506e0b949eca8ea9
GIT binary patch
literal 544
zcmZutO;5r=5Pb`U(u(q-h#wbCJb(v#@ni`HF`}XBfriB6Qa7+z3+adcEj^KF;t%jg
z8E1<JqHMDBX5PG+ot>}m_fG()*f)_wO~<y0jKUoqyA1i33}oD9$Tpe-2CXxF5DX<p
z2I4k(8j8^6L!X$cGxfMX;GtCUFR8_28Bx&<pAi(VgFu8GpGT3Pu<pzrN0uw1xGRX4
zUUZ~%HiH?6mn$BPDP*WMn$Cnjb1R9ZZ~f9FGWv29@Hh$S@ouYkwh;L|7+H72iSS~3
zu!3u^>eh05wmY!f>goP82|aNs)t@TM!=0!hipWE!#J_=b?9r$zKg3W@<x8Ux^;e2R
zXtaNIGN83XCtIM%B4mWQ<2l${nl{MhQ}P@p`Nf3*YuKR3KnZ1PqKXd))hT=+b3aG+
em3&$q*+u;YD&%KSrMsDWTUaMFNu{AqosA#bw0W)o

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestGenerics.class b/testData/classes/pkg/TestGenerics.class
new file mode 100644
index 0000000000000000000000000000000000000000..bc719a03fc9f56c96a38ca60f2d503491de044a5
GIT binary patch
literal 3233
zcmb7HSyvQC7`-(!(8ElFfCAzY_k>kY6OA&WKwO9eE`u1CEX~kDOVcx%=~2nP?}=HS
z@{niWa!&9BLp;gxIsYU15jjcBt?Hhh9*8-|2fDkezPjK2?suzu`0byce+BR)zD^*5
zNeve?^wePso=cz(7d2c;pca!!Y`|p=SL*OQUeNGj0!d89@shk7@-iha*#xFx%H3Br
z%p@@jD~W5EOTxyyyf_+iayhTzWeGVa2L%m9IdC<U1Y%=Gz9^uNI*wTwv5jKU<gn(d
zW!lpMYtq+@>qcM6wd_6y4hYm`tQp5}O9fM4fAwn08`_35)0c4zmNPRDni<aJY}0TC
z1_=_k?V<`0XbfSbt)k1-Fsz*NaTSTsIGkrt!PZPIxRU+$6_{aS!wgZuwZ>4PU@Qo%
zy&PhBdg_{)l_X-9Cx&>dO<9iR4hlp&Iwv_hlAC7XYtoiuj+f@A%)*2*Wpk!Eoy!{b
zq*1Ws*q@BKvli(zr}J|&eG_KUJz-L0D_bORYxRbOe0kG`RnaLjnHW~2n`S(OA=_p?
z*UC9m(4QN1u9^kY$&yWsGPtZPq{B(0IO}!r(CXQ+K&v}9>bT~NSx^L$elpny_EF~X
z9>tVE+bZfirMp;dODLymp<hpwcY!kKh#^61OZlvNcx0ksi#7N}kLL=<jO?s{P@PbA
z4m(GnKI0nMITBS}({P>5sos3Sa%VkmWz<Y5Zx+tyN!C#=kWH>Yd(L2CF<Z&By7~!<
z$ulX?o|^E>RHXc!gUW32RMz(0cP=#)4)a|)eCQ#9hn16Z4-AIb1r|?aa-~AnJZ?z?
zH--JVTh^juH~MI=N?qPg9o^{BaRWE$Ftw;oraDbBnT`d#!j`Wzz4C&FS9QFG*J+jt
zu4lR7l4Vbu1%b%$AsuhvO?i1s$J=;E!@D}(!}~h6V+Xlbvii2x@PUpG@sWm)b$o(P
z*+m_n;d32d;8s-)UM?Mv;|YO=3XsRVQ_hAe_WGgYOMJ!ol@+n;6@XFKEEsN%{1c9O
z!{<dAIyyt%ubjf@j7hJzbd37Ts{KK0LKHF!Mc16?3n*8T8$2*8*LQ|5SeMn9#yp)?
zYvl8$!#8$sN2t~QSq`VD(wZBq;{E*p7aw<X9)!TUa%t7)$@4@tLjf%>`PzJ6wfq-D
zzFX@nTJkWmq&agTBSmT|=TSc66lsToRZQFp<ZrDCFSmtzv{|D#Zr&s!U*?y1Ivq8r
zE+c3`)R?B6Rb<QZT*5YfM<e`>#}Jp6guqUYBG|<-ofV8bIHsq9aTlX_dV+B;Kl(zR
zGhX|-c9s}|_olA95M7OlUl6&E=#Pl~z{x1~@G5^d0BuaY5qtThdmFHiKPrHys%G|c
zByb>rAM@esyBgO$6#6kjZV5rxuY#5{61omg2hhiuNHVYa2{oryvfWO$I|9fU0}tX5
zgUf8anE}N%6+nK+ildzCy@%S1ccG=bqsxd#a36JJi%8r<lCyeq{Sq2_mat|CjZ0{%
zq;6(Xup4pezZM--y;D)x>Vf)I#o4pNszYn}n`jV6D3PR9iISCiQAbJKiyBfw4hK}P
za7DHyzKG`g{O(p*c<t(ehF+Du)r<49Yuq<NDTK;dS(7=vwP&~{a4g7li~FT0J<PO>
zbpp$15lDA0qgCKrwDF-$P@?rxBFfTq`@tWQO-z}`)1;sN-9tt8(u?~7R@<2II8G>j
zJwCs3gP4yqlGRE6B@y`x4H`!O#3qt^HX!$nPp*Fv?d4u=SjNUjCAgnWIlz?CUIzn$
zyFvu}R}qvmRRo&@f~N=*QRnM>-lZ%0%a&TiCdF^8#}{xtAC!Qb$Gdx%@mK^GZa?_F
zqF^g(xIaZl9OjuHB*`O0KdMMd&+Oz%8e^(QWs-4fJ+3?^_4K-2rt7Vpri@bA21Ncw
zlZG>j`)2>Ga+a9q0+9z)hk%VdX?M`<S8@mK!P6#5SEz<JC?f0mKSetlX>dtUzNj*o
TQ1|n+f_$g&hdmGdR@D6qBizOe

literal 0
HcmV?d00001

diff --git a/testData/results/TestAmbiguousCall.dec b/testData/results/TestAmbiguousCall.dec
index dec7ba0f20eecdc5a3c7d0774a0fdd4f3b68e6f6..acf1120655937c0e227ab11a1f472c444b2857b9 100644
--- a/testData/results/TestAmbiguousCall.dec
+++ b/testData/results/TestAmbiguousCall.dec
@@ -13,7 +13,7 @@ class TestAmbiguousCall {
       this.m1(var1, "IAE");// 10
       IllegalArgumentException var2 = new IllegalArgumentException();// 12
       this.m1((RuntimeException)var2, "RE");// 13
-      this.m1((IllegalArgumentException)var2, "IAE");// 14
+      this.m1(var2, "IAE");// 14
    }// 15
 }
 
diff --git a/testData/results/TestClassSwitch.dec b/testData/results/TestClassSwitch.dec
index 6a2b156f9ad0e29aad668542ee090d63130d2182..f92c9169b960ab9f1f5ff7440ac4caef9aa62744 100644
--- a/testData/results/TestClassSwitch.dec
+++ b/testData/results/TestClassSwitch.dec
@@ -2,13 +2,13 @@ package pkg;
 
 public class TestClassSwitch {
    public void testCaseOrder(int var1) {
-      switch (var1) {// 22
+      switch(var1) {// 22
          case 5:
-            System.out.println(5);// 27
+            System.out.println((int)5);// 27
          default:
             return;// 29
          case 13:
-            System.out.println(13);// 24
+            System.out.println((int)13);// 24
       }
    }// 25
 }
diff --git a/testData/results/TestExtendsList.dec b/testData/results/TestExtendsList.dec
index 6f116dbad41c3ce71fd5c79ee639ddbff3f1b39f..3f3dbea1836b9acaa8626c029bfe40dc0ee3c751 100644
--- a/testData/results/TestExtendsList.dec
+++ b/testData/results/TestExtendsList.dec
@@ -2,11 +2,11 @@ package pkg;
 
 public class TestExtendsList {
    static <T extends Comparable<? super T>> T m1(T var0) {
-      return null;// 20
+      return (T)null;// 20
    }
 
    static <T extends Object & Comparable<? super T>> T m2(T var0) {
-      return null;// 24
+      return (T)null;// 24
    }
 }
 
diff --git a/testData/results/TestGenerics.dec b/testData/results/TestGenerics.dec
new file mode 100644
index 0000000000000000000000000000000000000000..da090b301d5537352bad9fb01068cc37fa156cc0
--- /dev/null
+++ b/testData/results/TestGenerics.dec
@@ -0,0 +1,218 @@
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestGenerics<A, B extends TestGenerics.Maps & List> {
+   static Map<String, Boolean> field = TestGenerics.Maps.<String, Boolean>newHashMap();
+   static List<List<String>> llstring = new ArrayList<List<String>>();
+   static List<Byte> bytes = new ArrayList<Byte>();
+   A[] aArray = (A[])(new Object[10]);
+
+   public void genericAllocation() {
+      this.aArray = (A[])(new Object[20]);// 30
+   }// 31
+
+   public static void genericInference() {
+      HashMap<String, Integer> test = TestGenerics.Maps.<String, Integer>newHashMap();// 34
+   }// 35
+
+   public void genericList() {
+      List<B> testList = new ArrayList<B>();// 38
+      B b = testList.get(0);// 39
+      System.out.println("B:" + b);// 40
+   }// 41
+
+   public void genericCast() {
+      HashMap<String, Boolean> upcast = (HashMap)field;// 44
+   }// 45
+
+   public void genericForEach() {
+      for(String s : field.keySet()) {// 48
+         System.out.println(s);// 49
+      }
+// 51
+   }
+
+   public void genericForEachWithCast() {// 54
+      for(String s : llstring.get(0)) {// 55
+         System.out.println(s);
+      }// 57
+
+   }
+// 60
+   public <T extends Number> void genericSuperUp() {
+      List<T> list = new ArrayList<T>();// 61
+// 62
+      for(Number number : bytes) {
+         list.add(number);// 64
+      }
+
+   }
+// 68
+   public static class Maps {
+      public static <K, V> HashMap<K, V> newHashMap() {
+         return new HashMap<K, V>();
+      }
+   }
+}
+
+class 'pkg/TestGenerics' {
+   method 'genericAllocation ()V' {
+      0      14
+      1      14
+      2      14
+      6      14
+      7      14
+      8      14
+      9      14
+      a      14
+      b      14
+      c      15
+   }
+
+   method 'genericInference ()V' {
+      0      18
+      1      18
+      2      18
+      3      18
+      4      19
+   }
+
+   method 'genericList ()V' {
+      7      22
+      8      23
+      9      23
+      a      23
+      b      23
+      c      23
+      d      23
+      e      23
+      f      23
+      10      23
+      11      23
+      12      23
+      13      24
+      14      24
+      15      24
+      1d      24
+      1e      24
+      22      24
+      26      24
+      27      24
+      28      24
+      29      24
+      2a      24
+      2b      24
+      2c      25
+   }
+
+   method 'genericCast ()V' {
+      0      28
+      1      28
+      2      28
+      3      28
+      4      28
+      5      28
+      6      28
+      7      29
+   }
+
+   method 'genericForEach ()V' {
+      0      32
+      1      32
+      2      32
+      3      32
+      4      32
+      5      32
+      6      32
+      7      32
+      d      32
+      20      32
+      21      33
+      22      33
+      23      33
+      24      33
+      25      33
+      26      33
+      27      33
+      2b      35
+   }
+
+   method 'genericForEachWithCast ()V' {
+      0      38
+      1      38
+      2      38
+      3      38
+      4      38
+      5      38
+      6      38
+      7      38
+      8      38
+      9      38
+      a      38
+      b      38
+      11      38
+      24      38
+      25      39
+      26      39
+      27      39
+      28      39
+      29      39
+      2a      39
+      2b      39
+      2f      41
+   }
+
+   method 'genericSuperUp ()V' {
+      7      44
+      8      46
+      9      46
+      a      46
+      10      46
+      23      46
+      24      47
+      25      47
+      26      47
+      27      47
+      28      47
+      29      47
+      2a      47
+      2f      49
+   }
+}
+
+class 'pkg/TestGenerics$Maps' {
+   method 'newHashMap ()Ljava/util/HashMap;' {
+      7      53
+   }
+}
+
+Lines mapping:
+30 <-> 15
+31 <-> 16
+34 <-> 19
+35 <-> 20
+38 <-> 23
+39 <-> 24
+40 <-> 25
+41 <-> 26
+44 <-> 29
+45 <-> 30
+48 <-> 33
+49 <-> 34
+51 <-> 36
+54 <-> 39
+55 <-> 40
+57 <-> 42
+60 <-> 45
+61 <-> 47
+62 <-> 48
+64 <-> 50
+68 <-> 54
+Not mapped:
+50
+56
+63
diff --git a/testData/results/TestKotlinConstructorKt.dec b/testData/results/TestKotlinConstructorKt.dec
index e57e91a4d0f967a12d306f22b295608a08a872f1..624026a45ae5dd4b613fb8079a0ea0743281c9cc 100644
--- a/testData/results/TestKotlinConstructorKt.dec
+++ b/testData/results/TestKotlinConstructorKt.dec
@@ -14,8 +14,8 @@ import kotlin.collections.CollectionsKt;
 )
 public final class TestKotlinConstructorKt {
    private static final List<Mapping> foo(Collection<String> list) {
-      Iterable $receiver$iv = (Iterable)list;// 2
-      Collection destination$iv$iv = (Collection)(new ArrayList(CollectionsKt.collectionSizeOrDefault($receiver$iv, 10)));
+      Iterable $receiver$iv = list;// 2
+      Collection destination$iv$iv = new ArrayList(CollectionsKt.collectionSizeOrDefault($receiver$iv, 10));
 
       for(Object item$iv$iv : $receiver$iv) {// 10 11
          String it = (String)item$iv$iv;
@@ -24,12 +24,12 @@ public final class TestKotlinConstructorKt {
             throw new TypeCastException("null cannot be cast to non-null type kotlin.String");
          }
 
-         var10000.<init>((String)it);
+         var10000.<init>(it);
          Mapping var11 = var10000;
          destination$iv$iv.add(var11);// 12
       }
 // 4 13
-      return CollectionsKt.toList((Iterable)((List)destination$iv$iv));
+      return CollectionsKt.toList((List)destination$iv$iv);
    }
 }
 
diff --git a/testData/results/TestLocalsSignature.dec b/testData/results/TestLocalsSignature.dec
index 3da716bb86c538148347d67c29354a66dc416c17..3bd9c84810baa9f0cec8a62492ddccf80747d2d2 100644
--- a/testData/results/TestLocalsSignature.dec
+++ b/testData/results/TestLocalsSignature.dec
@@ -5,7 +5,7 @@ import java.util.List;
 
 public class TestLocalsSignature {
    public static void main(String[] args) {
-      List<String> s = new ArrayList();// 24
+      List<String> s = new ArrayList<String>();// 24
       s.add("xxx");// 25
    }// 26
 }
diff --git a/testData/results/TestVarArgCalls.dec b/testData/results/TestVarArgCalls.dec
index db4cb49cc7816f05dd2e3d82a6b79a7405001e4d..89cfc1980d0ff576c6f7676da8cb8c876db2c6ae 100644
--- a/testData/results/TestVarArgCalls.dec
+++ b/testData/results/TestVarArgCalls.dec
@@ -13,15 +13,15 @@ public class TestVarArgCalls {
       String.format("Test: %d - %s", 123, "DEF");// 15
       Object[] data = new Object[]{"Hello"};// 17
       String.format("Test: %s", (Object)data);// 18
-      String.format("Test: %s", (Object[])data);// 19
+      String.format("Test: %s", data);// 19
    }// 20
 
    public void printAll(String fmt, String... params) {
-      System.out.println(String.format(fmt, (Object[])params));// 23
+      System.out.println(String.format(fmt, params));// 23
    }// 24
 
    public void printComplex(String fmt, String[]... params) {
-      System.out.println(String.format(fmt, (Object[])params));// 27
+      System.out.println(String.format(fmt, params));// 27
    }// 28
 }
 
diff --git a/testData/src/pkg/TestGenerics.java b/testData/src/pkg/TestGenerics.java
new file mode 100644
index 0000000000000000000000000000000000000000..c45ac50962a7ebbf590404070a9fbd6a6a22aa6d
--- /dev/null
+++ b/testData/src/pkg/TestGenerics.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestGenerics<A, B extends TestGenerics.Maps & List>  {
+  static Map<String, Boolean> field = Maps.newHashMap();
+  static List<List<String>> llstring = new ArrayList<>();
+  static List<Byte> bytes = new ArrayList<>();
+  A[] aArray = (A[])(new Object[10]);
+
+  public void genericAllocation() {
+    aArray = (A[])(new Object[20]);
+  }
+  
+  public static void genericInference() {
+    HashMap<String, Integer> test = Maps.newHashMap();
+  }
+
+  public void genericList() {
+    List<B> testList = new ArrayList<B>();
+    B b = testList.get(0);
+    System.out.println("B:" + b);
+  }
+
+  public void genericCast() {
+    HashMap<String, Boolean> upcast = (HashMap<String, Boolean>)field;
+  }
+
+  public void genericForEach() { 
+    for (String s : field.keySet()) {
+      System.out.println(s);
+    }
+  }
+
+  public void genericForEachWithCast() { 
+    for (String s : llstring.get(0)) {
+      System.out.println(s);
+    }
+  }
+
+  public <T extends Number> void genericSuperUp() {
+    List<T> list = new ArrayList<>();
+    for (Number number : bytes) {
+      list.add((T)number);
+    }
+   }
+
+  public static class Maps {
+    public static <K, V> HashMap<K, V> newHashMap() {
+      return new HashMap<K, V>();
+    }
+  }
+}
