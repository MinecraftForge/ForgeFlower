From 01e351e13f31deaa74035ceeda111ace834849a8 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Wed, 28 Oct 2015 23:45:40 -0700
Subject: [PATCH 109/122] Stabelize a few areas on Java 8. Notibly the exit
 mapper. Fixes the decompile differences between J6/7 and J8.

---
 .../decompiler/main/rels/MethodProcessorRunnable.java  |  6 ++++--
 .../java/decompiler/modules/decompiler/DomHelper.java  |  4 ++--
 .../decompose/DominatorTreeExceptionFilter.java        |  6 +++---
 .../decompose/FastExtendedPostdominanceHelper.java     |  6 +++---
 .../modules/decompiler/stats/GeneralStatement.java     |  3 ++-
 .../modules/decompiler/stats/SwitchStatement.java      | 10 +++++++++-
 6 files changed, 23 insertions(+), 12 deletions(-)

diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index 16d7788..9bcd3ba 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -253,8 +253,10 @@ public class MethodProcessorRunnable implements Runnable {
     for (Object obj : root.getSequentialObjects()) {
       if (obj instanceof Statement) {
         printStatement((Statement)obj, "  ",varProc);
+      } else if (obj == null) {
+          System.out.println("  null");
       } else {
-        System.out.println("  " + obj.getClass().getSimpleName());
+          System.out.println("  " + obj.getClass().getSimpleName());
       }
     }
     if (root instanceof RootStatement) {
@@ -292,7 +294,7 @@ public class MethodProcessorRunnable implements Runnable {
     int start = values.nextSetBit(0);
     int end = values.length()-1;
 
-    System.out.print(indent + "{" + statement.type + "}:" + statement.id + " (" + start + ", " + end + ") " + statement.getClass().getSimpleName());
+    System.out.print(indent + "{" + statement.getClass().getSimpleName() + "}:" + statement.id + " (" + start + ", " + end + ") " + statement.getClass().getSimpleName());
     if (statement.type == Statement.TYPE_DO) {
         System.out.print(" t:"+((DoStatement)statement).getLooptype());
     } else if (statement.type == Statement.TYPE_BASICBLOCK) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
index c45f5e0..e780bd6 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
@@ -483,11 +483,11 @@ public class DomHelper {
 
         boolean same = (post == head);
 
-        HashSet<Statement> setNodes = new HashSet<Statement>();
+        LinkedHashSet<Statement> setNodes = new LinkedHashSet<Statement>();
         HashSet<Statement> setPreds = new HashSet<Statement>();
 
         // collect statement nodes
-        HashSet<Statement> setHandlers = new HashSet<Statement>();
+        HashSet<Statement> setHandlers = new LinkedHashSet<Statement>();
         setHandlers.add(head);
         while (true) {
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java b/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java
index 89e6849..1c3a8e1 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java
@@ -27,10 +27,10 @@ public class DominatorTreeExceptionFilter {
   private final Statement statement;
 
   // idom, nodes
-  private final Map<Integer, Set<Integer>> mapTreeBranches = new HashMap<Integer, Set<Integer>>();
+  private final Map<Integer, Set<Integer>> mapTreeBranches = new LinkedHashMap<Integer, Set<Integer>>();
 
   // handler, range nodes
-  private final Map<Integer, Set<Integer>> mapExceptionRanges = new HashMap<Integer, Set<Integer>>();
+  private final Map<Integer, Set<Integer>> mapExceptionRanges = new LinkedHashMap<Integer, Set<Integer>>();
 
   // handler, head dom
   private Map<Integer, Integer> mapExceptionDoms = new HashMap<Integer, Integer>();
@@ -86,7 +86,7 @@ public class DominatorTreeExceptionFilter {
 
       Set<Integer> set = mapTreeBranches.get(idom);
       if (set == null) {
-        mapTreeBranches.put(idom, set = new HashSet<Integer>());
+        mapTreeBranches.put(idom, set = new LinkedHashSet<Integer>());
       }
       set.add(key);
     }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
index eee7b15..349f522 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
@@ -28,9 +28,9 @@ public class FastExtendedPostdominanceHelper {
 
   private List<Statement> lstReversePostOrderList;
 
-  private HashMap<Integer, FastFixedSet<Integer>> mapSupportPoints = new HashMap<Integer, FastFixedSet<Integer>>();
+  private HashMap<Integer, FastFixedSet<Integer>> mapSupportPoints = new LinkedHashMap<Integer, FastFixedSet<Integer>>();
 
-  private final HashMap<Integer, FastFixedSet<Integer>> mapExtPostdominators = new HashMap<Integer, FastFixedSet<Integer>>();
+  private final HashMap<Integer, FastFixedSet<Integer>> mapExtPostdominators = new LinkedHashMap<Integer, FastFixedSet<Integer>>();
 
   private Statement statement;
 
@@ -40,7 +40,7 @@ public class FastExtendedPostdominanceHelper {
 
     this.statement = statement;
 
-    HashSet<Integer> set = new HashSet<Integer>();
+    HashSet<Integer> set = new LinkedHashSet<Integer>();
     for (Statement st : statement.getStats()) {
       set.add(st.id);
     }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
index 499894a..f7e0080 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
@@ -20,6 +20,7 @@ import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 
 
 public class GeneralStatement extends Statement {
@@ -39,7 +40,7 @@ public class GeneralStatement extends Statement {
     first = head;
     stats.addWithKey(head, head.id);
 
-    HashSet<Statement> set = new HashSet<Statement>(statements);
+    LinkedHashSet<Statement> set = new LinkedHashSet<Statement>(statements);
     set.remove(head);
 
     for (Statement st : set) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
index 2a29309..af522d9 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
@@ -80,7 +80,15 @@ public class SwitchStatement extends Statement {
 
     default_edge = head.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL).get(0);
 
-    for (Statement st : lstNodes) {
+    //We need to use set above in case we have multiple edges to the same node. But HashSets iterator is not ordered, so sort
+    List<Statement> sorted = new ArrayList<Statement>(lstNodes);
+    Collections.sort(sorted, new Comparator<Statement>() {
+      @Override
+      public int compare(Statement o1, Statement o2) {
+        return o1.id - o2.id;
+      }
+    });
+    for (Statement st : sorted) {
       stats.addWithKey(st, st.id);
     }
   }
-- 
2.21.0.windows.1

