From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: cpw <cpw@weeksfamily.ca>
Date: Sun, 9 Aug 2015 11:58:54 -0400
Subject: [PATCH] Ignore variables without an LVT entry. They're likely dummy
 vars generated by FF for exceptions, little info is missing. Also, don't
 exception on empty blocks, they're just empty blocks!


diff --git a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
index 4e865569886a79b208df09e2449106bea16ba87b..5a35cc8f05f06ca0e9726ff830eccff46da99b6b 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
@@ -169,8 +169,8 @@ public class ClassWrapper {
           StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
 
         if (attr != null) {
-          varProc.setDebugVarNames(attr.getMapVarNames());
           varProc.setLVT(attr.getLVT());
+          varProc.setDebugVarNames(attr.getMapVarNames());
         }
       }
 
diff --git a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
index f0b17a55f189e6dd356a3188bb6e2ce01074393d..388e76a7a8270d81d03b661ddbfef5ed9fb53fe4 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
@@ -229,7 +229,10 @@ public class MethodProcessorRunnable implements Runnable {
 
   public static void printMethod(RootStatement root, String name, VarProcessor varProc) {
     System.out.println(name + " {");
-
+    if (root == null || root.getSequentialObjects() == null) {
+        System.out.println("}");
+        return;
+    }
     for (Object obj : root.getSequentialObjects()) {
       if (obj instanceof Statement) {
         printStatement((Statement)obj, "  ",varProc);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
index ccd1bd64ac0c5e721806fc2b9b423561976c7fe9..6b15a12069348463463c60b541b38a355fb27e91 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
@@ -93,9 +93,11 @@ private LocalVariableTable lvt;
         if (indexedPairs.containsKey(key.var)) {
           int veridx = indexedPairs.get(key.var).headSet(key).size();
           List<LVTVariable> list = mapDebugVarNames.get(key.var);
-          if (list.size()>veridx) {
+          if (list != null && list.size()>veridx) {
               name = list.get(veridx).name;
               lvtName = true;
+          } else if (list == null) {
+              // we're an exception type, probably. let's just fall through
           }
         }
       }
diff --git a/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7e781e4172f736a831b857ca7fd3060d95e6186
--- /dev/null
+++ b/test/org/jetbrains/java/decompiler/MinecraftDecompilationTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2000-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler;
+
+import org.hamcrest.Matchers;
+import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.util.InterpreterUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.*;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+public class MinecraftDecompilationTest {
+  private DecompilerTestFixture fixture;
+
+  private static final String MC_JAR = "minecraft_ff_in.jar";
+  @Before
+  public void setUp() throws IOException {
+    fixture = new DecompilerTestFixture();
+    // -din=1 -rbr=0 -dgs=1 -asc=1 -rsy=0
+    Map<String,Object> mcFFOptions = new HashMap<String,Object>() {{
+        put(IFernflowerPreferences.DECOMPILE_INNER,"1");
+        put(IFernflowerPreferences.REMOVE_BRIDGE, "0");
+        put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES,"1");
+        put(IFernflowerPreferences.ASCII_STRING_CHARACTERS,"1");
+        put(IFernflowerPreferences.REMOVE_SYNTHETIC,"0");
+    }};
+    fixture.setUp(mcFFOptions);
+    if (!new File(fixture.getTestDataDir(), MC_JAR).exists()) {
+        throw new RuntimeException("Missing "+MC_JAR+" in testData dir - aborting");
+    }
+  }
+
+  @After
+  public void tearDown() {
+//    fixture.tearDown();
+//    fixture = null;
+  }
+
+//  @Test
+//  public void testDirectory() {
+//    File classes = new File(fixture.getTempDir(), "classes");
+//    unpack(new File(fixture.getTestDataDir(), "mc-fernflower-in.jar"), classes);
+//
+//    ConsoleDecompiler decompiler = fixture.getDecompiler();
+//    decompiler.addSpace(classes, true);
+//    decompiler.decompileContext();
+//
+//    compareDirectories(new File(fixture.getTestDataDir(), "bulk"), fixture.getTargetDir());
+//  }
+
+  @Test
+  public void testJar() {
+    ConsoleDecompiler decompiler = fixture.getDecompiler();
+    decompiler.addSpace(new File(fixture.getTestDataDir(), MC_JAR), true);
+    decompiler.decompileContext();
+
+    File unpacked = new File(fixture.getTempDir(), "unpacked");
+    unpack(new File(fixture.getTargetDir(), "bulk.jar"), unpacked);
+
+//    compareDirectories(new File(fixture.getTestDataDir(), "bulk"), unpacked);
+  }
+
+  private static void unpack(File archive, File targetDir) {
+    try {
+      ZipFile zip = new ZipFile(archive);
+      try {
+        Enumeration<? extends ZipEntry> entries = zip.entries();
+        while (entries.hasMoreElements()) {
+          ZipEntry entry = entries.nextElement();
+          if (!entry.isDirectory()) {
+            File file = new File(targetDir, entry.getName());
+            assertTrue(file.getParentFile().mkdirs() || file.getParentFile().isDirectory());
+            InputStream in = zip.getInputStream(entry);
+            OutputStream out = new FileOutputStream(file);
+            InterpreterUtil.copyStream(in, out);
+            out.close();
+            in.close();
+          }
+        }
+      }
+      finally {
+        zip.close();
+      }
+    }
+    catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private static void compareDirectories(File expected, File actual) {
+    String[] expectedList = expected.list();
+    String[] actualList = actual.list();
+    assertThat(actualList, Matchers.arrayContainingInAnyOrder(expectedList));
+    for (String name : expectedList) {
+      File child = new File(expected, name);
+      if (child.isDirectory()) {
+        compareDirectories(child, new File(actual, name));
+      }
+    }
+  }
+}
