From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Wed, 12 Sep 2018 03:01:05 -0700
Subject: [PATCH] Prioritize self and enclosing class when encountering
 inconsistent InnerClass attributes.

The compiler encodes all REFERENCED inner classes into the class. The first found used to win, but now ThisClass > EnclosingClass > Others AccessTransformers only edit the targeted class as it can't find all references.
Fixes AccessTransformers.

Add -win option to suppress warnings on inconsistent inner class
information.

diff --git a/README.md b/README.md
index 225b42bcbd388c395fe51d2c5edda8d1cb1127b2..c41dd217b88663552b02ceac510ae13199b64b3c 100644
--- a/README.md
+++ b/README.md
@@ -64,6 +64,7 @@ The rest of options can be left as they are: they are aimed at professional reve
 - inn (1): check for IntelliJ IDEA-specific @NotNull annotation and remove inserted code if found
 - lac (0): decompile lambda expressions to anonymous classes
 - nls (0): define new line character to be used for output. 0 - '\r\n' (Windows), 1 - '\n' (Unix), default is OS-dependent
+- win (1): Whether to warn on inconsistent inner class entries
 - ind: indentation string (default is 3 spaces)
 - log (INFO): a logging level, possible values are TRACE, INFO, WARN, ERROR
 
diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 124cdd01c4b531937373127576b7f6db90ed48ed..908ec69d788adf63487106715f82141cc1c43dac 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -1180,6 +1180,10 @@ public class ClassWriter {
     }
   }
 
+  public static String getModifiers(int flags) {
+    return MODIFIERS.entrySet().stream().filter(e -> (e.getKey() & flags) != 0).map(Map.Entry::getValue).collect(Collectors.joining(" "));
+  }
+
   public static void appendTypeParameters(TextBuffer buffer, List<String> parameters, List<List<VarType>> bounds) {
     buffer.append('<');
 
diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 26ccf4b2124ab617bfeec45ebbf3451ab2e7aa6d..80b8fd01286f90c3f194385edef47df805611c98 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -42,10 +42,20 @@ public class ClassesProcessor implements CodeConstants {
     private String simpleName;
     private int type;
     private int accessFlags;
+    private String source;
 
     private static boolean equal(Inner o1, Inner o2) {
       return o1.type == o2.type && o1.accessFlags == o2.accessFlags && InterpreterUtil.equalObjects(o1.simpleName, o2.simpleName);
     }
+
+    @Override
+    public String toString() {
+      return simpleName + " " + ClassWriter.getModifiers(accessFlags) + " " + getType() + " " + source;
+    }
+
+    private String getType() {
+        return type == ClassNode.CLASS_ANONYMOUS ? "ANONYMOUS" : type == ClassNode.CLASS_LAMBDA ? "LAMBDA" : type == ClassNode.CLASS_LOCAL ? "LOCAL" : type == ClassNode.CLASS_MEMBER ? "MEMBER" : type == ClassNode.CLASS_ROOT ? "ROOT" : "UNKNOWN(" + type +")";
+    }
   }
 
   public ClassesProcessor(StructContext context) {
@@ -88,6 +98,7 @@ public class ClassesProcessor implements CodeConstants {
               rec.simpleName = simpleName;
               rec.type = entry.simpleNameIdx == 0 ? ClassNode.CLASS_ANONYMOUS : entry.outerNameIdx == 0 ? ClassNode.CLASS_LOCAL : ClassNode.CLASS_MEMBER;
               rec.accessFlags = entry.accessFlags;
+              rec.source = cl.qualifiedName;
 
               // nested class type
               if (entry.innerName != null) {
@@ -130,8 +141,17 @@ public class ClassesProcessor implements CodeConstants {
                   mapInnerClasses.put(innerName, rec);
                 }
                 else if (!Inner.equal(existingRec, rec)) {
-                  String message = "Inconsistent inner class entries for " + innerName + "!";
-                  DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+                  if (DecompilerContext.getOption(IFernflowerPreferences.WARN_INCONSISTENT_INNER_CLASSES)) {
+                    String message = "Inconsistent inner class entries for " + innerName + "!";
+                    DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+                    DecompilerContext.getLogger().writeMessage("  Old: " + existingRec.toString(), IFernflowerLogger.Severity.WARN);
+                    DecompilerContext.getLogger().writeMessage("  New: " + rec.toString(), IFernflowerLogger.Severity.WARN);
+                  }
+                  int oldPriority = existingRec.source.equals(innerName) ? 1 : existingRec.source.equals(enclClassName) ? 2 : 3;
+                  int newPriority = rec.source.equals(innerName) ? 1 : rec.source.equals(enclClassName) ? 2 : 3;
+                  if (newPriority < oldPriority) {
+                      mapInnerClasses.put(innerName, rec);
+                  }
                 }
 
                 // reference to the nested class
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index d91d9faebf718192a679c436792a54c24bed8c63..9c6dd387cce2377ffb3eefd7e55aa4b5a04953e7 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -55,6 +55,8 @@ public interface IFernflowerPreferences {
 
   String SKIP_EXTRA_FILES = "sef";
 
+  String WARN_INCONSISTENT_INNER_CLASSES = "win";
+
   Map<String, Object> DEFAULTS = getDefaults();
 
   static Map<String, Object> getDefaults() {
@@ -99,6 +101,7 @@ public interface IFernflowerPreferences {
     defaults.put(DUMP_ORIGINAL_LINES, "0");
     defaults.put(USE_JAD_VARNAMING, "0");
     defaults.put(SKIP_EXTRA_FILES, "0");
+    defaults.put(WARN_INCONSISTENT_INNER_CLASSES, "1");
 
     return Collections.unmodifiableMap(defaults);
   }
