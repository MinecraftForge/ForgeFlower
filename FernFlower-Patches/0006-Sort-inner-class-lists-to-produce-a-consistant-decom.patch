From fdff6cfcb291cf7dcba48ce13e2aefcb7dae0d5b Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Sat, 1 Aug 2015 18:40:43 -0700
Subject: [PATCH 006/122] Sort inner class lists to produce a consistant
 decompile. Different JVMs sort HashSets differently causing inner classes to
 get shuffled.

---
 .../jetbrains/java/decompiler/main/ClassesProcessor.java | 9 ++++++++-
 .../java/decompiler/main/rels/LambdaProcessor.java       | 2 ++
 .../java/decompiler/main/rels/NestedClassProcessor.java  | 1 +
 3 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 5a56641..b3e9d81 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -228,6 +228,7 @@ public class ClassesProcessor {
                 stack.add(nestedClass);
               }
             }
+            Collections.sort(superNode.nested);
           }
         }
       }
@@ -342,7 +343,7 @@ public class ClassesProcessor {
   }
 
 
-  public static class ClassNode {
+  public static class ClassNode implements Comparable<ClassNode> {
 
     public static final int CLASS_ROOT = 0;
     public static final int CLASS_MEMBER = 1;
@@ -441,5 +442,11 @@ public class ClassesProcessor {
       public boolean is_method_reference;
       public boolean is_content_method_static;
     }
+
+    @Override
+    public int compareTo(ClassNode o)
+    {
+        return this.classStruct.qualifiedName.compareTo(o.classStruct.qualifiedName);
+    }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
index 0704efd..809af6d 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
@@ -119,6 +119,7 @@ public class LambdaProcessor {
             }
           }
         }
+        Collections.sort(node.nested);
       }
 
       mt.releaseResources();
@@ -133,6 +134,7 @@ public class LambdaProcessor {
 
           parent_class.nested.add(nd);
           nd.parent = parent_class;
+          Collections.sort(parent_class.nested);
         }
       }
     }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index 798010e..9aedf22 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -248,6 +248,7 @@ public class NestedClassProcessor {
       if (setEnclosing.contains(node.classStruct.qualifiedName)) {
         node.nested.add(child);
         child.parent = node;
+        Collections.sort(node.nested);
 
         return true;
       }
-- 
2.21.0.windows.1

