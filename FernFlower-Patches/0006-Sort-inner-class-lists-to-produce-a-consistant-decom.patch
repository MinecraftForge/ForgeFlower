From fdff6cfcb291cf7dcba48ce13e2aefcb7dae0d5b Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Sat, 1 Aug 2015 18:40:43 -0700
Subject: Sort inner class lists to produce a consistant decompile. Different
 JVMs sort HashSets differently causing inner classes to get shuffled.


diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 5a56641c6f614fdf677f8e1900f803f73397867c..b3e9d81eaa3a4d86e4714adf2f8e007af831d670 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -228,6 +228,7 @@ public class ClassesProcessor {
                 stack.add(nestedClass);
               }
             }
+            Collections.sort(superNode.nested);
           }
         }
       }
@@ -342,7 +343,7 @@ public class ClassesProcessor {
   }
 
 
-  public static class ClassNode {
+  public static class ClassNode implements Comparable<ClassNode> {
 
     public static final int CLASS_ROOT = 0;
     public static final int CLASS_MEMBER = 1;
@@ -441,5 +442,11 @@ public class ClassesProcessor {
       public boolean is_method_reference;
       public boolean is_content_method_static;
     }
+
+    @Override
+    public int compareTo(ClassNode o)
+    {
+        return this.classStruct.qualifiedName.compareTo(o.classStruct.qualifiedName);
+    }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
index 0704efd84bdbd29cb6c9f5db79337147ac0b2be7..809af6d88b5f7c232539e0dbc4c7c8d7c5e26e3b 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
@@ -119,6 +119,7 @@ public class LambdaProcessor {
             }
           }
         }
+        Collections.sort(node.nested);
       }
 
       mt.releaseResources();
@@ -133,6 +134,7 @@ public class LambdaProcessor {
 
           parent_class.nested.add(nd);
           nd.parent = parent_class;
+          Collections.sort(parent_class.nested);
         }
       }
     }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index 798010e24206ffcfb76b1f4936f9b5d3709a7275..9aedf22af1f60b3e17752769462aee91cd9daeb0 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -248,6 +248,7 @@ public class NestedClassProcessor {
       if (setEnclosing.contains(node.classStruct.qualifiedName)) {
         node.nested.add(child);
         child.parent = node;
+        Collections.sort(node.nested);
 
         return true;
       }
-- 
2.28.0.windows.1

