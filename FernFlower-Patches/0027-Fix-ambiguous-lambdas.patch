From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Justin <jrd2558@gmail.com>
Date: Wed, 19 Sep 2018 22:51:00 -0700
Subject: [PATCH] Fix ambiguous lambdas


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index cb5d2a86ad56ab82e74843a8f6258c4059a0df52..2c8652d73727c1e3d76be49504c875b93befca11 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -1082,6 +1082,9 @@ public class ExprProcessor implements CodeConstants {
       (castNull && rightType.getType() == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType, Collections.emptyList()))) ||
       (castNarrowing && isIntConstant(exprent) && isNarrowedIntType(leftType));
 
+    boolean castLambda = !cast && exprent.type == Exprent.EXPRENT_NEW && !leftType.equals(rightType) &&
+                          lambdaNeedsCast(leftType, (NewExprent)exprent);
+
     boolean quote = cast && exprent.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST);
 
     // cast instead to 'byte' / 'short' when int constant is used as a value for 'Byte' / 'Short'
@@ -1096,6 +1099,8 @@ public class ExprProcessor implements CodeConstants {
 
     if (cast) buffer.append('(').append(ExprProcessor.getCastTypeName(leftType, Collections.emptyList())).append(')');
 
+    if (castLambda) buffer.append('(').append(getCastTypeName(rightType, Collections.emptyList())).append(')');
+
     if (quote) buffer.append('(');
 
     if (exprent.type == Exprent.EXPRENT_CONST) {
@@ -1127,4 +1132,12 @@ public class ExprProcessor implements CodeConstants {
   private static boolean isNarrowedIntType(VarType type) {
     return VarType.VARTYPE_INT.isStrictSuperset(type) || type.equals(VarType.VARTYPE_BYTE_OBJ) || type.equals(VarType.VARTYPE_SHORT_OBJ);
   }
+
+  private static boolean lambdaNeedsCast(VarType left, NewExprent exprent) {
+    if (exprent.isLambda() && !exprent.isMethodReference()) {
+      StructClass cls = DecompilerContext.getStructContext().getClass(left.getValue());
+      return cls == null || cls.getMethod(exprent.getLambdaMethodKey()) == null;
+    }
+    return false;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index 77fa57bfd13729f13feaa17525a9d8588c1e27a9..139932bdee7eefd94f1edb28f3aef898f3c062c3 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -811,7 +811,8 @@ public class InvocationExprent extends Exprent {
       if (md.params.length == parameters.size()) {
         boolean exact = true;
         for (int i = 0; i < md.params.length; i++) {
-          if (!md.params[i].equals(parameters.get(i).getExprType())) {
+          Exprent exp = parameters.get(i);
+          if (!md.params[i].equals(exp.getExprType()) || (exp.type == EXPRENT_NEW && ((NewExprent)exp).isLambda() && !((NewExprent)exp).isMethodReference())) {
             exact = false;
             missed.set(i);
           }
@@ -825,7 +826,8 @@ public class InvocationExprent extends Exprent {
       boolean failed = false;
       MethodDescriptor md = MethodDescriptor.parseDescriptor(mtt.getDescriptor());
       for (int i = 0; i < parameters.size(); i++) {
-        VarType ptype = parameters.get(i).getExprType();
+        Exprent exp = parameters.get(i);
+        VarType ptype = exp.getExprType();
         if (!missed.get(i)) {
           if (!md.params[i].equals(ptype)) {
             failed = true;
@@ -833,6 +835,17 @@ public class InvocationExprent extends Exprent {
           }
         }
         else {
+          if (exp.type == EXPRENT_NEW) {
+            NewExprent newExp = (NewExprent)exp;
+            if (newExp.isLambda() && !newExp.isMethodReference() && !DecompilerContext.getStructContext().instanceOf(md.params[i].getValue(), exp.getExprType().getValue())) {
+              StructClass pcls = DecompilerContext.getStructContext().getClass(md.params[i].getValue());
+              if (pcls != null && pcls.getMethod(newExp.getLambdaMethodKey()) == null) {
+                failed = true;
+                break;
+              }
+              continue;
+            }
+          }
           if (md.params[i].getType() == CodeConstants.TYPE_OBJECT) {
             if (ptype.getType() != CodeConstants.TYPE_NULL) {
               if (!DecompilerContext.getStructContext().instanceOf(ptype.getValue(), md.params[i].getValue())) {
@@ -860,7 +873,10 @@ public class InvocationExprent extends Exprent {
 
         GenericMethodDescriptor gen = mtt.getSignature(); //TODO: Find synthetic flags for params, as Enum generic signatures do no contain the String,int params
         if (gen != null && gen.parameterTypes.size() > i && gen.parameterTypes.get(i).isGeneric()) {
-          break;
+          Exprent exp = parameters.get(i);
+          if (exp.type != EXPRENT_NEW || !((NewExprent)exp).isLambda() || ((NewExprent)exp).isMethodReference()) {
+            break;
+          }
         }
 
         MethodDescriptor md = MethodDescriptor.parseDescriptor(mtt.getDescriptor());
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
index 8df7f76e7690bdd13463e94cca28a312ffa09bd5..74b5b1ead7cef7c63596155e817d854995c0ea3f 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
@@ -5,6 +5,8 @@ import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassWriter;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
+import org.jetbrains.java.decompiler.util.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
@@ -29,6 +31,7 @@ public class NewExprent extends Exprent {
   private boolean isVarArgParam;
   private boolean anonymous;
   private boolean lambda;
+  private boolean methodReference = false;
   private boolean enumConst;
   private List<VarType> genericArgs = new ArrayList<>();
 
@@ -49,6 +52,7 @@ public class NewExprent extends Exprent {
         anonymous = true;
         if (node.type == ClassNode.CLASS_LAMBDA) {
           lambda = true;
+          methodReference = node.lambdaInformation.is_method_reference;
         }
       }
     }
@@ -512,4 +516,17 @@ public class NewExprent extends Exprent {
   public void setEnumConst(boolean enumConst) {
     this.enumConst = enumConst;
   }
+
+  public boolean isMethodReference() {
+    return methodReference;
+  }
+
+  public String getLambdaMethodKey() {
+    ClassNode node = DecompilerContext.getClassProcessor().getMapRootClasses().get(newType.getValue());
+    if (node != null && constructor != null) {
+      String descriptor = ((PrimitiveConstant)constructor.getBootstrapArguments().get(0)).getString();
+      return InterpreterUtil.makeUniqueKey(node.lambdaInformation.method_name, descriptor);
+    }
+    return "";
+  }
 }
